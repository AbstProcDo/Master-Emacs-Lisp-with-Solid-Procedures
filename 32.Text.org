#+TITLE: 32.Text
* 32 Text
   :PROPERTIES:
   :CUSTOM_ID: text
   :END:

This chapter describes the functions that deal with the text in a buffer. Most examine, insert, or delete text in the current buffer, often operating at point or on text adjacent to point. Many are interactive. All the functions that change the text provide for undoing the changes (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]]).

Many text-related functions operate on a region of text defined by two buffer positions passed in arguments named start and end. These arguments should be either markers (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Markers][Markers]]) or numeric character positions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Positions][Positions]]). The order of these arguments does not matter; it is all right for start to be the end of the region and end the beginning. For example, =(delete-region 1 10)= and =(delete-region 10 1)= are equivalent. An =args-out-of-range= error is signaled if either start or end is outside the accessible portion of the buffer. In an interactive call, point and the mark are used for these arguments.

Throughout this chapter, "text" refers to the characters in the buffer, together with their properties (when relevant). Keep in mind that point is always between two characters, and the cursor appears on the character after point.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Near-Point][Near Point]]: Examining text in the vicinity of point.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Contents][Buffer Contents]]: Examining text in a general fashion.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Comparing-Text][Comparing Text]]: Comparing substrings of buffers.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Insertion][Insertion]]: Adding new text to a buffer.
5) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Commands-for-Insertion][Commands for Insertion]]: User-level commands to insert text.
6) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deletion][Deletion]]: Removing text from a buffer.
7) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#User_002dLevel-Deletion][User-Level Deletion]]: User-level commands to delete text.
8) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]]: Where removed text sometimes is saved for later use.
9) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]]: Undoing changes to the text of a buffer.
10) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Maintaining-Undo][Maintaining Undo]]: How to enable and disable undo information. How to control how much information is kept.
11) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Filling][Filling]]: Functions for explicit filling.
12) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Margins][Margins]]: How to specify margins for filling commands.
13) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Adaptive-Fill][Adaptive Fill]]: Adaptive Fill mode chooses a fill prefix from context.
14) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Filling][Auto Filling]]: How auto-fill mode is implemented to break lines.
15) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sorting][Sorting]]: Functions for sorting parts of the buffer.
16) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Columns][Columns]]: Computing horizontal positions, and using them.
17) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]]: Functions to insert or adjust indentation.
18) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Case-Changes][Case Changes]]: Case conversion of parts of the buffer.
19) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]: Assigning Lisp property lists to text characters.
20) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Substitution][Substitution]]: Replacing a given character wherever it appears.
21) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Registers][Registers]]: How registers are implemented. Accessing the text or position stored in a register.
22) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Transposition][Transposition]]: Swapping two portions of a buffer.
23) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Replacing][Replacing]]: Replacing the text of one buffer with the text of another buffer.
24) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Decompression][Decompression]]: Dealing with compressed data.
25) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Base-64][Base 64]]: Conversion to or from base 64 encoding.
26) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Checksum_002fHash][Checksum/Hash]]: Computing cryptographic hashes.
27) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#GnuTLS-Cryptography][GnuTLS Cryptography]]: Cryptographic algorithms imported from GnuTLS.
28) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Parsing-HTML_002fXML][Parsing HTML/XML]]: Parsing HTML and XML.
29) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Changes][Atomic Changes]]: Installing several buffer changes atomically.
30) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Change-Hooks][Change Hooks]]: Supplying functions to be run when text is changed.

* 32.1 Examining Text Near Point
    :PROPERTIES:
    :CUSTOM_ID: examining-text-near-point
    :END:

Many functions are provided to look at the characters around point. Several simple functions are described here. See also =looking-at= in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Regexp-Search][Regexp Search]].

In the following four functions, "beginning" or "end" of buffer refers to the beginning or end of the accessible portion.

--- Function: *char-after* &optional position

#+BEGIN_QUOTE
  This function returns the character in the current buffer at (i.e., immediately after) position position. If position is out of range for this purpose, either before the beginning of the buffer, or at or beyond the end, then the value is =nil=. The default for position is point.

  In the following example, assume that the first character in the buffer is '@':

  #+BEGIN_EXAMPLE
                (string (char-after 1))
                     ⇒ "@"
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *char-before* &optional position

#+BEGIN_QUOTE
  This function returns the character in the current buffer immediately before position position. If position is out of range for this purpose, either at or before the beginning of the buffer, or beyond the end, then the value is =nil=. The default for position is point.
#+END_QUOTE

--- Function: *following-char*

#+BEGIN_QUOTE
  This function returns the character following point in the current buffer. This is similar to =(char-after (point))=. However, if point is at the end of the buffer, then =following-char= returns 0.

  Remember that point is always between characters, and the cursor normally appears over the character following point. Therefore, the character returned by =following-char= is the character the cursor is over.

  In this example, point is between the 'a' and the 'c'.

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                Gentlemen may cry ``Pea-!-ce! Peace!,''
                but there is no peace.
                ---------- Buffer: foo ----------

                (string (preceding-char))
                     ⇒ "a"
                (string (following-char))
                     ⇒ "c"
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *preceding-char*

#+BEGIN_QUOTE
  This function returns the character preceding point in the current buffer. See above, under =following-char=, for an example. If point is at the beginning of the buffer, =preceding-char= returns 0.
#+END_QUOTE

--- Function: *bobp*

#+BEGIN_QUOTE
  This function returns =t= if point is at the beginning of the buffer. If narrowing is in effect, this means the beginning of the accessible portion of the text. See also =point-min= in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Point][Point]].
#+END_QUOTE

--- Function: *eobp*

#+BEGIN_QUOTE
  This function returns =t= if point is at the end of the buffer. If narrowing is in effect, this means the end of accessible portion of the text. See also =point-max= in See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Point][Point]].
#+END_QUOTE

--- Function: *bolp*

#+BEGIN_QUOTE
  This function returns =t= if point is at the beginning of a line. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Lines][Text Lines]]. The beginning of the buffer (or of its accessible portion) always counts as the beginning of a line.
#+END_QUOTE

--- Function: *eolp*

#+BEGIN_QUOTE
  This function returns =t= if point is at the end of a line. The end of the buffer (or of its accessible portion) is always considered the end of a line.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Comparing-Text][Comparing Text]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Near-Point][Near Point]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.2 Examining Buffer Contents
    :PROPERTIES:
    :CUSTOM_ID: examining-buffer-contents
    :END:

This section describes functions that allow a Lisp program to convert any portion of the text in the buffer into a string.

--- Function: *buffer-substring* start end

#+BEGIN_QUOTE
  This function returns a string containing a copy of the text of the region defined by positions start and end in the current buffer. If the arguments are not positions in the accessible portion of the buffer, =buffer-substring= signals an =args-out-of-range= error.

  Here's an example which assumes Font-Lock mode is not enabled:

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                This is the contents of buffer foo

                ---------- Buffer: foo ----------

                (buffer-substring 1 10)
                     ⇒ "This is t"
                (buffer-substring (point-max) 10)
                     ⇒ "he contents of buffer foo\n"
  #+END_EXAMPLE

  If the text being copied has any text properties, these are copied into the string along with the characters they belong to. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]. However, overlays (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlays][Overlays]]) in the buffer and their properties are ignored, not copied.

  For example, if Font-Lock mode is enabled, you might get results like these:

  #+BEGIN_EXAMPLE
                (buffer-substring 1 10)
                     ⇒ #("This is t" 0 1 (fontified t) 1 9 (fontified t))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *buffer-substring-no-properties* start end

#+BEGIN_QUOTE
  This is like =buffer-substring=, except that it does not copy text properties, just the characters themselves. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]].
#+END_QUOTE

--- Function: *buffer-string*

#+BEGIN_QUOTE
  This function returns the contents of the entire accessible portion of the current buffer, as a string.
#+END_QUOTE

If you need to make sure the resulting string, when copied to a different location, will not change its visual appearance due to reordering of bidirectional text, use the =buffer-substring-with-bidi-context= function (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Bidirectional-Display][buffer-substring-with-bidi-context]]).

--- Function: *filter-buffer-substring* start end &optional delete

#+BEGIN_QUOTE
  This function filters the buffer text between start and end using a function specified by the variable =filter-buffer-substring-function=, and returns the result.

  The default filter function consults the obsolete wrapper hook =filter-buffer-substring-functions= (see the documentation string of the macro =with-wrapper-hook= for the details about this obsolete facility), and the obsolete variable =buffer-substring-filters=. If both of these are =nil=, it returns the unaltered text from the buffer, i.e., what =buffer-substring= would return.

  If delete is non-=nil=, the function deletes the text between start and end after copying it, like =delete-and-extract-region=.

  Lisp code should use this function instead of =buffer-substring=, =buffer-substring-no-properties=, or =delete-and-extract-region= when copying into user-accessible data structures such as the kill-ring, X clipboard, and registers. Major and minor modes can modify =filter-buffer-substring-function= to alter such text as it is copied out of the buffer.
#+END_QUOTE

--- Variable: *filter-buffer-substring-function*

#+BEGIN_QUOTE
  The value of this variable is a function that =filter-buffer-substring= will call to do the actual work. The function receives three arguments, the same as those of =filter-buffer-substring=, which it should treat as per the documentation of that function. It should return the filtered text (and optionally delete the source text).
#+END_QUOTE

The following two variables are obsoleted by =filter-buffer-substring-function=, but are still supported for backward compatibility.

--- Variable: *filter-buffer-substring-functions*

#+BEGIN_QUOTE
  This obsolete variable is a wrapper hook, whose members should be functions that accept four arguments: fun, start, end, and delete. fun is a function that takes three arguments (start, end, and delete), and returns a string. In both cases, the start, end, and delete arguments are the same as those of =filter-buffer-substring=.

  The first hook function is passed a fun that is equivalent to the default operation of =filter-buffer-substring=, i.e., it returns the buffer-substring between start and end (processed by any =buffer-substring-filters=) and optionally deletes the original text from the buffer. In most cases, the hook function will call fun once, and then do its own processing of the result. The next hook function receives a fun equivalent to this, and so on. The actual return value is the result of all the hook functions acting in sequence.
#+END_QUOTE

--- Variable: *buffer-substring-filters*

#+BEGIN_QUOTE
  The value of this obsolete variable should be a list of functions that accept a single string argument and return another string. The default =filter-buffer-substring= function passes the buffer substring to the first function in this list, and the return value of each function is passed to the next function. The return value of the last function is passed to =filter-buffer-substring-functions=.
#+END_QUOTE

--- Function: *current-word* &optional strict really-word

#+BEGIN_QUOTE
  This function returns the symbol (or word) at or near point, as a string. The return value includes no text properties.

  If the optional argument really-word is non-=nil=, it finds a word; otherwise, it finds a symbol (which includes both word characters and symbol constituent characters).

  If the optional argument strict is non-=nil=, then point must be in or next to the symbol or word---if no symbol or word is there, the function returns =nil=. Otherwise, a nearby symbol or word on the same line is acceptable.
#+END_QUOTE

--- Function: *thing-at-point* thing &optional no-properties

#+BEGIN_QUOTE
  Return the thing around or next to point, as a string.

  The argument thing is a symbol which specifies a kind of syntactic entity. Possibilities include =symbol=, =list=, =sexp=, =defun=, =filename=, =url=, =word=, =sentence=, =whitespace=, =line=, =page=, and others.

  When the optional argument no-properties is non-=nil=, this function strips text properties from the return value.

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                Gentlemen may cry ``Pea-!-ce! Peace!,''
                but there is no peace.
                ---------- Buffer: foo ----------

                (thing-at-point 'word)
                     ⇒ "Peace"
                (thing-at-point 'line)
                     ⇒ "Gentlemen may cry ``Peace! Peace!,''\n"
                (thing-at-point 'whitespace)
                     ⇒ nil
  #+END_EXAMPLE
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Insertion][Insertion]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Contents][Buffer Contents]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.3 Comparing Text
    :PROPERTIES:
    :CUSTOM_ID: comparing-text
    :END:

This function lets you compare portions of the text in a buffer, without copying them into strings first.

--- Function: *compare-buffer-substrings* buffer1 start1 end1 buffer2 start2 end2

#+BEGIN_QUOTE
  This function lets you compare two substrings of the same buffer or two different buffers. The first three arguments specify one substring, giving a buffer (or a buffer name) and two positions within the buffer. The last three arguments specify the other substring in the same way. You can use =nil= for buffer1, buffer2, or both to stand for the current buffer.

  The value is negative if the first substring is less, positive if the first is greater, and zero if they are equal. The absolute value of the result is one plus the index of the first differing characters within the substrings.

  This function ignores case when comparing characters if =case-fold-search= is non-=nil=. It always ignores text properties.

  Suppose you have the text 'foobarbar haha!rara!' in the current buffer; then in this example the two substrings are 'rbar' and 'rara!'. The value is 2 because the first substring is greater at the second character.

  #+BEGIN_EXAMPLE
                (compare-buffer-substrings nil 6 11 nil 16 21)
                     ⇒ 2
  #+END_EXAMPLE
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Commands-for-Insertion][Commands for Insertion]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Comparing-Text][Comparing Text]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.4 Inserting Text
    :PROPERTIES:
    :CUSTOM_ID: inserting-text
    :END:

Insertion means adding new text to a buffer. The inserted text goes at point---between the character before point and the character after point. Some insertion functions leave point before the inserted text, while other functions leave it after. We call the former insertion after point and the latter insertion before point.

Insertion moves markers located at positions after the insertion point, so that they stay with the surrounding text (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Markers][Markers]]). When a marker points at the place of insertion, insertion may or may not relocate the marker, depending on the marker's insertion type (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Marker-Insertion-Types][Marker Insertion Types]]). Certain special functions such as =insert-before-markers= relocate all such markers to point after the inserted text, regardless of the markers' insertion type.

Insertion functions signal an error if the current buffer is read-only (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-Only-Buffers][Read Only Buffers]]) or if they insert within read-only text (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]]).

These functions copy text characters from strings and buffers along with their properties. The inserted characters have exactly the same properties as the characters they were copied from. By contrast, characters specified as separate arguments, not part of a string or buffer, inherit their text properties from the neighboring text.

The insertion functions convert text from unibyte to multibyte in order to insert in a multibyte buffer, and vice versa---if the text comes from a string or from a buffer. However, they do not convert unibyte character codes 128 through 255 to multibyte characters, not even if the current buffer is a multibyte buffer. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Converting-Representations][Converting Representations]].

--- Function: *insert* &rest args

#+BEGIN_QUOTE
  This function inserts the strings and/or characters args into the current buffer, at point, moving point forward. In other words, it inserts the text before point. An error is signaled unless all args are either strings or characters. The value is =nil=.
#+END_QUOTE

--- Function: *insert-before-markers* &rest args

#+BEGIN_QUOTE
  This function inserts the strings and/or characters args into the current buffer, at point, moving point forward. An error is signaled unless all args are either strings or characters. The value is =nil=.

  This function is unlike the other insertion functions in that it relocates markers initially pointing at the insertion point, to point after the inserted text. If an overlay begins at the insertion point, the inserted text falls outside the overlay; if a nonempty overlay ends at the insertion point, the inserted text falls inside that overlay.
#+END_QUOTE

--- Command: *insert-char* character &optional count inherit

#+BEGIN_QUOTE
  This command inserts count instances of character into the current buffer before point. The argument count must be an integer, and character must be a character.

  If called interactively, this command prompts for character using its Unicode name or its code point. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Inserting-Text][Inserting Text]].

  This function does not convert unibyte character codes 128 through 255 to multibyte characters, not even if the current buffer is a multibyte buffer. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Converting-Representations][Converting Representations]].

  If inherit is non-=nil=, the inserted characters inherit sticky text properties from the two characters before and after the insertion point. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sticky-Properties][Sticky Properties]].
#+END_QUOTE

--- Function: *insert-buffer-substring* from-buffer-or-name &optional start end

#+BEGIN_QUOTE
  This function inserts a portion of buffer from-buffer-or-name into the current buffer before point. The text inserted is the region between start (inclusive) and end (exclusive). (These arguments default to the beginning and end of the accessible portion of that buffer.) This function returns =nil=.

  In this example, the form is executed with buffer 'bar' as the current buffer. We assume that buffer 'bar' is initially empty.

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                We hold these truths to be self-evident, that all
                ---------- Buffer: foo ----------

                (insert-buffer-substring "foo" 1 20)
                     ⇒ nil

                ---------- Buffer: bar ----------
                We hold these truth-!-
                ---------- Buffer: bar ----------
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *insert-buffer-substring-no-properties* from-buffer-or-name &optional start end

#+BEGIN_QUOTE
  This is like =insert-buffer-substring= except that it does not copy any text properties.
#+END_QUOTE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sticky-Properties][Sticky Properties]], for other insertion functions that inherit text properties from the nearby text in addition to inserting it. Whitespace inserted by indentation functions also inherits text properties.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deletion][Deletion]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Insertion][Insertion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.5 User-Level Insertion Commands
    :PROPERTIES:
    :CUSTOM_ID: user-level-insertion-commands
    :END:

This section describes higher-level commands for inserting text, commands intended primarily for the user but useful also in Lisp programs.

--- Command: *insert-buffer* from-buffer-or-name

#+BEGIN_QUOTE
  This command inserts the entire accessible contents of from-buffer-or-name (which must exist) into the current buffer after point. It leaves the mark after the inserted text. The value is =nil=.
#+END_QUOTE

--- Command: *self-insert-command* count

#+BEGIN_QUOTE
  This command inserts the last character typed; it does so count times, before point, and returns =nil=. Most printing characters are bound to this command. In routine use, =self-insert-command= is the most frequently called function in Emacs, but programs rarely use it except to install it on a keymap.

  In an interactive call, count is the numeric prefix argument.

  Self-insertion translates the input character through =translation-table-for-input=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Translation-of-Characters][Translation of Characters]].

  This command calls =auto-fill-function= whenever that is non-=nil= and the character inserted is in the table =auto-fill-chars= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Filling][Auto Filling]]).

  This command performs abbrev expansion if Abbrev mode is enabled and the inserted character does not have word-constituent syntax. (See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Abbrevs][Abbrevs]], and [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Class-Table][Syntax Class Table]].) It is also responsible for calling =blink-paren-function= when the inserted character has close parenthesis syntax (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Blinking][Blinking]]).

  The final thing this command does is to run the hook =post-self-insert-hook=. You could use this to automatically reindent text as it is typed, for example. If any function on this hook needs to act on the region (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Region][The Region]]), it should make sure Delete Selection mode (see [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Using-Region][Delete Selection]]) doesn't delete the region before =post-self-insert-hook= functions are invoked. The way to do so is to add a function that returns =nil= to =self-insert-uses-region-functions=, a special hook that tells Delete Selection mode it should not delete the region.

  Do not try substituting your own definition of =self-insert-command= for the standard one. The editor command loop handles this function specially.
#+END_QUOTE

--- Command: *newline* &optional number-of-newlines

#+BEGIN_QUOTE
  This command inserts newlines into the current buffer before point. If number-of-newlines is supplied, that many newline characters are inserted.

  This function calls =auto-fill-function= if the current column number is greater than the value of =fill-column= and number-of-newlines is =nil=. Typically what =auto-fill-function= does is insert a newline; thus, the overall result in this case is to insert two newlines at different places: one at point, and another earlier in the line. =newline= does not auto-fill if number-of-newlines is non-=nil=.

  This command indents to the left margin if that is not zero. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Margins][Margins]].

  The value returned is =nil=. In an interactive call, count is the numeric prefix argument.
#+END_QUOTE

--- Variable: *overwrite-mode*

#+BEGIN_QUOTE
  This variable controls whether overwrite mode is in effect. The value should be =overwrite-mode-textual=, =overwrite-mode-binary=, or =nil=. =overwrite-mode-textual= specifies textual overwrite mode (treats newlines and tabs specially), and =overwrite-mode-binary= specifies binary overwrite mode (treats newlines and tabs like any other characters).
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#User_002dLevel-Deletion][User-Level Deletion]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Commands-for-Insertion][Commands for Insertion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.6 Deleting Text
    :PROPERTIES:
    :CUSTOM_ID: deleting-text
    :END:

Deletion means removing part of the text in a buffer, without saving it in the kill ring (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]]). Deleted text can't be yanked, but can be reinserted using the undo mechanism (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]]). Some deletion functions do save text in the kill ring in some special cases.

All of the deletion functions operate on the current buffer.

--- Command: *erase-buffer*

#+BEGIN_QUOTE
  This function deletes the entire text of the current buffer (/not/ just the accessible portion), leaving it empty. If the buffer is read-only, it signals a =buffer-read-only= error; if some of the text in it is read-only, it signals a =text-read-only= error. Otherwise, it deletes the text without asking for any confirmation. It returns =nil=.

  Normally, deleting a large amount of text from a buffer inhibits further auto-saving of that buffer because it has shrunk. However, =erase-buffer= does not do this, the idea being that the future text is not really related to the former text, and its size should not be compared with that of the former text.
#+END_QUOTE

--- Command: *delete-region* start end

#+BEGIN_QUOTE
  This command deletes the text between positions start and end in the current buffer, and returns =nil=. If point was inside the deleted region, its value afterward is start. Otherwise, point relocates with the surrounding text, as markers do.
#+END_QUOTE

--- Function: *delete-and-extract-region* start end

#+BEGIN_QUOTE
  This function deletes the text between positions start and end in the current buffer, and returns a string containing the text just deleted.

  If point was inside the deleted region, its value afterward is start. Otherwise, point relocates with the surrounding text, as markers do.
#+END_QUOTE

--- Command: *delete-char* count &optional killp

#+BEGIN_QUOTE
  This command deletes count characters directly after point, or before point if count is negative. If killp is non-=nil=, then it saves the deleted characters in the kill ring.

  In an interactive call, count is the numeric prefix argument, and killp is the unprocessed prefix argument. Therefore, if a prefix argument is supplied, the text is saved in the kill ring. If no prefix argument is supplied, then one character is deleted, but not saved in the kill ring.

  The value returned is always =nil=.
#+END_QUOTE

--- Command: *delete-backward-char* count &optional killp

#+BEGIN_QUOTE
  This command deletes count characters directly before point, or after point if count is negative. If killp is non-=nil=, then it saves the deleted characters in the kill ring.

  In an interactive call, count is the numeric prefix argument, and killp is the unprocessed prefix argument. Therefore, if a prefix argument is supplied, the text is saved in the kill ring. If no prefix argument is supplied, then one character is deleted, but not saved in the kill ring.

  The value returned is always =nil=.
#+END_QUOTE

--- Command: *backward-delete-char-untabify* count &optional killp

#+BEGIN_QUOTE
  This command deletes count characters backward, changing tabs into spaces. When the next character to be deleted is a tab, it is first replaced with the proper number of spaces to preserve alignment and then one of those spaces is deleted instead of the tab. If killp is non-=nil=, then the command saves the deleted characters in the kill ring.

  Conversion of tabs to spaces happens only if count is positive. If it is negative, exactly −count characters after point are deleted.

  In an interactive call, count is the numeric prefix argument, and killp is the unprocessed prefix argument. Therefore, if a prefix argument is supplied, the text is saved in the kill ring. If no prefix argument is supplied, then one character is deleted, but not saved in the kill ring.

  The value returned is always =nil=.
#+END_QUOTE

--- User Option: *backward-delete-char-untabify-method*

#+BEGIN_QUOTE
  This option specifies how =backward-delete-char-untabify= should deal with whitespace. Possible values include =untabify=, the default, meaning convert a tab to many spaces and delete one; =hungry=, meaning delete all tabs and spaces before point with one command; =all= meaning delete all tabs, spaces and newlines before point, and =nil=, meaning do nothing special for whitespace characters.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deletion][Deletion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.7 User-Level Deletion Commands
    :PROPERTIES:
    :CUSTOM_ID: user-level-deletion-commands
    :END:

This section describes higher-level commands for deleting text, commands intended primarily for the user but useful also in Lisp programs.

--- Command: *delete-horizontal-space* &optional backward-only

#+BEGIN_QUOTE
  This function deletes all spaces and tabs around point. It returns =nil=.

  If backward-only is non-=nil=, the function deletes spaces and tabs before point, but not after point.

  In the following examples, we call =delete-horizontal-space= four times, once on each line, with point between the second and third characters on the line each time.

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                I -!-thought
                I -!-     thought
                We-!- thought
                Yo-!-u thought
                ---------- Buffer: foo ----------

                (delete-horizontal-space)   ; Four times.
                     ⇒ nil

                ---------- Buffer: foo ----------
                Ithought
                Ithought
                Wethought
                You thought
                ---------- Buffer: foo ----------
  #+END_EXAMPLE
#+END_QUOTE

--- Command: *delete-indentation* &optional join-following-p

#+BEGIN_QUOTE
  This function joins the line point is on to the previous line, deleting any whitespace at the join and in some cases replacing it with one space. If join-following-p is non-=nil=, =delete-indentation= joins this line to the following line instead. The function returns =nil=.

  If there is a fill prefix, and the second of the lines being joined starts with the prefix, then =delete-indentation= deletes the fill prefix before joining the lines. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Margins][Margins]].

  In the example below, point is located on the line starting 'events', and it makes no difference if there are trailing spaces in the preceding line.

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                When in the course of human
                -!-    events, it becomes necessary
                ---------- Buffer: foo ----------

                (delete-indentation)
                     ⇒ nil

                ---------- Buffer: foo ----------
                When in the course of human-!- events, it becomes necessary
                ---------- Buffer: foo ----------
  #+END_EXAMPLE

  After the lines are joined, the function =fixup-whitespace= is responsible for deciding whether to leave a space at the junction.
#+END_QUOTE

--- Command: *fixup-whitespace*

#+BEGIN_QUOTE
  This function replaces all the horizontal whitespace surrounding point with either one space or no space, according to the context. It returns =nil=.

  At the beginning or end of a line, the appropriate amount of space is none. Before a character with close parenthesis syntax, or after a character with open parenthesis or expression-prefix syntax, no space is also appropriate. Otherwise, one space is appropriate. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Class-Table][Syntax Class Table]].

  In the example below, =fixup-whitespace= is called the first time with point before the word 'spaces' in the first line. For the second invocation, point is directly after the '('.

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                This has too many     -!-spaces
                This has too many spaces at the start of (-!-   this list)
                ---------- Buffer: foo ----------

                (fixup-whitespace)
                     ⇒ nil
                (fixup-whitespace)
                     ⇒ nil

                ---------- Buffer: foo ----------
                This has too many spaces
                This has too many spaces at the start of (this list)
                ---------- Buffer: foo ----------
  #+END_EXAMPLE
#+END_QUOTE

--- Command: *just-one-space* &optional n

#+BEGIN_QUOTE
  This command replaces any spaces and tabs around point with a single space, or n spaces if n is specified. It returns =nil=.
#+END_QUOTE

--- Command: *delete-blank-lines*

#+BEGIN_QUOTE
  This function deletes blank lines surrounding point. If point is on a blank line with one or more blank lines before or after it, then all but one of them are deleted. If point is on an isolated blank line, then it is deleted. If point is on a nonblank line, the command deletes all blank lines immediately following it.

  A blank line is defined as a line containing only tabs and spaces.

  =delete-blank-lines= returns =nil=.
#+END_QUOTE

--- Command: *delete-trailing-whitespace* &optional start end

#+BEGIN_QUOTE
  Delete trailing whitespace in the region defined by start and end.

  This command deletes whitespace characters after the last non-whitespace character in each line in the region.

  If this command acts on the entire buffer (i.e., if called interactively with the mark inactive, or called from Lisp with end =nil=), it also deletes all trailing lines at the end of the buffer if the variable =delete-trailing-lines= is non-=nil=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#User_002dLevel-Deletion][User-Level Deletion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.8 The Kill Ring
    :PROPERTIES:
    :CUSTOM_ID: the-kill-ring
    :END:

Kill functions delete text like the deletion functions, but save it so that the user can reinsert it by yanking. Most of these functions have 'kill-' in their name. By contrast, the functions whose names start with 'delete-' normally do not save text for yanking (though they can still be undone); these are deletion functions.

Most of the kill commands are primarily for interactive use, and are not described here. What we do describe are the functions provided for use in writing such commands. You can use these functions to write commands for killing text. When you need to delete text for internal purposes within a Lisp function, you should normally use deletion functions, so as not to disturb the kill ring contents. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deletion][Deletion]].

Killed text is saved for later yanking in the kill ring. This is a list that holds a number of recent kills, not just the last text kill. We call this a "ring" because yanking treats it as having elements in a cyclic order. The list is kept in the variable =kill-ring=, and can be operated on with the usual functions for lists; there are also specialized functions, described in this section, that treat it as a ring.

Some people think this use of the word "kill" is unfortunate, since it refers to operations that specifically /do not/ destroy the entities killed. This is in sharp contrast to ordinary life, in which death is permanent and killed entities do not come back to life. Therefore, other metaphors have been proposed. For example, the term "cut ring" makes sense to people who, in pre-computer days, used scissors and paste to cut up and rearrange manuscripts. However, it would be difficult to change the terminology now.

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Kill-Ring-Concepts][Kill Ring Concepts]]: What text looks like in the kill ring.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Kill-Functions][Kill Functions]]: Functions that kill text.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yanking][Yanking]]: How yanking is done.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yank-Commands][Yank Commands]]: Commands that access the kill ring.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Low_002dLevel-Kill-Ring][Low-Level Kill Ring]]: Functions and variables for kill ring access.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Internals-of-Kill-Ring][Internals of Kill Ring]]: Variables that hold kill ring data.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Kill-Functions][Kill Functions]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]]

** 32.8.1 Kill Ring Concepts
     :PROPERTIES:
     :CUSTOM_ID: kill-ring-concepts
     :END:

The kill ring records killed text as strings in a list, most recent first. A short kill ring, for example, might look like this:

#+BEGIN_EXAMPLE
         ("some text" "a different piece of text" "even older text")
#+END_EXAMPLE

When the list reaches =kill-ring-max= entries in length, adding a new entry automatically deletes the last entry.

When kill commands are interwoven with other commands, each kill command makes a new entry in the kill ring. Multiple kill commands in succession build up a single kill ring entry, which would be yanked as a unit; the second and subsequent consecutive kill commands add text to the entry made by the first one.

For yanking, one entry in the kill ring is designated the front of the ring. Some yank commands rotate the ring by designating a different element as the front. But this virtual rotation doesn't change the list itself---the most recent entry always comes first in the list.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yanking][Yanking]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Kill-Ring-Concepts][Kill Ring Concepts]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]]

** 32.8.2 Functions for Killing
     :PROPERTIES:
     :CUSTOM_ID: functions-for-killing
     :END:

=kill-region= is the usual subroutine for killing text. Any command that calls this function is a kill command (and should probably have 'kill' in its name). =kill-region= puts the newly killed text in a new element at the beginning of the kill ring or adds it to the most recent element. It determines automatically (using =last-command=) whether the previous command was a kill command, and if so appends the killed text to the most recent entry.

The commands described below can filter the killed text before they save it in the kill ring. They call =filter-buffer-substring= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Contents][Buffer Contents]]) to perform the filtering. By default, there's no filtering, but major and minor modes and hook functions can set up filtering, so that text saved in the kill ring is different from what was in the buffer.

--- Command: *kill-region* start end &optional region

#+BEGIN_QUOTE
  This function kills the stretch of text between start and end; but if the optional argument region is non-=nil=, it ignores start and end, and kills the text in the current region instead. The text is deleted but saved in the kill ring, along with its text properties. The value is always =nil=.

  In an interactive call, start and end are point and the mark, and region is always non-=nil=, so the command always kills the text in the current region.

  If the buffer or text is read-only, =kill-region= modifies the kill ring just the same, then signals an error without modifying the buffer. This is convenient because it lets the user use a series of kill commands to copy text from a read-only buffer into the kill ring.
#+END_QUOTE

--- User Option: *kill-read-only-ok*

#+BEGIN_QUOTE
  If this option is non-=nil=, =kill-region= does not signal an error if the buffer or text is read-only. Instead, it simply returns, updating the kill ring but not changing the buffer.
#+END_QUOTE

--- Command: *copy-region-as-kill* start end &optional region

#+BEGIN_QUOTE
  This function saves the stretch of text between start and end on the kill ring (including text properties), but does not delete the text from the buffer. However, if the optional argument region is non-=nil=, the function ignores start and end, and saves the current region instead. It always returns =nil=.

  In an interactive call, start and end are point and the mark, and region is always non-=nil=, so the command always saves the text in the current region.

  The command does not set =this-command= to =kill-region=, so a subsequent kill command does not append to the same kill ring entry.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yank-Commands][Yank Commands]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Kill-Functions][Kill Functions]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]]

** 32.8.3 Yanking
     :PROPERTIES:
     :CUSTOM_ID: yanking
     :END:

Yanking means inserting text from the kill ring, but it does not insert the text blindly. The =yank= command, and related commands, use =insert-for-yank= to perform special processing on the text before it is inserted.

--- Function: *insert-for-yank* string

#+BEGIN_QUOTE
  This function works like =insert=, except that it processes the text in string according to the =yank-handler= text property, as well as the variables =yank-handled-properties= and =yank-excluded-properties= (see below), before inserting the result into the current buffer.
#+END_QUOTE

--- Function: *insert-buffer-substring-as-yank* buf &optional start end

#+BEGIN_QUOTE
  This function resembles =insert-buffer-substring=, except that it processes the text according to =yank-handled-properties= and =yank-excluded-properties=. (It does not handle the =yank-handler= property, which does not normally occur in buffer text anyway.)
#+END_QUOTE

If you put a =yank-handler= text property on all or part of a string, that alters how =insert-for-yank= inserts the string. If different parts of the string have different =yank-handler= values (comparison being done with =eq=), each substring is handled separately. The property value must be a list of one to four elements, with the following format (where elements after the first may be omitted):

#+BEGIN_EXAMPLE
         (function param noexclude undo)
#+END_EXAMPLE

Here is what the elements do:

- function

  When function is non-=nil=, it is called instead of =insert= to insert the string, with one argument---the string to insert.

- param

  If param is present and non-=nil=, it replaces string (or the substring of string being processed) as the object passed to function (or =insert=). For example, if function is =yank-rectangle=, param should be a list of strings to insert as a rectangle.

- noexclude

  If noexclude is present and non-=nil=, that disables the normal action of =yank-handled-properties= and =yank-excluded-properties= on the inserted string.

- undo

  If undo is present and non-=nil=, it is a function that will be called by =yank-pop= to undo the insertion of the current object. It is called with two arguments, the start and end of the current region. function can set =yank-undo-function= to override the undo value.

--- User Option: *yank-handled-properties*

#+BEGIN_QUOTE
  This variable specifies special text property handling conditions for yanked text. It takes effect after the text has been inserted (either normally, or via the =yank-handler= property), and prior to =yank-excluded-properties= taking effect.

  The value should be an alist of elements =(=prop=.=fun=)=. Each alist element is handled in order. The inserted text is scanned for stretches of text having text properties =eq= to prop; for each such stretch, fun is called with three arguments: the value of the property, and the start and end positions of the text.
#+END_QUOTE

--- User Option: *yank-excluded-properties*

#+BEGIN_QUOTE
  The value of this variable is the list of properties to remove from inserted text. Its default value contains properties that might lead to annoying results, such as causing the text to respond to the mouse or specifying key bindings. It takes effect after =yank-handled-properties=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Low_002dLevel-Kill-Ring][Low-Level Kill Ring]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yanking][Yanking]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]]

** 32.8.4 Functions for Yanking
     :PROPERTIES:
     :CUSTOM_ID: functions-for-yanking
     :END:

This section describes higher-level commands for yanking, which are intended primarily for the user but useful also in Lisp programs. Both =yank= and =yank-pop= honor the =yank-excluded-properties= variable and =yank-handler= text property (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yanking][Yanking]]).

--- Command: *yank* &optional arg

#+BEGIN_QUOTE
  This command inserts before point the text at the front of the kill ring. It sets the mark at the beginning of that text, using =push-mark= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Mark][The Mark]]), and puts point at the end.

  If arg is a non-=nil= list (which occurs interactively when the user types C-u with no digits), then =yank= inserts the text as described above, but puts point before the yanked text and sets the mark after it.

  If arg is a number, then =yank= inserts the argth most recently killed text---the argth element of the kill ring list, counted cyclically from the front, which is considered the first element for this purpose.

  =yank= does not alter the contents of the kill ring, unless it used text provided by another program, in which case it pushes that text onto the kill ring. However if arg is an integer different from one, it rotates the kill ring to place the yanked string at the front.

  =yank= returns =nil=.
#+END_QUOTE

--- Command: *yank-pop* &optional arg

#+BEGIN_QUOTE
  This command replaces the just-yanked entry from the kill ring with a different entry from the kill ring.

  This is allowed only immediately after a =yank= or another =yank-pop=. At such a time, the region contains text that was just inserted by yanking. =yank-pop= deletes that text and inserts in its place a different piece of killed text. It does not add the deleted text to the kill ring, since it is already in the kill ring somewhere. It does however rotate the kill ring to place the newly yanked string at the front.

  If arg is =nil=, then the replacement text is the previous element of the kill ring. If arg is numeric, the replacement is the argth previous kill. If arg is negative, a more recent kill is the replacement.

  The sequence of kills in the kill ring wraps around, so that after the oldest one comes the newest one, and before the newest one goes the oldest.

  The return value is always =nil=.
#+END_QUOTE

--- Variable: *yank-undo-function*

#+BEGIN_QUOTE
  If this variable is non-=nil=, the function =yank-pop= uses its value instead of =delete-region= to delete the text inserted by the previous =yank= or =yank-pop= command. The value must be a function of two arguments, the start and end of the current region.

  The function =insert-for-yank= automatically sets this variable according to the undo element of the =yank-handler= text property, if there is one.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Internals-of-Kill-Ring][Internals of Kill Ring]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yank-Commands][Yank Commands]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]]

** 32.8.5 Low-Level Kill Ring
     :PROPERTIES:
     :CUSTOM_ID: low-level-kill-ring
     :END:

These functions and variables provide access to the kill ring at a lower level, but are still convenient for use in Lisp programs, because they take care of interaction with window system selections (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-System-Selections][Window System Selections]]).

--- Function: *current-kill* n &optional do-not-move

#+BEGIN_QUOTE
  The function =current-kill= rotates the yanking pointer, which designates the front of the kill ring, by n places (from newer kills to older ones), and returns the text at that place in the ring.

  If the optional second argument do-not-move is non-=nil=, then =current-kill= doesn't alter the yanking pointer; it just returns the nth kill, counting from the current yanking pointer.

  If n is zero, indicating a request for the latest kill, =current-kill= calls the value of =interprogram-paste-function= (documented below) before consulting the kill ring. If that value is a function and calling it returns a string or a list of several strings, =current-kill= pushes the strings onto the kill ring and returns the first string. It also sets the yanking pointer to point to the kill-ring entry of the first string returned by =interprogram-paste-function=, regardless of the value of do-not-move. Otherwise, =current-kill= does not treat a zero value for n specially: it returns the entry pointed at by the yanking pointer and does not move the yanking pointer.
#+END_QUOTE

--- Function: *kill-new* string &optional replace

#+BEGIN_QUOTE
  This function pushes the text string onto the kill ring and makes the yanking pointer point to it. It discards the oldest entry if appropriate. It also invokes the values of =interprogram-paste-function= (subject to the user option =save-interprogram-paste-before-kill=) and =interprogram-cut-function= (see below).

  If replace is non-=nil=, then =kill-new= replaces the first element of the kill ring with string, rather than pushing string onto the kill ring.
#+END_QUOTE

--- Function: *kill-append* string before-p

#+BEGIN_QUOTE
  This function appends the text string to the first entry in the kill ring and makes the yanking pointer point to the combined entry. Normally string goes at the end of the entry, but if before-p is non-=nil=, it goes at the beginning. This function calls =kill-new= as a subroutine, thus causing the values of =interprogram-cut-function= and possibly =interprogram-paste-function= (see below) to be invoked by extension.
#+END_QUOTE

--- Variable: *interprogram-paste-function*

#+BEGIN_QUOTE
  This variable provides a way of transferring killed text from other programs, when you are using a window system. Its value should be =nil= or a function of no arguments.

  If the value is a function, =current-kill= calls it to get the most recent kill. If the function returns a non-=nil= value, then that value is used as the most recent kill. If it returns =nil=, then the front of the kill ring is used.

  To facilitate support for window systems that support multiple selections, this function may also return a list of strings. In that case, the first string is used as the most recent kill, and all the other strings are pushed onto the kill ring, for easy access by =yank-pop=.

  The normal use of this function is to get the window system's clipboard as the most recent kill, even if the selection belongs to another application. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-System-Selections][Window System Selections]]. However, if the clipboard contents come from the current Emacs session, this function should return =nil=.
#+END_QUOTE

--- Variable: *interprogram-cut-function*

#+BEGIN_QUOTE
  This variable provides a way of communicating killed text to other programs, when you are using a window system. Its value should be =nil= or a function of one required argument.

  If the value is a function, =kill-new= and =kill-append= call it with the new first element of the kill ring as the argument.

  The normal use of this function is to put newly killed text in the window system's clipboard. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-System-Selections][Window System Selections]].
#+END_QUOTE

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Low_002dLevel-Kill-Ring][Low-Level Kill Ring]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]]

** 32.8.6 Internals of the Kill Ring
     :PROPERTIES:
     :CUSTOM_ID: internals-of-the-kill-ring
     :END:

The variable =kill-ring= holds the kill ring contents, in the form of a list of strings. The most recent kill is always at the front of the list.

The =kill-ring-yank-pointer= variable points to a link in the kill ring list, whose car is the text to yank next. We say it identifies the front of the ring. Moving =kill-ring-yank-pointer= to a different link is called rotating the kill ring. We call the kill ring a "ring" because the functions that move the yank pointer wrap around from the end of the list to the beginning, or vice-versa. Rotation of the kill ring is virtual; it does not change the value of =kill-ring=.

Both =kill-ring= and =kill-ring-yank-pointer= are Lisp variables whose values are normally lists. The word "pointer" in the name of the =kill-ring-yank-pointer= indicates that the variable's purpose is to identify one element of the list for use by the next yank command.

The value of =kill-ring-yank-pointer= is always =eq= to one of the links in the kill ring list. The element it identifies is the car of that link. Kill commands, which change the kill ring, also set this variable to the value of =kill-ring=. The effect is to rotate the ring so that the newly killed text is at the front.

Here is a diagram that shows the variable =kill-ring-yank-pointer= pointing to the second entry in the kill ring =("some text" "a different piece of text" "yet older text")=.

#+BEGIN_EXAMPLE
         kill-ring                  ---- kill-ring-yank-pointer
           |                       |
           |                       v
           |     --- ---          --- ---      --- ---
            --> |   |   |------> |   |   |--> |   |   |--> nil
                 --- ---          --- ---      --- ---
                  |                |            |
                  |                |            |
                  |                |             -->"yet older text"
                  |                |
                  |                 --> "a different piece of text"
                  |
                   --> "some text"
#+END_EXAMPLE

This state of affairs might occur after C-y (=yank=) immediately followed by M-y (=yank-pop=).

--- Variable: *kill-ring*

#+BEGIN_QUOTE
  This variable holds the list of killed text sequences, most recently killed first.
#+END_QUOTE

--- Variable: *kill-ring-yank-pointer*

#+BEGIN_QUOTE
  This variable's value indicates which element of the kill ring is at the front of the ring for yanking. More precisely, the value is a tail of the value of =kill-ring=, and its car is the kill string that C-y should yank.
#+END_QUOTE

--- User Option: *kill-ring-max*

#+BEGIN_QUOTE
  The value of this variable is the maximum length to which the kill ring can grow, before elements are thrown away at the end. The default value for =kill-ring-max= is 60.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Maintaining-Undo][Maintaining Undo]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Kill-Ring][The Kill Ring]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.9 Undo
    :PROPERTIES:
    :CUSTOM_ID: undo
    :END:

Most buffers have an undo list, which records all changes made to the buffer's text so that they can be undone. (The buffers that don't have one are usually special-purpose buffers for which Emacs assumes that undoing is not useful. In particular, any buffer whose name begins with a space has its undo recording off by default; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Names][Buffer Names]].) All the primitives that modify the text in the buffer automatically add elements to the front of the undo list, which is in the variable =buffer-undo-list=.

--- Variable: *buffer-undo-list*

#+BEGIN_QUOTE
  This buffer-local variable's value is the undo list of the current buffer. A value of =t= disables the recording of undo information.
#+END_QUOTE

Here are the kinds of elements an undo list can have:

- position

  This kind of element records a previous value of point; undoing this element moves point to position. Ordinary cursor motion does not make any sort of undo record, but deletion operations use these entries to record where point was before the command.

- =(=beg=.=end=)=

  This kind of element indicates how to delete text that was inserted. Upon insertion, the text occupied the range beg--end in the buffer.

- =(=text=.=position=)=

  This kind of element indicates how to reinsert text that was deleted. The deleted text itself is the string text. The place to reinsert it is =(abs=position=)=. If position is positive, point was at the beginning of the deleted text, otherwise it was at the end. Zero or more (marker . adjustment) elements follow immediately after this element.

- =(t .=time-flag=)=

  This kind of element indicates that an unmodified buffer became modified. A time-flag of the form =(=sec-high sec-low microsec picosec=)= represents the visited file's modification time as of when it was previously visited or saved, using the same format as =current-time=; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Time-of-Day][Time of Day]]. A time-flag of 0 means the buffer does not correspond to any file; −1 means the visited file previously did not exist. =primitive-undo= uses these values to determine whether to mark the buffer as unmodified once again; it does so only if the file's status matches that of time-flag.

- =(nil=property value beg=.=end=)=

  This kind of element records a change in a text property. Here's how you might undo the change: =(put-text-property beg end property value)=

- =(=marker=.=adjustment=)=

  This kind of element records the fact that the marker marker was relocated due to deletion of surrounding text, and that it moved adjustment character positions. If the marker's location is consistent with the (text . position) element preceding it in the undo list, then undoing this element moves marker − adjustment characters.

- =(apply=funname=.=args=)=

  This is an extensible undo item, which is undone by calling funname with arguments args.

- =(apply=delta beg end funname=.=args=)=

  This is an extensible undo item, which records a change limited to the range beg to end, which increased the size of the buffer by delta characters. It is undone by calling funname with arguments args. This kind of element enables undo limited to a region to determine whether the element pertains to that region.

- =nil=

  This element is a boundary. The elements between two boundaries are called a change group; normally, each change group corresponds to one keyboard command, and undo commands normally undo an entire group as a unit.

--- Function: *undo-boundary*

#+BEGIN_QUOTE
  This function places a boundary element in the undo list. The undo command stops at such a boundary, and successive undo commands undo to earlier and earlier boundaries. This function returns =nil=.

  Calling this function explicitly is useful for splitting the effects of a command into more than one unit. For example, =query-replace= calls =undo-boundary= after each replacement, so that the user can undo individual replacements one by one.

  Mostly, however, this function is called automatically at an appropriate time.
#+END_QUOTE

--- Function: *undo-auto-amalgamate*

#+BEGIN_QUOTE
  The editor command loop automatically calls =undo-boundary= just before executing each key sequence, so that each undo normally undoes the effects of one command. A few exceptional commands are amalgamating: these commands generally cause small changes to buffers, so with these a boundary is inserted only every 20th command, allowing the changes to be undone as a group. By default, the commands =self-insert-command=, which produces self-inserting input characters (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Commands-for-Insertion][Commands for Insertion]]), and =delete-char=, which deletes characters (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deletion][Deletion]]), are amalgamating. Where a command affects the contents of several buffers, as may happen, for example, when a function on the =post-command-hook= affects a buffer other than the =current-buffer=, then =undo-boundary= will be called in each of the affected buffers.
#+END_QUOTE

--- Variable: *undo-auto-current-boundary-timer*

#+BEGIN_QUOTE
  Some buffers, such as process buffers, can change even when no commands are executing. In these cases, =undo-boundary= is normally called periodically by the timer in this variable. Setting this variable to non-=nil= prevents this behavior.
#+END_QUOTE

--- Variable: *undo-in-progress*

#+BEGIN_QUOTE
  This variable is normally =nil=, but the undo commands bind it to =t=. This is so that various kinds of change hooks can tell when they're being called for the sake of undoing.
#+END_QUOTE

--- Function: *primitive-undo* count list

#+BEGIN_QUOTE
  This is the basic function for undoing elements of an undo list. It undoes the first count elements of list, returning the rest of list.

  =primitive-undo= adds elements to the buffer's undo list when it changes the buffer. Undo commands avoid confusion by saving the undo list value at the beginning of a sequence of undo operations. Then the undo operations use and update the saved value. The new elements added by undoing are not part of this saved value, so they don't interfere with continuing to undo.

  This function does not bind =undo-in-progress=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Filling][Filling]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.10 Maintaining Undo Lists
    :PROPERTIES:
    :CUSTOM_ID: maintaining-undo-lists
    :END:

This section describes how to enable and disable undo information for a given buffer. It also explains how the undo list is truncated automatically so it doesn't get too big.

Recording of undo information in a newly created buffer is normally enabled to start with; but if the buffer name starts with a space, the undo recording is initially disabled. You can explicitly enable or disable undo recording with the following two functions, or by setting =buffer-undo-list= yourself.

--- Command: *buffer-enable-undo* &optional buffer-or-name

#+BEGIN_QUOTE
  This command enables recording undo information for buffer buffer-or-name, so that subsequent changes can be undone. If no argument is supplied, then the current buffer is used. This function does nothing if undo recording is already enabled in the buffer. It returns =nil=.

  In an interactive call, buffer-or-name is the current buffer. You cannot specify any other buffer.
#+END_QUOTE

--- Command: *buffer-disable-undo* &optional buffer-or-name

#+BEGIN_QUOTE
  This function discards the undo list of buffer-or-name, and disables further recording of undo information. As a result, it is no longer possible to undo either previous changes or any subsequent changes. If the undo list of buffer-or-name is already disabled, this function has no effect.

  In an interactive call, BUFFER-OR-NAME is the current buffer. You cannot specify any other buffer. This function returns =nil=.
#+END_QUOTE

As editing continues, undo lists get longer and longer. To prevent them from using up all available memory space, garbage collection trims them back to size limits you can set. (For this purpose, the size of an undo list measures the cons cells that make up the list, plus the strings of deleted text.) Three variables control the range of acceptable sizes: =undo-limit=, =undo-strong-limit= and =undo-outer-limit=. In these variables, size is counted as the number of bytes occupied, which includes both saved text and other data.

--- User Option: *undo-limit*

#+BEGIN_QUOTE
  This is the soft limit for the acceptable size of an undo list. The change group at which this size is exceeded is the last one kept.
#+END_QUOTE

--- User Option: *undo-strong-limit*

#+BEGIN_QUOTE
  This is the upper limit for the acceptable size of an undo list. The change group at which this size is exceeded is discarded itself (along with all older change groups). There is one exception: the very latest change group is only discarded if it exceeds =undo-outer-limit=.
#+END_QUOTE

--- User Option: *undo-outer-limit*

#+BEGIN_QUOTE
  If at garbage collection time the undo info for the current command exceeds this limit, Emacs discards the info and displays a warning. This is a last ditch limit to prevent memory overflow.
#+END_QUOTE

--- User Option: *undo-ask-before-discard*

#+BEGIN_QUOTE
  If this variable is non-=nil=, when the undo info exceeds =undo-outer-limit=, Emacs asks in the echo area whether to discard the info. The default value is =nil=, which means to discard it automatically.

  This option is mainly intended for debugging. Garbage collection is inhibited while the question is asked, which means that Emacs might leak memory if the user waits too long before answering the question.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Margins][Margins]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Maintaining-Undo][Maintaining Undo]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.11 Filling
    :PROPERTIES:
    :CUSTOM_ID: filling
    :END:

Filling means adjusting the lengths of lines (by moving the line breaks) so that they are nearly (but no greater than) a specified maximum width. Additionally, lines can be justified, which means inserting spaces to make the left and/or right margins line up precisely. The width is controlled by the variable =fill-column=. For ease of reading, lines should be no longer than 70 or so columns.

You can use Auto Fill mode (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Filling][Auto Filling]]) to fill text automatically as you insert it, but changes to existing text may leave it improperly filled. Then you must fill the text explicitly.

Most of the commands in this section return values that are not meaningful. All the functions that do filling take note of the current left margin, current right margin, and current justification style (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Margins][Margins]]). If the current justification style is =none=, the filling functions don't actually do anything.

Several of the filling functions have an argument justify. If it is non-=nil=, that requests some kind of justification. It can be =left=, =right=, =full=, or =center=, to request a specific style of justification. If it is =t=, that means to use the current justification style for this part of the text (see =current-justification=, below). Any other value is treated as =full=.

When you call the filling functions interactively, using a prefix argument implies the value =full= for justify.

--- Command: *fill-paragraph* &optional justify region

#+BEGIN_QUOTE
  This command fills the paragraph at or after point. If justify is non-=nil=, each line is justified as well. It uses the ordinary paragraph motion commands to find paragraph boundaries. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Paragraphs][Paragraphs]].

  When region is non-=nil=, then if Transient Mark mode is enabled and the mark is active, this command calls =fill-region= to fill all the paragraphs in the region, instead of filling only the current paragraph. When this command is called interactively, region is =t=.
#+END_QUOTE

--- Command: *fill-region* start end &optional justify nosqueeze to-eop

#+BEGIN_QUOTE
  This command fills each of the paragraphs in the region from start to end. It justifies as well if justify is non-=nil=.

  If nosqueeze is non-=nil=, that means to leave whitespace other than line breaks untouched. If to-eop is non-=nil=, that means to keep filling to the end of the paragraph---or the next hard newline, if =use-hard-newlines= is enabled (see below).

  The variable =paragraph-separate= controls how to distinguish paragraphs. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Standard-Regexps][Standard Regexps]].
#+END_QUOTE

--- Command: *fill-individual-paragraphs* start end &optional justify citation-regexp

#+BEGIN_QUOTE
  This command fills each paragraph in the region according to its individual fill prefix. Thus, if the lines of a paragraph were indented with spaces, the filled paragraph will remain indented in the same fashion.

  The first two arguments, start and end, are the beginning and end of the region to be filled. The third and fourth arguments, justify and citation-regexp, are optional. If justify is non-=nil=, the paragraphs are justified as well as filled. If citation-regexp is non-=nil=, it means the function is operating on a mail message and therefore should not fill the header lines. If citation-regexp is a string, it is used as a regular expression; if it matches the beginning of a line, that line is treated as a citation marker.

  Ordinarily, =fill-individual-paragraphs= regards each change in indentation as starting a new paragraph. If =fill-individual-varying-indent= is non-=nil=, then only separator lines separate paragraphs. That mode can handle indented paragraphs with additional indentation on the first line.
#+END_QUOTE

--- User Option: *fill-individual-varying-indent*

#+BEGIN_QUOTE
  This variable alters the action of =fill-individual-paragraphs= as described above.
#+END_QUOTE

--- Command: *fill-region-as-paragraph* start end &optional justify nosqueeze squeeze-after

#+BEGIN_QUOTE
  This command considers a region of text as a single paragraph and fills it. If the region was made up of many paragraphs, the blank lines between paragraphs are removed. This function justifies as well as filling when justify is non-=nil=.

  If nosqueeze is non-=nil=, that means to leave whitespace other than line breaks untouched. If squeeze-after is non-=nil=, it specifies a position in the region, and means don't canonicalize spaces before that position.

  In Adaptive Fill mode, this command calls =fill-context-prefix= to choose a fill prefix by default. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Adaptive-Fill][Adaptive Fill]].
#+END_QUOTE

--- Command: *justify-current-line* &optional how eop nosqueeze

#+BEGIN_QUOTE
  This command inserts spaces between the words of the current line so that the line ends exactly at =fill-column=. It returns =nil=.

  The argument how, if non-=nil= specifies explicitly the style of justification. It can be =left=, =right=, =full=, =center=, or =none=. If it is =t=, that means to follow specified justification style (see =current-justification=, below). =nil= means to do full justification.

  If eop is non-=nil=, that means do only left-justification if =current-justification= specifies full justification. This is used for the last line of a paragraph; even if the paragraph as a whole is fully justified, the last line should not be.

  If nosqueeze is non-=nil=, that means do not change interior whitespace.
#+END_QUOTE

--- User Option: *default-justification*

#+BEGIN_QUOTE
  This variable's value specifies the style of justification to use for text that doesn't specify a style with a text property. The possible values are =left=, =right=, =full=, =center=, or =none=. The default value is =left=.
#+END_QUOTE

--- Function: *current-justification*

#+BEGIN_QUOTE
  This function returns the proper justification style to use for filling the text around point.

  This returns the value of the =justification= text property at point, or the variable =default-justification= if there is no such text property. However, it returns =nil= rather than =none= to mean "don't justify".
#+END_QUOTE

--- User Option: *sentence-end-double-space*

#+BEGIN_QUOTE
  If this variable is non-=nil=, a period followed by just one space does not count as the end of a sentence, and the filling functions avoid breaking the line at such a place.
#+END_QUOTE

--- User Option: *sentence-end-without-period*

#+BEGIN_QUOTE
  If this variable is non-=nil=, a sentence can end without a period. This is used for languages like Thai, where sentences end with a double space but without a period.
#+END_QUOTE

--- User Option: *sentence-end-without-space*

#+BEGIN_QUOTE
  If this variable is non-=nil=, it should be a string of characters that can end a sentence without following spaces.
#+END_QUOTE

--- User Option: *fill-separate-heterogeneous-words-with-space*

#+BEGIN_QUOTE
  If this variable is non-=nil=, two words of different kind (e.g., English and CJK) will be separated with a space when concatenating one that is in the end of a line and the other that is in the beginning of the next line for filling.
#+END_QUOTE

--- Variable: *fill-paragraph-function*

#+BEGIN_QUOTE
  This variable provides a way to override the filling of paragraphs. If its value is non-=nil=, =fill-paragraph= calls this function to do the work. If the function returns a non-=nil= value, =fill-paragraph= assumes the job is done, and immediately returns that value.

  The usual use of this feature is to fill comments in programming language modes. If the function needs to fill a paragraph in the usual way, it can do so as follows:

  #+BEGIN_EXAMPLE
                (let ((fill-paragraph-function nil))
                  (fill-paragraph arg))
  #+END_EXAMPLE
#+END_QUOTE

--- Variable: *fill-forward-paragraph-function*

#+BEGIN_QUOTE
  This variable provides a way to override how the filling functions, such as =fill-region= and =fill-paragraph=, move forward to the next paragraph. Its value should be a function, which is called with a single argument n, the number of paragraphs to move, and should return the difference between n and the number of paragraphs actually moved. The default value of this variable is =forward-paragraph=. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Paragraphs][Paragraphs]].
#+END_QUOTE

--- Variable: *use-hard-newlines*

#+BEGIN_QUOTE
  If this variable is non-=nil=, the filling functions do not delete newlines that have the =hard= text property. These hard newlines act as paragraph separators. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Hard-and-Soft-Newlines][Hard and Soft Newlines]].
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Adaptive-Fill][Adaptive Fill]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Filling][Filling]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.12 Margins for Filling
    :PROPERTIES:
    :CUSTOM_ID: margins-for-filling
    :END:

--- User Option: *fill-prefix*


  This buffer-local variable, if =non-nil=, specifies a string of text that appears at the beginning of normal text lines and should be disregarded when filling them. Any line that fails to start with the fill prefix is considered the start of a paragraph; so is any line that starts with the fill prefix followed by additional whitespace. Lines that start with the fill prefix but no additional whitespace are ordinary text lines that can be filled together. The resulting filled lines also start with the fill prefix.

  The fill prefix follows the left margin whitespace, if any.


--- User Option: *fill-column*


  This buffer-local variable specifies the maximum width of filled lines. Its value should be an integer, which is a number of columns. All the filling, justification, and centering commands are affected by this variable, including Auto Fill mode (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Filling][Auto Filling]]).

  As a practical matter, if you are writing text for other people to read, you should set =fill-column= to no more than 70. Otherwise the line will be too long for people to read comfortably, and this can make the text seem clumsy.

  The default value for =fill-column= is 70.


--- Command: *set-left-margin* from to margin

#+BEGIN_QUOTE
  This sets the =left-margin= property on the text from from to to to the value margin. If Auto Fill mode is enabled, this command also refills the region to fit the new margin.
#+END_QUOTE

--- Command: *set-right-margin* from to margin

#+BEGIN_QUOTE
  This sets the =right-margin= property on the text from from to to to the value margin. If Auto Fill mode is enabled, this command also refills the region to fit the new margin.
#+END_QUOTE

--- Function: *current-left-margin*

#+BEGIN_QUOTE
  This function returns the proper left margin value to use for filling the text around point. The value is the sum of the =left-margin= property of the character at the start of the current line (or zero if none), and the value of the variable =left-margin=.
#+END_QUOTE

--- Function: *current-fill-column*

#+BEGIN_QUOTE
  This function returns the proper fill column value to use for filling the text around point. The value is the value of the =fill-column= variable, minus the value of the =right-margin= property of the character after point.
#+END_QUOTE

--- Command: *move-to-left-margin* &optional n force

#+BEGIN_QUOTE
  This function moves point to the left margin of the current line. The column moved to is determined by calling the function =current-left-margin=. If the argument n is non-=nil=, =move-to-left-margin= moves forward n−1 lines first.

  If force is non-=nil=, that says to fix the line's indentation if that doesn't match the left margin value.
#+END_QUOTE

--- Function: *delete-to-left-margin* &optional from to

#+BEGIN_QUOTE
  This function removes left margin indentation from the text between from and to. The amount of indentation to delete is determined by calling =current-left-margin=. In no case does this function delete non-whitespace. If from and to are omitted, they default to the whole buffer.
#+END_QUOTE

--- Function: *indent-to-left-margin*

#+BEGIN_QUOTE
  This function adjusts the indentation at the beginning of the current line to the value specified by the variable =left-margin=. (That may involve either inserting or deleting whitespace.) This function is value of =indent-line-function= in Paragraph-Indent Text mode.
#+END_QUOTE

--- User Option: *left-margin*

#+BEGIN_QUOTE
  This variable specifies the base left margin column. In Fundamental mode, indents to this column. This variable automatically becomes buffer-local when set in any fashion.
#+END_QUOTE

--- User Option: *fill-nobreak-predicate*

#+BEGIN_QUOTE
  This variable gives major modes a way to specify not to break a line at certain places. Its value should be a list of functions. Whenever filling considers breaking the line at a certain place in the buffer, it calls each of these functions with no arguments and with point located at that place. If any of the functions returns non-=nil=, then the line won't be broken there.
#+END_QUOTE

* 32.13 Adaptive Fill Mode
    :PROPERTIES:
    :CUSTOM_ID: adaptive-fill-mode
    :END:

When Adaptive Fill Mode is enabled, Emacs determines the fill prefix automatically from the text in each paragraph being filled rather than using a predetermined value. During filling, this fill prefix gets inserted at the start of the second and subsequent lines of the paragraph as described in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Filling][Filling]], and in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Filling][Auto Filling]].

--- User Option: *adaptive-fill-mode*

#+BEGIN_QUOTE
  Adaptive Fill mode is enabled when this variable is non-=nil=. It is =t= by default.
#+END_QUOTE

--- Function: *fill-context-prefix* from to

#+BEGIN_QUOTE
  This function implements the heart of Adaptive Fill mode; it chooses a fill prefix based on the text between from and to, typically the start and end of a paragraph. It does this by looking at the first two lines of the paragraph, based on the variables described below.

  Usually, this function returns the fill prefix, a string. However, before doing this, the function makes a final check (not specially mentioned in the following) that a line starting with this prefix wouldn't look like the start of a paragraph. Should this happen, the function signals the anomaly by returning =nil= instead.

  In detail, =fill-context-prefix= does this:

  1. It takes a candidate for the fill prefix from the first line---it tries first the function in =adaptive-fill-function= (if any), then the regular expression =adaptive-fill-regexp= (see below). The first non-=nil= result of these, or the empty string if they're both =nil=, becomes the first line's candidate.
  2. If the paragraph has as yet only one line, the function tests the validity of the prefix candidate just found. The function then returns the candidate if it's valid, or a string of spaces otherwise. (see the description of =adaptive-fill-first-line-regexp= below).
  3. When the paragraph already has two lines, the function next looks for a prefix candidate on the second line, in just the same way it did for the first line. If it doesn't find one, it returns =nil=.
  4. The function now compares the two candidate prefixes heuristically: if the non-whitespace characters in the line 2 candidate occur in the same order in the line 1 candidate, the function returns the line 2 candidate. Otherwise, it returns the largest initial substring which is common to both candidates (which might be the empty string).
#+END_QUOTE

--- User Option: *adaptive-fill-regexp*

#+BEGIN_QUOTE
  Adaptive Fill mode matches this regular expression against the text starting after the left margin whitespace (if any) on a line; the characters it matches are that line's candidate for the fill prefix.

  The default value matches whitespace with certain punctuation characters intermingled.
#+END_QUOTE

--- User Option: *adaptive-fill-first-line-regexp*

#+BEGIN_QUOTE
  Used only in one-line paragraphs, this regular expression acts as an additional check of the validity of the one available candidate fill prefix: the candidate must match this regular expression, or match =comment-start-skip=. If it doesn't, =fill-context-prefix= replaces the candidate with a string of spaces of the same width as it.

  The default value of this variable is ="\\=[ \t]*\'"`, which matches only a string of whitespace. The effect of this default is to force the fill prefixes found in one-line paragraphs always to be pure whitespace.
#+END_QUOTE

--- User Option: *adaptive-fill-function*

#+BEGIN_QUOTE
  You can specify more complex ways of choosing a fill prefix automatically by setting this variable to a function. The function is called with point after the left margin (if any) of a line, and it must preserve point. It should return either that line's fill prefix or =nil=, meaning it has failed to determine a prefix.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sorting][Sorting]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Adaptive-Fill][Adaptive Fill]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.14 Auto Filling
    :PROPERTIES:
    :CUSTOM_ID: auto-filling
    :END:

Auto Fill mode is a minor mode that fills lines automatically as text is inserted. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Auto-Fill][Auto Fill]]. This section describes some variables used by Auto Fill mode. For a description of functions that you can call explicitly to fill and justify existing text, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Filling][Filling]].

Auto Fill mode also enables the functions that change the margins and justification style to refill portions of the text. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Margins][Margins]].

--- Variable: *auto-fill-function*

#+BEGIN_QUOTE
  The value of this buffer-local variable should be a function (of no arguments) to be called after self-inserting a character from the table =auto-fill-chars=, see below. It may be =nil=, in which case nothing special is done in that case.

  The value of =auto-fill-function= is =do-auto-fill= when Auto Fill mode is enabled. That is a function whose sole purpose is to implement the usual strategy for breaking a line.
#+END_QUOTE

--- Variable: *normal-auto-fill-function*

#+BEGIN_QUOTE
  This variable specifies the function to use for =auto-fill-function=, if and when Auto Fill is turned on. Major modes can set buffer-local values for this variable to alter how Auto Fill works.
#+END_QUOTE

--- Variable: *auto-fill-chars*

#+BEGIN_QUOTE
  A char table of characters which invoke =auto-fill-function= when self-inserted---space and newline in most language environments. They have an entry =t= in the table.
#+END_QUOTE

--- User Option: *comment-auto-fill-only-comments*

#+BEGIN_QUOTE
  This variable, if non-=nil=, means to fill lines automatically within comments only. More precisely, this means that if a comment syntax was defined for the current buffer, then self-inserting a character outside of a comment will not call =auto-fill-function=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Columns][Columns]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Filling][Auto Filling]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.15 Sorting Text
    :PROPERTIES:
    :CUSTOM_ID: sorting-text
    :END:

The sorting functions described in this section all rearrange text in a buffer. This is in contrast to the function =sort=, which rearranges the order of the elements of a list (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Rearrangement][Rearrangement]]). The values returned by these functions are not meaningful.

--- Function: *sort-subr* reverse nextrecfun endrecfun &optional startkeyfun endkeyfun predicate

#+BEGIN_QUOTE
  This function is the general text-sorting routine that subdivides a buffer into records and then sorts them. Most of the commands in this section use this function.

  To understand how =sort-subr= works, consider the whole accessible portion of the buffer as being divided into disjoint pieces called sort records. The records may or may not be contiguous, but they must not overlap. A portion of each sort record (perhaps all of it) is designated as the sort key. Sorting rearranges the records in order by their sort keys.

  Usually, the records are rearranged in order of ascending sort key. If the first argument to the =sort-subr= function, reverse, is non-=nil=, the sort records are rearranged in order of descending sort key.

  The next four arguments to =sort-subr= are functions that are called to move point across a sort record. They are called many times from within =sort-subr=.

  1. nextrecfun

     is called with point at the end of a record. This function moves point to the start of the next record. The first record is assumed to start at the position of point when

     #+BEGIN_EXAMPLE
         sort-subr
     #+END_EXAMPLE

     is called. Therefore, you should usually move point to the beginning of the buffer before calling

     #+BEGIN_EXAMPLE
         sort-subr
     #+END_EXAMPLE

     .

     This function can indicate there are no more sort records by leaving point at the end of the buffer.

  2. endrecfun is called with point within a record. It moves point to the end of the record.

  3. startkeyfun is called to move point from the start of a record to the start of the sort key. This argument is optional; if it is omitted, the whole record is the sort key. If supplied, the function should either return a non-=nil= value to be used as the sort key, or return =nil= to indicate that the sort key is in the buffer starting at point. In the latter case, endkeyfun is called to find the end of the sort key.

  4. endkeyfun is called to move point from the start of the sort key to the end of the sort key. This argument is optional. If startkeyfun returns =nil= and this argument is omitted (or =nil=), then the sort key extends to the end of the record. There is no need for endkeyfun if startkeyfun returns a non-=nil= value.

  The argument predicate is the function to use to compare keys. If keys are numbers, it defaults to =<=; otherwise it defaults to =string<=.

  As an example of =sort-subr=, here is the complete function definition for =sort-lines=:

  #+BEGIN_EXAMPLE
                ;; Note that the first two lines of doc string
                ;; are effectively one line when viewed by a user.
                (defun sort-lines (reverse beg end)
                  "Sort lines in region alphabetically;\
                 argument means descending order.
                Called from a program, there are three arguments:
                REVERSE (non-nil means reverse order),\
                 BEG and END (region to sort).
                The variable `sort-fold-case' determines\
                 whether alphabetic case affects
                the sort order."
                  (interactive "P\nr")
                  (save-excursion
                    (save-restriction
                      (narrow-to-region beg end)
                      (goto-char (point-min))
                      (let ((inhibit-field-text-motion t))
                        (sort-subr reverse 'forward-line 'end-of-line)))))
  #+END_EXAMPLE

  Here =forward-line= moves point to the start of the next record, and =end-of-line= moves point to the end of record. We do not pass the arguments startkeyfun and endkeyfun, because the entire record is used as the sort key.

  The =sort-paragraphs= function is very much the same, except that its =sort-subr= call looks like this:

  #+BEGIN_EXAMPLE
                (sort-subr reverse
                           (function
                            (lambda ()
                              (while (and (not (eobp))
                                          (looking-at paragraph-separate))
                                (forward-line 1))))
                           'forward-paragraph)
  #+END_EXAMPLE

  Markers pointing into any sort records are left with no useful position after =sort-subr= returns.
#+END_QUOTE

--- User Option: *sort-fold-case*

#+BEGIN_QUOTE
  If this variable is non-=nil=, =sort-subr= and the other buffer sorting functions ignore case when comparing strings.
#+END_QUOTE

--- Command: *sort-regexp-fields* reverse record-regexp key-regexp start end

#+BEGIN_QUOTE
  This command sorts the region between start and end alphabetically as specified by record-regexp and key-regexp. If reverse is a negative integer, then sorting is in reverse order.

  Alphabetical sorting means that two sort keys are compared by comparing the first characters of each, the second characters of each, and so on. If a mismatch is found, it means that the sort keys are unequal; the sort key whose character is less at the point of first mismatch is the lesser sort key. The individual characters are compared according to their numerical character codes in the Emacs character set.

  The value of the record-regexp argument specifies how to divide the buffer into sort records. At the end of each record, a search is done for this regular expression, and the text that matches it is taken as the next record. For example, the regular expression '\^.+$', which matches lines with at least one character besides a newline, would make each such line into a sort record. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Regular-Expressions][Regular Expressions]], for a description of the syntax and meaning of regular expressions.

  The value of the key-regexp argument specifies what part of each record is the sort key. The key-regexp could match the whole record, or only a part. In the latter case, the rest of the record has no effect on the sorted order of records, but it is carried along when the record moves to its new position.

  The key-regexp argument can refer to the text matched by a subexpression of record-regexp, or it can be a regular expression on its own.

  If key-regexp is:

  - '\digit'

    then the text matched by the digitth '(...)' parenthesis grouping in record-regexp is the sort key.

  - '&'

    then the whole record is the sort key.

  - a regular expression

    then =sort-regexp-fields= searches for a match for the regular expression within the record. If such a match is found, it is the sort key. If there is no match for key-regexp within a record then that record is ignored, which means its position in the buffer is not changed. (The other records may move around it.)

  For example, if you plan to sort all the lines in the region by the first word on each line starting with the letter 'f', you should set record-regexp to ‘\^.*$' and set key-regexp to '<f\w*>'. The resulting expression looks like this:

  #+BEGIN_EXAMPLE
                (sort-regexp-fields nil "^.*$" "\\<f\\w*\\>"
                                    (region-beginning)
                                    (region-end))
  #+END_EXAMPLE

  If you call =sort-regexp-fields= interactively, it prompts for record-regexp and key-regexp in the minibuffer.
#+END_QUOTE

--- Command: *sort-lines* reverse start end

#+BEGIN_QUOTE
  This command alphabetically sorts lines in the region between start and end. If reverse is non-=nil=, the sort is in reverse order.
#+END_QUOTE

--- Command: *sort-paragraphs* reverse start end

#+BEGIN_QUOTE
  This command alphabetically sorts paragraphs in the region between start and end. If reverse is non-=nil=, the sort is in reverse order.
#+END_QUOTE

--- Command: *sort-pages* reverse start end

#+BEGIN_QUOTE
  This command alphabetically sorts pages in the region between start and end. If reverse is non-=nil=, the sort is in reverse order.
#+END_QUOTE

--- Command: *sort-fields* field start end

#+BEGIN_QUOTE
  This command sorts lines in the region between start and end, comparing them alphabetically by the fieldth field of each line. Fields are separated by whitespace and numbered starting from 1. If field is negative, sorting is by the −fieldth field from the end of the line. This command is useful for sorting tables.
#+END_QUOTE

--- Command: *sort-numeric-fields* field start end

#+BEGIN_QUOTE
  This command sorts lines in the region between start and end, comparing them numerically by the fieldth field of each line. Fields are separated by whitespace and numbered starting from 1. The specified field must contain a number in each line of the region. Numbers starting with 0 are treated as octal, and numbers starting with '0x' are treated as hexadecimal.

  If field is negative, sorting is by the −fieldth field from the end of the line. This command is useful for sorting tables.
#+END_QUOTE

--- User Option: *sort-numeric-base*

#+BEGIN_QUOTE
  This variable specifies the default radix for =sort-numeric-fields= to parse numbers.
#+END_QUOTE

--- Command: *sort-columns* reverse &optional beg end

#+BEGIN_QUOTE
  This command sorts the lines in the region between beg and end, comparing them alphabetically by a certain range of columns. The column positions of beg and end bound the range of columns to sort on.

  If reverse is non-=nil=, the sort is in reverse order.

  One unusual thing about this command is that the entire line containing position beg, and the entire line containing position end, are included in the region sorted.

  Note that =sort-columns= rejects text that contains tabs, because tabs could be split across the specified columns. Use M-x untabify to convert tabs to spaces before sorting.

  When possible, this command actually works by calling the =sort= utility program.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sorting][Sorting]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.16 Counting Columns
    :PROPERTIES:
    :CUSTOM_ID: counting-columns
    :END:

The column functions convert between a character position (counting characters from the beginning of the buffer) and a column position (counting screen characters from the beginning of a line).

These functions count each character according to the number of columns it occupies on the screen. This means control characters count as occupying 2 or 4 columns, depending upon the value of =ctl-arrow=, and tabs count as occupying a number of columns that depends on the value of =tab-width= and on the column where the tab begins. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Usual-Display][Usual Display]].

Column number computations ignore the width of the window and the amount of horizontal scrolling. Consequently, a column value can be arbitrarily high. The first (or leftmost) column is numbered 0. They also ignore overlays and text properties, aside from invisibility.

--- Function: *current-column*

#+BEGIN_QUOTE
  This function returns the horizontal position of point, measured in columns, counting from 0 at the left margin. The column position is the sum of the widths of all the displayed representations of the characters between the start of the current line and point.
#+END_QUOTE

--- Command: *move-to-column* column &optional force

#+BEGIN_QUOTE
  This function moves point to column in the current line. The calculation of column takes into account the widths of the displayed representations of the characters between the start of the line and point.

  When called interactively, column is the value of prefix numeric argument. If column is not an integer, an error is signaled.

  If it is impossible to move to column column because that is in the middle of a multicolumn character such as a tab, point moves to the end of that character. However, if force is non-=nil=, and column is in the middle of a tab, then =move-to-column= either converts the tab into spaces (when =indent-tabs-mode= is =nil=), or inserts enough spaces before it (otherwise), so that point can move precisely to column column. Other multicolumn characters can cause anomalies despite force, since there is no way to split them.

  The argument force also has an effect if the line isn't long enough to reach column column; if it is =t=, that means to add whitespace at the end of the line to reach that column.

  The return value is the column number actually moved to.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Case-Changes][Case Changes]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Columns][Columns]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.17 Indentation
    :PROPERTIES:
    :CUSTOM_ID: indentation
    :END:

The indentation functions are used to examine, move to, and change whitespace that is at the beginning of a line. Some of the functions can also change whitespace elsewhere on a line. Columns and indentation count from zero at the left margin.

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Primitive-Indent][Primitive Indent]]: Functions used to count and insert indentation.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mode_002dSpecific-Indent][Mode-Specific Indent]]: Customize indentation for different modes.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Region-Indent][Region Indent]]: Indent all the lines in a region.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Relative-Indent][Relative Indent]]: Indent the current line based on previous lines.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indent-Tabs][Indent Tabs]]: Adjustable, typewriter-like tab stops.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Motion-by-Indent][Motion by Indent]]: Move to first non-blank character.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mode_002dSpecific-Indent][Mode-Specific Indent]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]]

** 32.17.1 Indentation Primitives
     :PROPERTIES:
     :CUSTOM_ID: indentation-primitives
     :END:

This section describes the primitive functions used to count and insert indentation. The functions in the following sections use these primitives. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Size-of-Displayed-Text][Size of Displayed Text]], for related functions.

--- Function: *current-indentation*

#+BEGIN_QUOTE
  This function returns the indentation of the current line, which is the horizontal position of the first nonblank character. If the contents are entirely blank, then this is the horizontal position of the end of the line.
#+END_QUOTE

--- Command: *indent-to* column &optional minimum

#+BEGIN_QUOTE
  This function indents from point with tabs and spaces until column is reached. If minimum is specified and non-=nil=, then at least that many spaces are inserted even if this requires going beyond column. Otherwise the function does nothing if point is already beyond column. The value is the column at which the inserted indentation ends.

  The inserted whitespace characters inherit text properties from the surrounding text (usually, from the preceding text only). See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sticky-Properties][Sticky Properties]].
#+END_QUOTE

--- User Option: *indent-tabs-mode*

#+BEGIN_QUOTE
  If this variable is non-=nil=, indentation functions can insert tabs as well as spaces. Otherwise, they insert only spaces. Setting this variable automatically makes it buffer-local in the current buffer.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Region-Indent][Region Indent]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Primitive-Indent][Primitive Indent]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]]

** 32.17.2 Indentation Controlled by Major Mode
     :PROPERTIES:
     :CUSTOM_ID: indentation-controlled-by-major-mode
     :END:

An important function of each major mode is to customize the key to indent properly for the language being edited. This section describes the mechanism of the key and how to control it. The functions in this section return unpredictable values.

--- Command: *indent-for-tab-command* &optional rigid

#+BEGIN_QUOTE
  This is the command bound to in most editing modes. Its usual action is to indent the current line, but it can alternatively insert a tab character or indent a region.

  Here is what it does:

  - First, it checks whether Transient Mark mode is enabled and the region is active. If so, it calls =indent-region= to indent all the text in the region (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Region-Indent][Region Indent]]).\\
  - Otherwise, if the indentation function in =indent-line-function= is =indent-to-left-margin= (a trivial command that inserts a tab character), or if the variable =tab-always-indent= specifies that a tab character ought to be inserted (see below), then it inserts a tab character.\\
  - Otherwise, it indents the current line; this is done by calling the function in =indent-line-function=. If the line is already indented, and the value of =tab-always-indent= is =complete= (see below), it tries completing the text at point.

  If rigid is non-=nil= (interactively, with a prefix argument), then after this command indents a line or inserts a tab, it also rigidly indents the entire balanced expression which starts at the beginning of the current line, in order to reflect the new indentation. This argument is ignored if the command indents the region.
#+END_QUOTE

--- Variable: *indent-line-function*

#+BEGIN_QUOTE
  This variable's value is the function to be used by =indent-for-tab-command=, and various other indentation commands, to indent the current line. It is usually assigned by the major mode; for instance, Lisp mode sets it to =lisp-indent-line=, C mode sets it to =c-indent-line=, and so on. The default value is =indent-relative=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto_002dIndentation][Auto-Indentation]].
#+END_QUOTE

--- Command: *indent-according-to-mode*

#+BEGIN_QUOTE
  This command calls the function in =indent-line-function= to indent the current line in a way appropriate for the current major mode.
#+END_QUOTE

--- Command: *newline-and-indent*

#+BEGIN_QUOTE
  This function inserts a newline, then indents the new line (the one following the newline just inserted) according to the major mode. It does indentation by calling =indent-according-to-mode=.
#+END_QUOTE

--- Command: *reindent-then-newline-and-indent*

#+BEGIN_QUOTE
  This command reindents the current line, inserts a newline at point, and then indents the new line (the one following the newline just inserted). It does indentation on both lines by calling =indent-according-to-mode=.
#+END_QUOTE

--- User Option: *tab-always-indent*

#+BEGIN_QUOTE
  This variable can be used to customize the behavior of the (=indent-for-tab-command=) command. If the value is =t= (the default), the command normally just indents the current line. If the value is =nil=, the command indents the current line only if point is at the left margin or in the line's indentation; otherwise, it inserts a tab character. If the value is =complete=, the command first tries to indent the current line, and if the line was already indented, it calls =completion-at-point= to complete the text at point (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-in-Buffers][Completion in Buffers]]).
#+END_QUOTE

Some major modes need to support embedded regions of text whose syntax belongs to a different major mode. Examples include literate programming source files that combine documentation and snippets of source code, Yacc/Bison programs that include snippets of Python or JS code, etc. To correctly indent the embedded chunks, the primary mode needs to delegate the indentation to another mode's indentation engine (e.g., call =js-indent-line= for JS code or =python-indent-line= for Python), while providing it with some context to guide the indentation. Major modes, for their part, should avoid calling =widen= in their indentation code and obey =prog-first-column=.

--- Variable: *prog-indentation-context*

#+BEGIN_QUOTE
  This variable, when non-=nil=, holds the indentation context for the sub-mode's indentation engine provided by the superior major mode. The value should be a list of the form =(=first-column=.=rest. The members of the list have the following meaning:

  - first-column

    The column to be used for top-level constructs. This replaces the default value of the top-level column used by the sub-mode, usually zero.

  - rest

    This value is currently unused.

#+END_QUOTE

The following convenience function should be used by major mode's indentation engine in support of invocations as sub-modes of another major mode.

--- Function: *prog-first-column*

#+BEGIN_QUOTE
  Call this function instead of using a literal value (usually, zero) of the column number for indenting top-level program constructs. The function's value is the column number to use for top-level constructs. When no superior mode is in effect, this function returns zero.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Relative-Indent][Relative Indent]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mode_002dSpecific-Indent][Mode-Specific Indent]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]]

** 32.17.3 Indenting an Entire Region
     :PROPERTIES:
     :CUSTOM_ID: indenting-an-entire-region
     :END:

This section describes commands that indent all the lines in the region. They return unpredictable values.

--- Command: *indent-region* start end &optional to-column

#+BEGIN_QUOTE
  This command indents each nonblank line starting between start (inclusive) and end (exclusive). If to-column is =nil=, =indent-region= indents each nonblank line by calling the current mode's indentation function, the value of =indent-line-function=.

  If to-column is non-=nil=, it should be an integer specifying the number of columns of indentation; then this function gives each line exactly that much indentation, by either adding or deleting whitespace.

  If there is a fill prefix, =indent-region= indents each line by making it start with the fill prefix.
#+END_QUOTE

--- Variable: *indent-region-function*

#+BEGIN_QUOTE
  The value of this variable is a function that can be used by =indent-region= as a short cut. It should take two arguments, the start and end of the region. You should design the function so that it will produce the same results as indenting the lines of the region one by one, but presumably faster.

  If the value is =nil=, there is no short cut, and =indent-region= actually works line by line.

  A short-cut function is useful in modes such as C mode and Lisp mode, where the =indent-line-function= must scan from the beginning of the function definition: applying it to each line would be quadratic in time. The short cut can update the scan information as it moves through the lines indenting them; this takes linear time. In a mode where indenting a line individually is fast, there is no need for a short cut.

  =indent-region= with a non-=nil= argument to-column has a different meaning and does not use this variable.
#+END_QUOTE

--- Command: *indent-rigidly* start end count

#+BEGIN_QUOTE
  This function indents all lines starting between start (inclusive) and end (exclusive) sideways by count columns. This preserves the shape of the affected region, moving it as a rigid unit.

  This is useful not only for indenting regions of unindented text, but also for indenting regions of formatted code. For example, if count is 3, this command adds 3 columns of indentation to every line that begins in the specified region.

  If called interactively with no prefix argument, this command invokes a transient mode for adjusting indentation rigidly. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Indentation-Commands][Indentation Commands]].
#+END_QUOTE

--- Command: *indent-code-rigidly* start end columns &optional nochange-regexp

#+BEGIN_QUOTE
  This is like =indent-rigidly=, except that it doesn't alter lines that start within strings or comments.

  In addition, it doesn't alter a line if nochange-regexp matches at the beginning of the line (if nochange-regexp is non-=nil=).
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indent-Tabs][Indent Tabs]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Region-Indent][Region Indent]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]]

** 32.17.4 Indentation Relative to Previous Lines
     :PROPERTIES:
     :CUSTOM_ID: indentation-relative-to-previous-lines
     :END:

This section describes two commands that indent the current line based on the contents of previous lines.

--- Command: *indent-relative* &optional unindented-ok

#+BEGIN_QUOTE
  This command inserts whitespace at point, extending to the same column as the next indent point of the previous nonblank line. An indent point is a non-whitespace character following whitespace. The next indent point is the first one at a column greater than the current column of point. For example, if point is underneath and to the left of the first non-blank character of a line of text, it moves to that column by inserting whitespace.

  If the previous nonblank line has no next indent point (i.e., none at a great enough column position), =indent-relative= either does nothing (if unindented-ok is non-=nil=) or calls =tab-to-tab-stop=. Thus, if point is underneath and to the right of the last column of a short line of text, this command ordinarily moves point to the next tab stop by inserting whitespace.

  The return value of =indent-relative= is unpredictable.

  In the following example, point is at the beginning of the second line:

  #+BEGIN_EXAMPLE
                            This line is indented twelve spaces.
                -!-The quick brown fox jumped.
  #+END_EXAMPLE

  Evaluation of the expression =(indent-relative nil)= produces the following:

  #+BEGIN_EXAMPLE
                            This line is indented twelve spaces.
                            -!-The quick brown fox jumped.
  #+END_EXAMPLE

  In this next example, point is between the 'm' and 'p' of 'jumped':

  #+BEGIN_EXAMPLE
                            This line is indented twelve spaces.
                The quick brown fox jum-!-ped.
  #+END_EXAMPLE

  Evaluation of the expression =(indent-relative nil)= produces the following:

  #+BEGIN_EXAMPLE
                            This line is indented twelve spaces.
                The quick brown fox jum  -!-ped.
  #+END_EXAMPLE
#+END_QUOTE

--- Command: *indent-relative-first-indent-point*

#+BEGIN_QUOTE
  This command indents the current line like the previous nonblank line, by calling =indent-relative= with =t= as the first-only argument. The return value is unpredictable.

  If the previous nonblank line has no indent points beyond the current column, this command does nothing.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Motion-by-Indent][Motion by Indent]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Relative-Indent][Relative Indent]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]]

** 32.17.5 Adjustable Tab Stops
     :PROPERTIES:
     :CUSTOM_ID: adjustable-tab-stops
     :END:

This section explains the mechanism for user-specified tab stops and the mechanisms that use and set them. The name "tab stops" is used because the feature is similar to that of the tab stops on a typewriter. The feature works by inserting an appropriate number of spaces and tab characters to reach the next tab stop column; it does not affect the display of tab characters in the buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Usual-Display][Usual Display]]). Note that the character as input uses this tab stop feature only in a few major modes, such as Text mode. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Tab-Stops][Tab Stops]].

--- Command: *tab-to-tab-stop*

#+BEGIN_QUOTE
  This command inserts spaces or tabs before point, up to the next tab stop column defined by =tab-stop-list=.
#+END_QUOTE

--- User Option: *tab-stop-list*

#+BEGIN_QUOTE
  This variable defines the tab stop columns used by =tab-to-tab-stop=. It should be either =nil=, or a list of increasing integers, which need not be evenly spaced. The list is implicitly extended to infinity through repetition of the interval between the last and penultimate elements (or =tab-width= if the list has fewer than two elements). A value of =nil= means a tab stop every =tab-width= columns.

  Use M-x edit-tab-stops to edit the location of tab stops interactively.
#+END_QUOTE

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indent-Tabs][Indent Tabs]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]]

** 32.17.6 Indentation-Based Motion Commands
     :PROPERTIES:
     :CUSTOM_ID: indentation-based-motion-commands
     :END:

These commands, primarily for interactive use, act based on the indentation in the text.

--- Command: *back-to-indentation*

#+BEGIN_QUOTE
  This command moves point to the first non-whitespace character in the current line (which is the line in which point is located). It returns =nil=.
#+END_QUOTE

--- Command: *backward-to-indentation* &optional arg

#+BEGIN_QUOTE
  This command moves point backward arg lines and then to the first nonblank character on that line. It returns =nil=. If arg is omitted or =nil=, it defaults to 1.
#+END_QUOTE

--- Command: *forward-to-indentation* &optional arg

#+BEGIN_QUOTE
  This command moves point forward arg lines and then to the first nonblank character on that line. It returns =nil=. If arg is omitted or =nil=, it defaults to 1.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indentation][Indentation]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.18 Case Changes
    :PROPERTIES:
    :CUSTOM_ID: case-changes
    :END:

The case change commands described here work on text in the current buffer. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Case-Conversion][Case Conversion]], for case conversion functions that work on strings and characters. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Case-Tables][Case Tables]], for how to customize which characters are upper or lower case and how to convert them.

--- Command: *capitalize-region* start end

#+BEGIN_QUOTE
  This function capitalizes all words in the region defined by start and end. To capitalize means to convert each word's first character to upper case and convert the rest of each word to lower case. The function returns =nil=.

  If one end of the region is in the middle of a word, the part of the word within the region is treated as an entire word.

  When =capitalize-region= is called interactively, start and end are point and the mark, with the smallest first.

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                This is the contents of the 5th foo.
                ---------- Buffer: foo ----------

                (capitalize-region 1 37)
                ⇒ nil

                ---------- Buffer: foo ----------
                This Is The Contents Of The 5th Foo.
                ---------- Buffer: foo ----------
  #+END_EXAMPLE
#+END_QUOTE

--- Command: *downcase-region* start end

#+BEGIN_QUOTE
  This function converts all of the letters in the region defined by start and end to lower case. The function returns =nil=.

  When =downcase-region= is called interactively, start and end are point and the mark, with the smallest first.
#+END_QUOTE

--- Command: *upcase-region* start end

#+BEGIN_QUOTE
  This function converts all of the letters in the region defined by start and end to upper case. The function returns =nil=.

  When =upcase-region= is called interactively, start and end are point and the mark, with the smallest first.
#+END_QUOTE

--- Command: *capitalize-word* count

#+BEGIN_QUOTE
  This function capitalizes count words after point, moving point over as it does. To capitalize means to convert each word's first character to upper case and convert the rest of each word to lower case. If count is negative, the function capitalizes the −count previous words but does not move point. The value is =nil=.

  If point is in the middle of a word, the part of the word before point is ignored when moving forward. The rest is treated as an entire word.

  When =capitalize-word= is called interactively, count is set to the numeric prefix argument.
#+END_QUOTE

--- Command: *downcase-word* count

#+BEGIN_QUOTE
  This function converts the count words after point to all lower case, moving point over as it does. If count is negative, it converts the −count previous words but does not move point. The value is =nil=.

  When =downcase-word= is called interactively, count is set to the numeric prefix argument.
#+END_QUOTE

--- Command: *upcase-word* count

#+BEGIN_QUOTE
  This function converts the count words after point to all upper case, moving point over as it does. If count is negative, it converts the −count previous words but does not move point. The value is =nil=.

  When =upcase-word= is called interactively, count is set to the numeric prefix argument.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Substitution][Substitution]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Case-Changes][Case Changes]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.19 Text Properties
    :PROPERTIES:
    :CUSTOM_ID: text-properties
    :END:

Each character position in a buffer or a string can have a text property list, much like the property list of a symbol (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Lists][Property Lists]]). The properties belong to a particular character at a particular place, such as, the letter 'T' at the beginning of this sentence or the first 'o' in 'foo'---if the same character occurs in two different places, the two occurrences in general have different properties.

Each property has a name and a value. Both of these can be any Lisp object, but the name is normally a symbol. Typically each property name symbol is used for a particular purpose; for instance, the text property =face= specifies the faces for displaying the character (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]]). The usual way to access the property list is to specify a name and ask what value corresponds to it.

If a character has a =category= property, we call it the property category of the character. It should be a symbol. The properties of the symbol serve as defaults for the properties of the character.

Copying text between strings and buffers preserves the properties along with the characters; this includes such diverse functions as =substring=, =insert=, and =buffer-substring=.

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Examining-Properties][Examining Properties]]: Looking at the properties of one character.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Changing-Properties][Changing Properties]]: Setting the properties of a range of text.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Search][Property Search]]: Searching for where a property changes value.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]]: Particular properties with special meanings.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-Properties][Format Properties]]: Properties for representing formatting of text.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sticky-Properties][Sticky Properties]]: How inserted text gets properties from neighboring text.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lazy-Properties][Lazy Properties]]: Computing text properties in a lazy fashion only when text is examined.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Clickable-Text][Clickable Text]]: Using text properties to make regions of text do something when you click on them.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Fields][Fields]]: The =field= property defines fields within the buffer.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Not-Intervals][Not Intervals]]: Why text properties do not use Lisp-visible text intervals.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Changing-Properties][Changing Properties]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.1 Examining Text Properties
     :PROPERTIES:
     :CUSTOM_ID: examining-text-properties
     :END:

The simplest way to examine text properties is to ask for the value of a particular property of a particular character. For that, use =get-text-property=. Use =text-properties-at= to get the entire property list of a character. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Search][Property Search]], for functions to examine the properties of a number of characters at once.

These functions handle both strings and buffers. Keep in mind that positions in a string start from 0, whereas positions in a buffer start from 1.

--- Function: *get-text-property* pos prop &optional object

#+BEGIN_QUOTE
  This function returns the value of the prop property of the character after position pos in object (a buffer or string). The argument object is optional and defaults to the current buffer.

  If there is no prop property strictly speaking, but the character has a property category that is a symbol, then =get-text-property= returns the prop property of that symbol.
#+END_QUOTE

--- Function: *get-char-property* position prop &optional object

#+BEGIN_QUOTE
  This function is like =get-text-property=, except that it checks overlays first and then text properties. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlays][Overlays]].

  The argument object may be a string, a buffer, or a window. If it is a window, then the buffer displayed in that window is used for text properties and overlays, but only the overlays active for that window are considered. If object is a buffer, then overlays in that buffer are considered first, in order of decreasing priority, followed by the text properties. If object is a string, only text properties are considered, since strings never have overlays.
#+END_QUOTE

--- Function: *get-pos-property* position prop &optional object

#+BEGIN_QUOTE
  This function is like =get-char-property=, except that it pays attention to properties' stickiness and overlays' advancement settings instead of the property of the character at (i.e., right after) position.
#+END_QUOTE

--- Function: *get-char-property-and-overlay* position prop &optional object

#+BEGIN_QUOTE
  This is like =get-char-property=, but gives extra information about the overlay that the property value comes from.

  Its value is a cons cell whose car is the property value, the same value =get-char-property= would return with the same arguments. Its cdr is the overlay in which the property was found, or =nil=, if it was found as a text property or not found at all.

  If position is at the end of object, both the car and the cdr of the value are =nil=.
#+END_QUOTE

--- Variable: *char-property-alias-alist*

#+BEGIN_QUOTE
  This variable holds an alist which maps property names to a list of alternative property names. If a character does not specify a direct value for a property, the alternative property names are consulted in order; the first non-=nil= value is used. This variable takes precedence over =default-text-properties=, and =category= properties take precedence over this variable.
#+END_QUOTE

--- Function: *text-properties-at* position &optional object

#+BEGIN_QUOTE
  This function returns the entire property list of the character at position in the string or buffer object. If object is =nil=, it defaults to the current buffer.
#+END_QUOTE

--- Variable: *default-text-properties*

#+BEGIN_QUOTE
  This variable holds a property list giving default values for text properties. Whenever a character does not specify a value for a property, neither directly, through a category symbol, or through =char-property-alias-alist=, the value stored in this list is used instead. Here is an example:

  #+BEGIN_EXAMPLE
                (setq default-text-properties '(foo 69)
                      char-property-alias-alist nil)
                ;; Make sure character 1 has no properties of its own.
                (set-text-properties 1 2 nil)
                ;; What we get, when we ask, is the default value.
                (get-text-property 1 'foo)
                     ⇒ 69
  #+END_EXAMPLE
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Search][Property Search]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Examining-Properties][Examining Properties]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.2 Changing Text Properties
     :PROPERTIES:
     :CUSTOM_ID: changing-text-properties
     :END:

The primitives for changing properties apply to a specified range of text in a buffer or string. The function =set-text-properties= (see end of section) sets the entire property list of the text in that range; more often, it is useful to add, change, or delete just certain properties specified by name.

Since text properties are considered part of the contents of the buffer (or string), and can affect how a buffer looks on the screen, any change in buffer text properties marks the buffer as modified. Buffer text property changes are undoable also (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]]). Positions in a string start from 0, whereas positions in a buffer start from 1.

--- Function: *put-text-property* start end prop value &optional object

#+BEGIN_QUOTE
  This function sets the prop property to value for the text between start and end in the string or buffer object. If object is =nil=, it defaults to the current buffer.
#+END_QUOTE

--- Function: *add-text-properties* start end props &optional object

#+BEGIN_QUOTE
  This function adds or overrides text properties for the text between start and end in the string or buffer object. If object is =nil=, it defaults to the current buffer.

  The argument props specifies which properties to add. It should have the form of a property list (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Lists][Property Lists]]): a list whose elements include the property names followed alternately by the corresponding values.

  The return value is =t= if the function actually changed some property's value; =nil= otherwise (if props is =nil= or its values agree with those in the text).

  For example, here is how to set the =comment= and =face= properties of a range of text:

  #+BEGIN_EXAMPLE
                (add-text-properties start end
                                     '(comment t face highlight))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *remove-text-properties* start end props &optional object

#+BEGIN_QUOTE
  This function deletes specified text properties from the text between start and end in the string or buffer object. If object is =nil=, it defaults to the current buffer.

  The argument props specifies which properties to delete. It should have the form of a property list (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Lists][Property Lists]]): a list whose elements are property names alternating with corresponding values. But only the names matter---the values that accompany them are ignored. For example, here's how to remove the =face= property.

  #+BEGIN_EXAMPLE
                (remove-text-properties start end '(face nil))
  #+END_EXAMPLE

  The return value is =t= if the function actually changed some property's value; =nil= otherwise (if props is =nil= or if no character in the specified text had any of those properties).

  To remove all text properties from certain text, use =set-text-properties= and specify =nil= for the new property list.
#+END_QUOTE

--- Function: *remove-list-of-text-properties* start end list-of-properties &optional object

#+BEGIN_QUOTE
  Like =remove-text-properties= except that list-of-properties is a list of property names only, not an alternating list of property names and values.
#+END_QUOTE

--- Function: *set-text-properties* start end props &optional object

#+BEGIN_QUOTE
  This function completely replaces the text property list for the text between start and end in the string or buffer object. If object is =nil=, it defaults to the current buffer.

  The argument props is the new property list. It should be a list whose elements are property names alternating with corresponding values.

  After =set-text-properties= returns, all the characters in the specified range have identical properties.

  If props is =nil=, the effect is to get rid of all properties from the specified range of text. Here's an example:

  #+BEGIN_EXAMPLE
                (set-text-properties start end nil)
  #+END_EXAMPLE

  Do not rely on the return value of this function.
#+END_QUOTE

--- Function: *add-face-text-property* start end face &optional appendp object

#+BEGIN_QUOTE
  This function acts on the text between start and end, adding the face face to the =face= text property. face should be a valid value for the =face= property (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]]), such as a face name or an anonymous face (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Faces][Faces]]).

  If any text in the region already has a non-=nil= =face= property, those face(s) are retained. This function sets the =face= property to a list of faces, with face as the first element (by default) and the pre-existing faces as the remaining elements. If the optional argument appendp is non-=nil=, face is appended to the end of the list instead. Note that in a face list, the first occurring value for each attribute takes precedence.

  For example, the following code would assign an italicized green face to the text between start and end:

  #+BEGIN_EXAMPLE
                (add-face-text-property start end 'italic)
                (add-face-text-property start end '(:foreground "red"))
                (add-face-text-property start end '(:foreground "green"))
  #+END_EXAMPLE

  The optional argument object, if non-=nil=, specifies a buffer or string to act on, rather than the current buffer. If object is a string, then start and end are zero-based indices into the string.
#+END_QUOTE

The easiest way to make a string with text properties is with =propertize=:

--- Function: *propertize* string &rest properties

#+BEGIN_QUOTE
  This function returns a copy of string with the text properties properties added. These properties apply to all the characters in the string that is returned. Here is an example that constructs a string with a =face= property and a =mouse-face= property:

  #+BEGIN_EXAMPLE
                (propertize "foo" 'face 'italic
                            'mouse-face 'bold-italic)
                     ⇒ #("foo" 0 3 (mouse-face bold-italic face italic))
  #+END_EXAMPLE

  To put different properties on various parts of a string, you can construct each part with =propertize= and then combine them with =concat=:

  #+BEGIN_EXAMPLE
                (concat
                 (propertize "foo" 'face 'italic
                             'mouse-face 'bold-italic)
                 " and "
                 (propertize "bar" 'face 'italic
                             'mouse-face 'bold-italic))
                     ⇒ #("foo and bar"
                                 0 3 (face italic mouse-face bold-italic)
                                 3 8 nil
                                 8 11 (face italic mouse-face bold-italic))
  #+END_EXAMPLE
#+END_QUOTE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Contents][Buffer Contents]], for the function =buffer-substring-no-properties=, which copies text from the buffer but does not copy its properties.

If you wish to add text properties to a buffer or remove them without marking the buffer as modified, you can wrap the calls above in the =with-silent-modifications= macro. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Modification][Buffer Modification]].

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Changing-Properties][Changing Properties]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.3 Text Property Search Functions
     :PROPERTIES:
     :CUSTOM_ID: text-property-search-functions
     :END:

In typical use of text properties, most of the time several or many consecutive characters have the same value for a property. Rather than writing your programs to examine characters one by one, it is much faster to process chunks of text that have the same property value.

Here are functions you can use to do this. They use =eq= for comparing property values. In all cases, object defaults to the current buffer.

For good performance, it's very important to use the limit argument to these functions, especially the ones that search for a single property---otherwise, they may spend a long time scanning to the end of the buffer, if the property you are interested in does not change.

These functions do not move point; instead, they return a position (or =nil=). Remember that a position is always between two characters; the position returned by these functions is between two characters with different properties.

--- Function: *next-property-change* pos &optional object limit

#+BEGIN_QUOTE
  The function scans the text forward from position pos in the string or buffer object until it finds a change in some text property, then returns the position of the change. In other words, it returns the position of the first character beyond pos whose properties are not identical to those of the character just after pos.

  If limit is non-=nil=, then the scan ends at position limit. If there is no property change before that point, this function returns limit.

  The value is =nil= if the properties remain unchanged all the way to the end of object and limit is =nil=. If the value is non-=nil=, it is a position greater than or equal to pos. The value equals pos only when limit equals pos.

  Here is an example of how to scan the buffer by chunks of text within which all properties are constant:

  #+BEGIN_EXAMPLE
                (while (not (eobp))
                  (let ((plist (text-properties-at (point)))
                        (next-change
                         (or (next-property-change (point) (current-buffer))
                             (point-max))))
                    Process text from point to next-change...
                    (goto-char next-change)))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *previous-property-change* pos &optional object limit

#+BEGIN_QUOTE
  This is like =next-property-change=, but scans back from pos instead of forward. If the value is non-=nil=, it is a position less than or equal to pos; it equals pos only if limit equals pos.
#+END_QUOTE

--- Function: *next-single-property-change* pos prop &optional object limit

#+BEGIN_QUOTE
  The function scans text for a change in the prop property, then returns the position of the change. The scan goes forward from position pos in the string or buffer object. In other words, this function returns the position of the first character beyond pos whose prop property differs from that of the character just after pos.

  If limit is non-=nil=, then the scan ends at position limit. If there is no property change before that point, =next-single-property-change= returns limit.

  The value is =nil= if the property remains unchanged all the way to the end of object and limit is =nil=. If the value is non-=nil=, it is a position greater than or equal to pos; it equals pos only if limit equals pos.
#+END_QUOTE

--- Function: *previous-single-property-change* pos prop &optional object limit

#+BEGIN_QUOTE
  This is like =next-single-property-change=, but scans back from pos instead of forward. If the value is non-=nil=, it is a position less than or equal to pos; it equals pos only if limit equals pos.
#+END_QUOTE

--- Function: *next-char-property-change* pos &optional limit

#+BEGIN_QUOTE
  This is like =next-property-change= except that it considers overlay properties as well as text properties, and if no change is found before the end of the buffer, it returns the maximum buffer position rather than =nil= (in this sense, it resembles the corresponding overlay function =next-overlay-change=, rather than =next-property-change=). There is no object operand because this function operates only on the current buffer. It returns the next address at which either kind of property changes.
#+END_QUOTE

--- Function: *previous-char-property-change* pos &optional limit

#+BEGIN_QUOTE
  This is like =next-char-property-change=, but scans back from pos instead of forward, and returns the minimum buffer position if no change is found.
#+END_QUOTE

--- Function: *next-single-char-property-change* pos prop &optional object limit

#+BEGIN_QUOTE
  This is like =next-single-property-change= except that it considers overlay properties as well as text properties, and if no change is found before the end of the object, it returns the maximum valid position in object rather than =nil=. Unlike =next-char-property-change=, this function /does/ have an object operand; if object is not a buffer, only text-properties are considered.
#+END_QUOTE

--- Function: *previous-single-char-property-change* pos prop &optional object limit

#+BEGIN_QUOTE
  This is like =next-single-char-property-change=, but scans back from pos instead of forward, and returns the minimum valid position in object if no change is found.
#+END_QUOTE

--- Function: *text-property-any* start end prop value &optional object

#+BEGIN_QUOTE
  This function returns non-=nil= if at least one character between start and end has a property prop whose value is value. More precisely, it returns the position of the first such character. Otherwise, it returns =nil=.

  The optional fifth argument, object, specifies the string or buffer to scan. Positions are relative to object. The default for object is the current buffer.
#+END_QUOTE

--- Function: *text-property-not-all* start end prop value &optional object

#+BEGIN_QUOTE
  This function returns non-=nil= if at least one character between start and end does not have a property prop with value value. More precisely, it returns the position of the first such character. Otherwise, it returns =nil=.

  The optional fifth argument, object, specifies the string or buffer to scan. Positions are relative to object. The default for object is the current buffer.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-Properties][Format Properties]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Search][Property Search]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.4 Properties with Special Meanings
     :PROPERTIES:
     :CUSTOM_ID: properties-with-special-meanings
     :END:

Here is a table of text property names that have special built-in meanings. The following sections list a few additional special property names that control filling and property inheritance. All other names have no standard meaning, and you can use them as you like.

Note: the properties =composition=, =display=, =invisible= and =intangible= can also cause point to move to an acceptable place, after each Emacs command. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Adjusting-Point][Adjusting Point]].

- =category=

  If a character has a =category= property, we call it the property category of the character. It should be a symbol. The properties of this symbol serve as defaults for the properties of the character.

- =face=

  The =face= property controls the appearance of the character (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Faces][Faces]]). The value of the property can be the following: A face name (a symbol or string). An anonymous face: a property list of the form =(=keyword value=...)=, where each keyword is a face attribute name and value is a value for that attribute. A list of faces. Each list element should be either a face name or an anonymous face. This specifies a face which is an aggregate of the attributes of each of the listed faces. Faces occurring earlier in the list have higher priority. A cons cell of the form =(foreground-color .=color-name=)= or =(background-color .=color-name=)=. This specifies the foreground or background color, similar to =(:foreground=color-name=)= or =(:background=color-name=)=. This form is supported for backward compatibility only, and should be avoided. Font Lock mode (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Font-Lock-Mode][Font Lock Mode]]) works in most buffers by dynamically updating the =face= property of characters based on the context. The =add-face-text-property= function provides a convenient way to set this text property. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Changing-Properties][Changing Properties]].

- =font-lock-face=

  This property specifies a value for the =face= property that Font Lock mode should apply to the underlying text. It is one of the fontification methods used by Font Lock mode, and is useful for special modes that implement their own highlighting. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Precalculated-Fontification][Precalculated Fontification]]. When Font Lock mode is disabled, =font-lock-face= has no effect.

- =mouse-face=

  This property is used instead of =face= when the mouse is on or near the character. For this purpose, "near" means that all text between the character and where the mouse is have the same =mouse-face= property value. Emacs ignores all face attributes from the =mouse-face= property that alter the text size (e.g., =:height=, =:weight=, and =:slant=). Those attributes are always the same as for the unhighlighted text.

- =fontified=

  This property says whether the text is ready for display. If =nil=, Emacs's redisplay routine calls the functions in =fontification-functions= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Faces][Auto Faces]]) to prepare this part of the buffer before it is displayed. It is used internally by the just-in-time font locking code.

- =display=

  This property activates various features that change the way text is displayed. For example, it can make text appear taller or shorter, higher or lower, wider or narrow, or replaced with an image. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Display-Property][Display Property]].

- =help-echo=

  If text has a string as its =help-echo= property, then when you move the mouse onto that text, Emacs displays that string in the echo area, or in the tooltip window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Tooltips][Tooltips]]). If the value of the =help-echo= property is a function, that function is called with three arguments, window, object and pos and should return a help string or =nil= for none. The first argument, window is the window in which the help was found. The second, object, is the buffer, overlay or string which had the =help-echo= property. The pos argument is as follows: If object is a buffer, pos is the position in the buffer. If object is an overlay, that overlay has a =help-echo= property, and pos is the position in the overlay's buffer. If object is a string (an overlay string or a string displayed with the =display= property), pos is the position in that string. If the value of the =help-echo= property is neither a function nor a string, it is evaluated to obtain a help string. You can alter the way help text is displayed by setting the variable =show-help-function= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Help-display][Help display]]). This feature is used in the mode line and for other active text.

- =keymap=

  The =keymap= property specifies an additional keymap for commands. When this keymap applies, it is used for key lookup before the minor mode keymaps and before the buffer's local map. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Active-Keymaps][Active Keymaps]]. If the property value is a symbol, the symbol's function definition is used as the keymap. The property's value for the character before point applies if it is non-=nil= and rear-sticky, and the property's value for the character after point applies if it is non-=nil= and front-sticky. (For mouse clicks, the position of the click is used instead of the position of point.)

- =local-map=

  This property works like =keymap= except that it specifies a keymap to use /instead of/ the buffer's local map. For most purposes (perhaps all purposes), it is better to use the =keymap= property.

- =syntax-table=

  The =syntax-table= property overrides what the syntax table says about this particular character. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Properties][Syntax Properties]].

- =read-only=

  If a character has the property =read-only=, then modifying that character is not allowed. Any command that would do so gets an error, =text-read-only=. If the property value is a string, that string is used as the error message. Insertion next to a read-only character is an error if inserting ordinary text there would inherit the =read-only= property due to stickiness. Thus, you can control permission to insert next to read-only text by controlling the stickiness. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sticky-Properties][Sticky Properties]]. Since changing properties counts as modifying the buffer, it is not possible to remove a =read-only= property unless you know the special trick: bind =inhibit-read-only= to a non-=nil= value and then remove the property. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-Only-Buffers][Read Only Buffers]].

- =inhibit-read-only=

  Characters that have the property =inhibit-read-only= can be edited even in read-only buffers. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-Only-Buffers][Read Only Buffers]].

- =invisible=

  A non-=nil= =invisible= property can make a character invisible on the screen. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Invisible-Text][Invisible Text]], for details.

- =intangible=

  If a group of consecutive characters have equal and non-=nil= =intangible= properties, then you cannot place point between them. If you try to move point forward into the group, point actually moves to the end of the group. If you try to move point backward into the group, point actually moves to the start of the group. If consecutive characters have unequal non-=nil= =intangible= properties, they belong to separate groups; each group is separately treated as described above. When the variable =inhibit-point-motion-hooks= is non-=nil= (as it is by default), the =intangible= property is ignored. Beware: this property operates at a very low level, and affects a lot of code in unexpected ways. So use it with extreme caution. A common misuse is to put an intangible property on invisible text, which is actually unnecessary since the command loop will move point outside of the invisible text at the end of each command anyway. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Adjusting-Point][Adjusting Point]]. For these reasons, this property is obsolete; use the =cursor-intangible= property instead.

- =cursor-intangible=

  When the minor mode =cursor-intangible-mode= is turned on, point is moved away from any position that has a non-=nil= =cursor-intangible= property, just before redisplay happens. When the variable =cursor-sensor-inhibit= is non-=nil=, the =cursor-intangible= property and the =cursor-sensor-functions= property (described below) are ignored.

- =field=

  Consecutive characters with the same =field= property constitute a field. Some motion functions including =forward-word= and =beginning-of-line= stop moving at a field boundary. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Fields][Fields]].

- =cursor=

  Normally, the cursor is displayed at the beginning or the end of any overlay and text property strings present at the current buffer position. You can place the cursor on any desired character of these strings by giving that character a non-=nil= =cursor= text property. In addition, if the value of the =cursor= property is an integer, it specifies the number of buffer's character positions, starting with the position where the overlay or the =display= property begins, for which the cursor should be displayed on that character. Specifically, if the value of the =cursor= property of a character is the number n, the cursor will be displayed on this character for any buffer position in the range =[=ovpos=..=ovpos=+=n=)=, where ovpos is the overlay's starting position given by =overlay-start= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Managing-Overlays][Managing Overlays]]), or the position where the =display= text property begins in the buffer. In other words, the string character with the =cursor= property of any non-=nil= value is the character where to display the cursor. The value of the property says for which buffer positions to display the cursor there. If the value is an integer n, the cursor is displayed there when point is anywhere between the beginning of the overlay or =display= property and n positions after that. If the value is anything else and non-=nil=, the cursor is displayed there only when point is at the beginning of the =display= property or at =overlay-start=. When the buffer has many overlay strings (e.g., see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlay-Properties][before-string]]) that conceal some of the buffer text or =display= properties that are strings, it is a good idea to use the =cursor= property on these strings to cue the Emacs display about the places where to put the cursor while traversing these strings. This directly communicates to the display engine where the Lisp program wants to put the cursor, or where the user would expect the cursor, when point is located on some buffer position that is "covered" by the display or overlay string.

- =pointer=

  This specifies a specific pointer shape when the mouse pointer is over this text or image. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Pointer-Shape][Pointer Shape]], for possible pointer shapes.

- =line-spacing=

  A newline can have a =line-spacing= text or overlay property that controls the height of the display line ending with that newline. The property value overrides the default frame line spacing and the buffer local =line-spacing= variable. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Line-Height][Line Height]].

- =line-height=

  A newline can have a =line-height= text or overlay property that controls the total height of the display line ending in that newline. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Line-Height][Line Height]].

- =wrap-prefix=

  If text has a =wrap-prefix= property, the prefix it defines will be added at display time to the beginning of every continuation line due to text wrapping (so if lines are truncated, the wrap-prefix is never used). It may be a string or an image (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Other-Display-Specs][Other Display Specs]]), or a stretch of whitespace such as specified by the =:width= or =:align-to= display properties (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Specified-Space][Specified Space]]). A wrap-prefix may also be specified for an entire buffer using the =wrap-prefix= buffer-local variable (however, a =wrap-prefix= text-property takes precedence over the value of the =wrap-prefix= variable). See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Truncation][Truncation]].

- =line-prefix=

  If text has a =line-prefix= property, the prefix it defines will be added at display time to the beginning of every non-continuation line. It may be a string or an image (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Other-Display-Specs][Other Display Specs]]), or a stretch of whitespace such as specified by the =:width= or =:align-to= display properties (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Specified-Space][Specified Space]]). A line-prefix may also be specified for an entire buffer using the =line-prefix= buffer-local variable (however, a =line-prefix= text-property takes precedence over the value of the =line-prefix= variable). See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Truncation][Truncation]].

- =modification-hooks=

  If a character has the property =modification-hooks=, then its value should be a list of functions; modifying that character calls all of those functions before the actual modification. Each function receives two arguments: the beginning and end of the part of the buffer being modified. Note that if a particular modification hook function appears on several characters being modified by a single primitive, you can't predict how many times the function will be called. Furthermore, insertion will not modify any existing character, so this hook will only be run when removing some characters, replacing them with others, or changing their text-properties. If these functions modify the buffer, they should bind =inhibit-modification-hooks= to =t= around doing so, to avoid confusing the internal mechanism that calls these hooks. Overlays also support the =modification-hooks= property, but the details are somewhat different (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlay-Properties][Overlay Properties]]).

- =insert-in-front-hooks=

- =insert-behind-hooks=

  The operation of inserting text in a buffer also calls the functions listed in the =insert-in-front-hooks= property of the following character and in the =insert-behind-hooks= property of the preceding character. These functions receive two arguments, the beginning and end of the inserted text. The functions are called /after/ the actual insertion takes place. See also [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Change-Hooks][Change Hooks]], for other hooks that are called when you change text in a buffer.

- =point-entered=

- =point-left=

  The special properties =point-entered= and =point-left= record hook functions that report motion of point. Each time point moves, Emacs compares these two property values: the =point-left= property of the character after the old location, and the =point-entered= property of the character after the new location. If these two values differ, each of them is called (if not =nil=) with two arguments: the old value of point, and the new one. The same comparison is made for the characters before the old and new locations. The result may be to execute two =point-left= functions (which may be the same function) and/or two =point-entered= functions (which may be the same function). In any case, all the =point-left= functions are called first, followed by all the =point-entered= functions. It is possible to use =char-after= to examine characters at various buffer positions without moving point to those positions. Only an actual change in the value of point runs these hook functions. The variable =inhibit-point-motion-hooks= by default inhibits running the =point-left= and =point-entered= hooks, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Inhibit-point-motion-hooks][Inhibit point motion hooks]]. These properties are obsolete; please use =cursor-sensor-functions= instead.

- =cursor-sensor-functions=

  This special property records a list of functions that react to cursor motion. Each function in the list is called, just before redisplay, with 3 arguments: the affected window, the previous known position of the cursor, and one of the symbols =entered= or =left=, depending on whether the cursor is entering the text that has this property or leaving it. The functions are called only when the minor mode =cursor-sensor-mode= is turned on. When the variable =cursor-sensor-inhibit= is non-=nil=, the =cursor-sensor-functions= property is ignored.

- =composition=

  This text property is used to display a sequence of characters as a single glyph composed from components. But the value of the property itself is completely internal to Emacs and should not be manipulated directly by, for instance, =put-text-property=.

--- Variable: *inhibit-point-motion-hooks*

#+BEGIN_QUOTE
  When this obsolete variable is non-=nil=, =point-left= and =point-entered= hooks are not run, and the =intangible= property has no effect. Do not set this variable globally; bind it with =let=. Since the affected properties are obsolete, this variable's default value is =t=, to effectively disable them.
#+END_QUOTE

--- Variable: *show-help-function*

#+BEGIN_QUOTE
  If this variable is non-=nil=, it specifies a function called to display help strings. These may be =help-echo= properties, menu help strings (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Simple-Menu-Items][Simple Menu Items]], see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Extended-Menu-Items][Extended Menu Items]]), or tool bar help strings (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Tool-Bar][Tool Bar]]). The specified function is called with one argument, the help string to display, which is passed through =substitute-command-keys= before being given to the function; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keys-in-Documentation][Keys in Documentation]]. Tooltip mode (see [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Tooltips][Tooltips]]) provides an example.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sticky-Properties][Sticky Properties]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.5 Formatted Text Properties
     :PROPERTIES:
     :CUSTOM_ID: formatted-text-properties
     :END:

These text properties affect the behavior of the fill commands. They are used for representing formatted text. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Filling][Filling]], and [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Margins][Margins]].

- =hard=

  If a newline character has this property, it is a "hard" newline. The fill commands do not alter hard newlines and do not move words across them. However, this property takes effect only if the =use-hard-newlines= minor mode is enabled. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Hard-and-Soft-Newlines][Hard and Soft Newlines]].

- =right-margin=

  This property specifies an extra right margin for filling this part of the text.

- =left-margin=

  This property specifies an extra left margin for filling this part of the text.

- =justification=

  This property specifies the style of justification for filling this part of the text.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lazy-Properties][Lazy Properties]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-Properties][Format Properties]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.6 Stickiness of Text Properties
     :PROPERTIES:
     :CUSTOM_ID: stickiness-of-text-properties
     :END:

Self-inserting characters, the ones that get inserted into a buffer when the user types them (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Commands-for-Insertion][Commands for Insertion]]), normally take on the same properties as the preceding character. This is called inheritance of properties.

By contrast, a Lisp program can do insertion with inheritance or without, depending on the choice of insertion primitive. The ordinary text insertion functions, such as =insert=, do not inherit any properties. They insert text with precisely the properties of the string being inserted, and no others. This is correct for programs that copy text from one context to another---for example, into or out of the kill ring. To insert with inheritance, use the special primitives described in this section. Self-inserting characters inherit properties because they work using these primitives.

When you do insertion with inheritance, /which/ properties are inherited, and from where, depends on which properties are sticky. Insertion after a character inherits those of its properties that are rear-sticky. Insertion before a character inherits those of its properties that are front-sticky. When both sides offer different sticky values for the same property, the previous character's value takes precedence.

By default, a text property is rear-sticky but not front-sticky; thus, the default is to inherit all the properties of the preceding character, and nothing from the following character.

You can control the stickiness of various text properties with two specific text properties, =front-sticky= and =rear-nonsticky=, and with the variable =text-property-default-nonsticky=. You can use the variable to specify a different default for a given property. You can use those two text properties to make any specific properties sticky or nonsticky in any particular part of the text.

If a character's =front-sticky= property is =t=, then all its properties are front-sticky. If the =front-sticky= property is a list, then the sticky properties of the character are those whose names are in the list. For example, if a character has a =front-sticky= property whose value is =(face read-only)=, then insertion before the character can inherit its =face= property and its =read-only= property, but no others.

The =rear-nonsticky= property works the opposite way. Most properties are rear-sticky by default, so the =rear-nonsticky= property says which properties are /not/ rear-sticky. If a character's =rear-nonsticky= property is =t=, then none of its properties are rear-sticky. If the =rear-nonsticky= property is a list, properties are rear-sticky /unless/ their names are in the list.

--- Variable: *text-property-default-nonsticky*

#+BEGIN_QUOTE
  This variable holds an alist which defines the default rear-stickiness of various text properties. Each element has the form =(=property=.=nonstickiness=)=, and it defines the stickiness of a particular text property, property.

  If nonstickiness is non-=nil=, this means that the property property is rear-nonsticky by default. Since all properties are front-nonsticky by default, this makes property nonsticky in both directions by default.

  The text properties =front-sticky= and =rear-nonsticky=, when used, take precedence over the default nonstickiness specified in =text-property-default-nonsticky=.
#+END_QUOTE

Here are the functions that insert text with inheritance of properties:

--- Function: *insert-and-inherit* &rest strings

#+BEGIN_QUOTE
  Insert the strings strings, just like the function =insert=, but inherit any sticky properties from the adjoining text.
#+END_QUOTE

--- Function: *insert-before-markers-and-inherit* &rest strings

#+BEGIN_QUOTE
  Insert the strings strings, just like the function =insert-before-markers=, but inherit any sticky properties from the adjoining text.
#+END_QUOTE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Insertion][Insertion]], for the ordinary insertion functions which do not inherit.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Clickable-Text][Clickable Text]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sticky-Properties][Sticky Properties]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.7 Lazy Computation of Text Properties
     :PROPERTIES:
     :CUSTOM_ID: lazy-computation-of-text-properties
     :END:

Instead of computing text properties for all the text in the buffer, you can arrange to compute the text properties for parts of the text when and if something depends on them.

The primitive that extracts text from the buffer along with its properties is =buffer-substring=. Before examining the properties, this function runs the abnormal hook =buffer-access-fontify-functions=.

--- Variable: *buffer-access-fontify-functions*

#+BEGIN_QUOTE
  This variable holds a list of functions for computing text properties. Before =buffer-substring= copies the text and text properties for a portion of the buffer, it calls all the functions in this list. Each of the functions receives two arguments that specify the range of the buffer being accessed. (The buffer itself is always the current buffer.)
#+END_QUOTE

The function =buffer-substring-no-properties= does not call these functions, since it ignores text properties anyway.

In order to prevent the hook functions from being called more than once for the same part of the buffer, you can use the variable =buffer-access-fontified-property=.

--- Variable: *buffer-access-fontified-property*

#+BEGIN_QUOTE
  If this variable's value is non-=nil=, it is a symbol which is used as a text property name. A non-=nil= value for that text property means the other text properties for this character have already been computed.

  If all the characters in the range specified for =buffer-substring= have a non-=nil= value for this property, =buffer-substring= does not call the =buffer-access-fontify-functions= functions. It assumes these characters already have the right text properties, and just copies the properties they already have.

  The normal way to use this feature is that the =buffer-access-fontify-functions= functions add this property, as well as others, to the characters they operate on. That way, they avoid being called over and over for the same text.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Fields][Fields]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lazy-Properties][Lazy Properties]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.8 Defining Clickable Text
     :PROPERTIES:
     :CUSTOM_ID: defining-clickable-text
     :END:

Clickable text is text that can be clicked, with either the mouse or via a keyboard command, to produce some result. Many major modes use clickable text to implement textual hyper-links, or links for short.

The easiest way to insert and manipulate links is to use the =button= package. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buttons][Buttons]]. In this section, we will explain how to manually set up clickable text in a buffer, using text properties. For simplicity, we will refer to the clickable text as a link.

Implementing a link involves three separate steps: (1) indicating clickability when the mouse moves over the link; (2) making or mouse-2 on that link do something; and (3) setting up a =follow-link= condition so that the link obeys =mouse-1-click-follows-link=.

To indicate clickability, add the =mouse-face= text property to the text of the link; then Emacs will highlight the link when the mouse moves over it. In addition, you should define a tooltip or echo area message, using the =help-echo= text property. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]]. For instance, here is how Dired indicates that file names are clickable:

#+BEGIN_EXAMPLE
          (if (dired-move-to-filename)
              (add-text-properties
                (point)
                (save-excursion
                  (dired-move-to-end-of-filename)
                  (point))
                '(mouse-face highlight
                  help-echo "mouse-2: visit this file in other window")))
#+END_EXAMPLE

To make the link clickable, bind and mouse-2 to commands that perform the desired action. Each command should check to see whether it was called on a link, and act accordingly. For instance, Dired's major mode keymap binds mouse-2 to the following command:

#+BEGIN_EXAMPLE
         (defun dired-mouse-find-file-other-window (event)
           "In Dired, visit the file or directory name you click on."
           (interactive "e")
           (let ((window (posn-window (event-end event)))
                 (pos (posn-point (event-end event)))
                 file)
             (if (not (windowp window))
                 (error "No file chosen"))
             (with-current-buffer (window-buffer window)
               (goto-char pos)
               (setq file (dired-get-file-for-visit)))
             (if (file-directory-p file)
                 (or (and (cdr dired-subdir-alist)
                          (dired-goto-subdir file))
                     (progn
                       (select-window window)
                       (dired-other-window file)))
               (select-window window)
               (find-file-other-window (file-name-sans-versions file t)))))
#+END_EXAMPLE

This command uses the functions =posn-window= and =posn-point= to determine where the click occurred, and =dired-get-file-for-visit= to determine which file to visit.

Instead of binding the mouse command in a major mode keymap, you can bind it within the link text, using the =keymap= text property (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]]). For instance:

#+BEGIN_EXAMPLE
         (let ((map (make-sparse-keymap)))
           (define-key map [mouse-2] 'operate-this-button)
           (put-text-property link-start link-end 'keymap map))
#+END_EXAMPLE

With this method, you can easily define different commands for different links. Furthermore, the global definition of and mouse-2 remain available for the rest of the text in the buffer.

The basic Emacs command for clicking on links is mouse-2. However, for compatibility with other graphical applications, Emacs also recognizes mouse-1 clicks on links, provided the user clicks on the link quickly without moving the mouse. This behavior is controlled by the user option =mouse-1-click-follows-link=. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Mouse-References][Mouse References]].

To set up the link so that it obeys =mouse-1-click-follows-link=, you must either (1) apply a =follow-link= text or overlay property to the link text, or (2) bind the =follow-link= event to a keymap (which can be a major mode keymap or a local keymap specified via the =keymap= text property). The value of the =follow-link= property, or the binding for the =follow-link= event, acts as a condition for the link action. This condition tells Emacs two things: the circumstances under which a mouse-1 click should be regarded as occurring inside the link, and how to compute an action code that says what to translate the mouse-1 click into. The link action condition can be one of the following:

- =mouse-face=

  If the condition is the symbol =mouse-face=, a position is inside a link if there is a non-=nil= =mouse-face= property at that position. The action code is always =t=. For example, here is how Info mode handles : =(define-key Info-mode-map [follow-link] 'mouse-face)=

- a function

  If the condition is a function, func, then a position pos is inside a link if =(=func pos=)= evaluates to non-=nil=. The value returned by func serves as the action code. For example, here is how pcvs enables mouse-1 to follow links on file names only: =(define-key map [follow-link]            (lambda (pos)              (eq (get-char-property pos 'face) 'cvs-filename-face)))=

- anything else

  If the condition value is anything else, then the position is inside a link and the condition itself is the action code. Clearly, you should specify this kind of condition only when applying the condition via a text or property overlay on the link text (so that it does not apply to the entire buffer).

The action code tells mouse-1 how to follow the link:

- a string or vector

  If the action code is a string or vector, the mouse-1 event is translated into the first element of the string or vector; i.e., the action of the mouse-1 click is the local or global binding of that character or symbol. Thus, if the action code is ="foo"=, mouse-1 translates into f. If it is =[foo]=, mouse-1 translates into .

- anything else

  For any other non-=nil= action code, the mouse-1 event is translated into a mouse-2 event at the same position.

To define mouse-1 to activate a button defined with =define-button-type=, give the button a =follow-link= property. The property value should be a link action condition, as described above. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buttons][Buttons]]. For example, here is how Help mode handles mouse-1:

#+BEGIN_EXAMPLE
         (define-button-type 'help-xref
           'follow-link t
           'action #'help-button-action)
#+END_EXAMPLE

To define mouse-1 on a widget defined with =define-widget=, give the widget a =:follow-link= property. The property value should be a link action condition, as described above. For example, here is how the =link= widget specifies that a click shall be translated to :

#+BEGIN_EXAMPLE
         (define-widget 'link 'item
           "An embedded link."
           :button-prefix 'widget-link-prefix
           :button-suffix 'widget-link-suffix
           :follow-link "\C-m"
           :help-echo "Follow the link."
           :format "%[%t%]")
#+END_EXAMPLE

--- Function: *mouse-on-link-p* pos

#+BEGIN_QUOTE
  This function returns non-=nil= if position pos in the current buffer is on a link. pos can also be a mouse event location, as returned by =event-start= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Accessing-Mouse][Accessing Mouse]]).
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Not-Intervals][Not Intervals]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Clickable-Text][Clickable Text]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.9 Defining and Using Fields
     :PROPERTIES:
     :CUSTOM_ID: defining-and-using-fields
     :END:

A field is a range of consecutive characters in the buffer that are identified by having the same value (comparing with =eq=) of the =field= property (either a text-property or an overlay property). This section describes special functions that are available for operating on fields.

You specify a field with a buffer position, pos. We think of each field as containing a range of buffer positions, so the position you specify stands for the field containing that position.

When the characters before and after pos are part of the same field, there is no doubt which field contains pos: the one those characters both belong to. When pos is at a boundary between fields, which field it belongs to depends on the stickiness of the =field= properties of the two surrounding characters (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sticky-Properties][Sticky Properties]]). The field whose property would be inherited by text inserted at pos is the field that contains pos.

There is an anomalous case where newly inserted text at pos would not inherit the =field= property from either side. This happens if the previous character's =field= property is not rear-sticky, and the following character's =field= property is not front-sticky. In this case, pos belongs to neither the preceding field nor the following field; the field functions treat it as belonging to an empty field whose beginning and end are both at pos.

In all of these functions, if pos is omitted or =nil=, the value of point is used by default. If narrowing is in effect, then pos should fall within the accessible portion. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Narrowing][Narrowing]].

--- Function: *field-beginning* &optional pos escape-from-edge limit

#+BEGIN_QUOTE
  This function returns the beginning of the field specified by pos.

  If pos is at the beginning of its field, and escape-from-edge is non-=nil=, then the return value is always the beginning of the preceding field that /ends/ at pos, regardless of the stickiness of the =field= properties around pos.

  If limit is non-=nil=, it is a buffer position; if the beginning of the field is before limit, then limit will be returned instead.
#+END_QUOTE

--- Function: *field-end* &optional pos escape-from-edge limit

#+BEGIN_QUOTE
  This function returns the end of the field specified by pos.

  If pos is at the end of its field, and escape-from-edge is non-=nil=, then the return value is always the end of the following field that /begins/ at pos, regardless of the stickiness of the =field= properties around pos.

  If limit is non-=nil=, it is a buffer position; if the end of the field is after limit, then limit will be returned instead.
#+END_QUOTE

--- Function: *field-string* &optional pos

#+BEGIN_QUOTE
  This function returns the contents of the field specified by pos, as a string.
#+END_QUOTE

--- Function: *field-string-no-properties* &optional pos

#+BEGIN_QUOTE
  This function returns the contents of the field specified by pos, as a string, discarding text properties.
#+END_QUOTE

--- Function: *delete-field* &optional pos

#+BEGIN_QUOTE
  This function deletes the text of the field specified by pos.
#+END_QUOTE

--- Function: *constrain-to-field* new-pos old-pos &optional escape-from-edge only-in-line inhibit-capture-property

#+BEGIN_QUOTE
  This function constrains new-pos to the field that old-pos belongs to---in other words, it returns the position closest to new-pos that is in the same field as old-pos.

  If new-pos is =nil=, then =constrain-to-field= uses the value of point instead, and moves point to the resulting position in addition to returning that position.

  If old-pos is at the boundary of two fields, then the acceptable final positions depend on the argument escape-from-edge. If escape-from-edge is =nil=, then new-pos must be in the field whose =field= property equals what new characters inserted at old-pos would inherit. (This depends on the stickiness of the =field= property for the characters before and after old-pos.) If escape-from-edge is non-=nil=, new-pos can be anywhere in the two adjacent fields. Additionally, if two fields are separated by another field with the special value =boundary=, then any point within this special field is also considered to be on the boundary.

  Commands like C-a with no argument, that normally move backward to a specific kind of location and stay there once there, probably should specify =nil= for escape-from-edge. Other motion commands that check fields should probably pass =t=.

  If the optional argument only-in-line is non-=nil=, and constraining new-pos in the usual way would move it to a different line, new-pos is returned unconstrained. This used in commands that move by line, such as =next-line= and =beginning-of-line=, so that they respect field boundaries only in the case where they can still move to the right line.

  If the optional argument inhibit-capture-property is non-=nil=, and old-pos has a non-=nil= property of that name, then any field boundaries are ignored.

  You can cause =constrain-to-field= to ignore all field boundaries (and so never constrain anything) by binding the variable =inhibit-field-text-motion= to a non-=nil= value.
#+END_QUOTE

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Fields][Fields]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]

** 32.19.10 Why Text Properties are not Intervals
     :PROPERTIES:
     :CUSTOM_ID: why-text-properties-are-not-intervals
     :END:

Some editors that support adding attributes to text in the buffer do so by letting the user specify intervals within the text, and adding the properties to the intervals. Those editors permit the user or the programmer to determine where individual intervals start and end. We deliberately provided a different sort of interface in Emacs Lisp to avoid certain paradoxical behavior associated with text modification.

If the actual subdivision into intervals is meaningful, that means you can distinguish between a buffer that is just one interval with a certain property, and a buffer containing the same text subdivided into two intervals, both of which have that property.

Suppose you take the buffer with just one interval and kill part of the text. The text remaining in the buffer is one interval, and the copy in the kill ring (and the undo list) becomes a separate interval. Then if you yank back the killed text, you get two intervals with the same properties. Thus, editing does not preserve the distinction between one interval and two.

Suppose we attempt to fix this problem by coalescing the two intervals when the text is inserted. That works fine if the buffer originally was a single interval. But suppose instead that we have two adjacent intervals with the same properties, and we kill the text of one interval and yank it back. The same interval-coalescence feature that rescues the other case causes trouble in this one: after yanking, we have just one interval. Once again, editing does not preserve the distinction between one interval and two.

Insertion of text at the border between intervals also raises questions that have no satisfactory answer.

However, it is easy to arrange for editing to behave consistently for questions of the form, "What are the properties of text at this buffer or string position?" So we have decided these are the only questions that make sense; we have not implemented asking questions about where intervals start or end.

In practice, you can usually use the text property search functions in place of explicit interval boundaries. You can think of them as finding the boundaries of intervals, assuming that intervals are always coalesced whenever possible. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Search][Property Search]].

Emacs also provides explicit intervals as a presentation feature; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlays][Overlays]].

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Registers][Registers]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.20 Substituting for a Character Code
    :PROPERTIES:
    :CUSTOM_ID: substituting-for-a-character-code
    :END:

The following functions replace characters within a specified region based on their character codes.

--- Function: *subst-char-in-region* start end old-char new-char &optional noundo

#+BEGIN_QUOTE
  This function replaces all occurrences of the character old-char with the character new-char in the region of the current buffer defined by start and end.

  If noundo is non-=nil=, then =subst-char-in-region= does not record the change for undo and does not mark the buffer as modified. This was useful for controlling the old selective display feature (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Selective-Display][Selective Display]]).

  =subst-char-in-region= does not move point and returns =nil=.

  #+BEGIN_EXAMPLE
                ---------- Buffer: foo ----------
                This is the contents of the buffer before.
                ---------- Buffer: foo ----------

                (subst-char-in-region 1 20 ?i ?X)
                     ⇒ nil

                ---------- Buffer: foo ----------
                ThXs Xs the contents of the buffer before.
                ---------- Buffer: foo ----------
  #+END_EXAMPLE
#+END_QUOTE

--- Command: *translate-region* start end table

#+BEGIN_QUOTE
  This function applies a translation table to the characters in the buffer between positions start and end.

  The translation table table is a string or a char-table; =(aref=table ochar=)= gives the translated character corresponding to ochar. If table is a string, any characters with codes larger than the length of table are not altered by the translation.

  The return value of =translate-region= is the number of characters that were actually changed by the translation. This does not count characters that were mapped into themselves in the translation table.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Transposition][Transposition]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Substitution][Substitution]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.21 Registers
    :PROPERTIES:
    :CUSTOM_ID: registers
    :END:

A register is a sort of variable used in Emacs editing that can hold a variety of different kinds of values. Each register is named by a single character. All ASCII characters and their meta variants (but with the exception of C-g) can be used to name registers. Thus, there are 255 possible registers. A register is designated in Emacs Lisp by the character that is its name.

--- Variable: *register-alist*

#+BEGIN_QUOTE
  This variable is an alist of elements of the form =(=name=.=contents=)=. Normally, there is one element for each Emacs register that has been used.

  The object name is a character (an integer) identifying the register.
#+END_QUOTE

The contents of a register can have several possible types:

- a number

  A number stands for itself. If =insert-register= finds a number in the register, it converts the number to decimal.

- a marker

  A marker represents a buffer position to jump to.

- a string

  A string is text saved in the register.

- a rectangle

  A rectangle is represented by a list of strings.

- =(=window-configuration position=)=

  This represents a window configuration to restore in one frame, and a position to jump to in the current buffer.

- =(=frame-configuration position=)=

  This represents a frame configuration to restore, and a position to jump to in the current buffer.

- (file filename)

  This represents a file to visit; jumping to this value visits file filename.

- (file-query filename position)

  This represents a file to visit and a position in it; jumping to this value visits file filename and goes to buffer position position. Restoring this type of position asks the user for confirmation first.

The functions in this section return unpredictable values unless otherwise stated.

--- Function: *get-register* reg

#+BEGIN_QUOTE
  This function returns the contents of the register reg, or =nil= if it has no contents.
#+END_QUOTE

--- Function: *set-register* reg value

#+BEGIN_QUOTE
  This function sets the contents of register reg to value. A register can be set to any value, but the other register functions expect only certain data types. The return value is value.
#+END_QUOTE

--- Command: *view-register* reg

#+BEGIN_QUOTE
  This command displays what is contained in register reg.
#+END_QUOTE

--- Command: *insert-register* reg &optional beforep

#+BEGIN_QUOTE
  This command inserts contents of register reg into the current buffer.

  Normally, this command puts point before the inserted text, and the mark after it. However, if the optional second argument beforep is non-=nil=, it puts the mark before and point after.

  When called interactively, the command defaults to putting point after text, and a prefix argument inverts this behavior.

  If the register contains a rectangle, then the rectangle is inserted with its upper left corner at point. This means that text is inserted in the current line and underneath it on successive lines.

  If the register contains something other than saved text (a string) or a rectangle (a list), currently useless things happen. This may be changed in the future.
#+END_QUOTE

--- Function: *register-read-with-preview* prompt

#+BEGIN_QUOTE
  This function reads and returns a register name, prompting with prompt and possibly showing a preview of the existing registers and their contents. The preview is shown in a temporary window, after the delay specified by the user option =register-preview-delay=, if its value and =register-alist= are both non-=nil=. The preview is also shown if the user requests help (e.g., by typing the help character). We recommend that all interactive commands which read register names use this function.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Replacing][Replacing]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Registers][Registers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.22 Transposition of Text
    :PROPERTIES:
    :CUSTOM_ID: transposition-of-text
    :END:

This function can be used to transpose stretches of text:

--- Function: *transpose-regions* start1 end1 start2 end2 &optional leave-markers

#+BEGIN_QUOTE
  This function exchanges two nonoverlapping portions of the buffer (if they overlap, the function signals an error). Arguments start1 and end1 specify the bounds of one portion and arguments start2 and end2 specify the bounds of the other portion.

  Normally, =transpose-regions= relocates markers with the transposed text; a marker previously positioned within one of the two transposed portions moves along with that portion, thus remaining between the same two characters in their new position. However, if leave-markers is non-=nil=, =transpose-regions= does not do this---it leaves all markers unrelocated.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Decompression][Decompression]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Transposition][Transposition]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.23 Replacing Buffer Text
    :PROPERTIES:
    :CUSTOM_ID: replacing-buffer-text
    :END:

You can use the following function to replace the text of one buffer with the text of another buffer:

--- Command: *replace-buffer-contents* source

#+BEGIN_QUOTE
  This function replaces the accessible portion of the current buffer with the accessible portion of the buffer source. source may either be a buffer object or the name of a buffer. When =replace-buffer-contents= succeeds, the text of the accessible portion of the current buffer will be equal to the text of the accessible portion of the source buffer. This function attempts to keep point, markers, text properties, and overlays in the current buffer intact. One potential case where this behavior is useful is external code formatting programs: they typically write the reformatted text into a temporary buffer or file, and using =delete-region= and =insert-buffer-substring= would destroy these properties. However, the latter combination is typically faster. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deletion][Deletion]], and [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Insertion][Insertion]].
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Base-64][Base 64]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Replacing][Replacing]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.24 Dealing With Compressed Data
    :PROPERTIES:
    :CUSTOM_ID: dealing-with-compressed-data
    :END:

When =auto-compression-mode= is enabled, Emacs automatically uncompresses compressed files when you visit them, and automatically recompresses them if you alter and save them. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Compressed-Files][Compressed Files]].

The above feature works by calling an external executable (e.g., gzip). Emacs can also be compiled with support for built-in decompression using the zlib library, which is faster than calling an external program.

--- Function: *zlib-available-p*

#+BEGIN_QUOTE
  This function returns non-=nil= if built-in zlib decompression is available.
#+END_QUOTE

--- Function: *zlib-decompress-region* start end

#+BEGIN_QUOTE
  This function decompresses the region between start and end, using built-in zlib decompression. The region should contain data that were compressed with gzip or zlib. On success, the function replaces the contents of the region with the decompressed data. On failure, the function leaves the region unchanged and returns =nil=. This function can be called only in unibyte buffers.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Checksum_002fHash][Checksum/Hash]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Decompression][Decompression]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.25 Base 64 Encoding
    :PROPERTIES:
    :CUSTOM_ID: base-64-encoding
    :END:

Base 64 code is used in email to encode a sequence of 8-bit bytes as a longer sequence of ASCII graphic characters. It is defined in Internet RFC[[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#fn-15][15]]2045. This section describes the functions for converting to and from this code.

--- Command: *base64-encode-region* beg end &optional no-line-break

#+BEGIN_QUOTE
  This function converts the region from beg to end into base 64 code. It returns the length of the encoded text. An error is signaled if a character in the region is multibyte, i.e., in a multibyte buffer the region must contain only characters from the charsets =ascii=, =eight-bit-control= and =eight-bit-graphic=.

  Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument no-line-break is non-=nil=, these newlines are not added, so the output is just one long line.
#+END_QUOTE

--- Function: *base64-encode-string* string &optional no-line-break

#+BEGIN_QUOTE
  This function converts the string string into base 64 code. It returns a string containing the encoded text. As for =base64-encode-region=, an error is signaled if a character in the string is multibyte.

  Normally, this function inserts newline characters into the encoded text, to avoid overlong lines. However, if the optional argument no-line-break is non-=nil=, these newlines are not added, so the result string is just one long line.
#+END_QUOTE

--- Command: *base64-decode-region* beg end

#+BEGIN_QUOTE
  This function converts the region from beg to end from base 64 code into the corresponding decoded text. It returns the length of the decoded text.

  The decoding functions ignore newline characters in the encoded text.
#+END_QUOTE

--- Function: *base64-decode-string* string

#+BEGIN_QUOTE
  This function converts the string string from base 64 code into the corresponding decoded text. It returns a unibyte string containing the decoded text.

  The decoding functions ignore newline characters in the encoded text.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#GnuTLS-Cryptography][GnuTLS Cryptography]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Base-64][Base 64]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.26 Checksum/Hash
    :PROPERTIES:
    :CUSTOM_ID: checksumhash
    :END:

Emacs has built-in support for computing cryptographic hashes. A cryptographic hash, or checksum, is a digital fingerprint of a piece of data (e.g., a block of text) which can be used to check that you have an unaltered copy of that data.

Emacs supports several common cryptographic hash algorithms: MD5, SHA-1, SHA-2, SHA-224, SHA-256, SHA-384 and SHA-512. MD5 is the oldest of these algorithms, and is commonly used in message digests to check the integrity of messages transmitted over a network. MD5 is not collision resistant (i.e., it is possible to deliberately design different pieces of data which have the same MD5 hash), so you should not used it for anything security-related. A similar theoretical weakness also exists in SHA-1. Therefore, for security-related applications you should use the other hash types, such as SHA-2.

--- Function: *secure-hash-algorithms*

#+BEGIN_QUOTE
  This function returns a list of symbols representing algorithms that =secure-hash= can use.
#+END_QUOTE

--- Function: *secure-hash* algorithm object &optional start end binary

#+BEGIN_QUOTE
  This function returns a hash for object. The argument algorithm is a symbol stating which hash to compute: one of =md5=, =sha1=, =sha224=, =sha256=, =sha384= or =sha512=. The argument object should be a buffer or a string.

  The optional arguments start and end are character positions specifying the portion of object to compute the message digest for. If they are =nil= or omitted, the hash is computed for the whole of object.

  If the argument binary is omitted or =nil=, the function returns the text form of the hash, as an ordinary Lisp string. If binary is non-=nil=, it returns the hash in binary form, as a sequence of bytes stored in a unibyte string.

  This function does not compute the hash directly from the internal representation of object's text (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Representations][Text Representations]]). Instead, it encodes the text using a coding system (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Coding-Systems][Coding Systems]]), and computes the hash from that encoded text. If object is a buffer, the coding system used is the one which would be chosen by default for writing the text into a file. If object is a string, the user's preferred coding system is used (see [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Recognize-Coding][Recognize Coding]]).
#+END_QUOTE

--- Function: *md5* object &optional start end coding-system noerror

#+BEGIN_QUOTE
  This function returns an MD5 hash. It is semi-obsolete, since for most purposes it is equivalent to calling =secure-hash= with =md5= as the algorithm argument. The object, start and end arguments have the same meanings as in =secure-hash=.

  If coding-system is non-=nil=, it specifies a coding system to use to encode the text; if omitted or =nil=, the default coding system is used, like in =secure-hash=.

  Normally, =md5= signals an error if the text can't be encoded using the specified or chosen coding system. However, if noerror is non-=nil=, it silently uses =raw-text= coding instead.
#+END_QUOTE

--- Function: *buffer-hash* &optional buffer-or-name

#+BEGIN_QUOTE
  Return a hash of buffer-or-name. If =nil=, this defaults to the current buffer. As opposed to =secure-hash=, this function computes the hash based on the internal representation of the buffer, disregarding any coding systems. It's therefore only useful when comparing two buffers running in the same Emacs, and is not guaranteed to return the same hash between different Emacs versions. It should be somewhat more efficient on larger buffers than =secure-hash= is, and should not allocate more memory.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Parsing-HTML_002fXML][Parsing HTML/XML]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Checksum_002fHash][Checksum/Hash]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.27 GnuTLS Cryptography
    :PROPERTIES:
    :CUSTOM_ID: gnutls-cryptography
    :END:

If compiled with GnuTLS, Emacs offers built-in cryptographic support. Following the GnuTLS API terminology, the available tools are digests, MACs, symmetric ciphers, and AEAD ciphers.

The terms used herein, such as IV (Initialization Vector), require some familiarity with cryptography and will not be defined in detail. Please consult https://www.gnutls.org/ for specific documentation which may help you understand the terminology and structure of the GnuTLS library.

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]]
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#GnuTLS-Cryptographic-Functions][GnuTLS Cryptographic Functions]]

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#GnuTLS-Cryptographic-Functions][GnuTLS Cryptographic Functions]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#GnuTLS-Cryptography][GnuTLS Cryptography]]

** 32.27.1 Format of GnuTLS Cryptography Inputs
     :PROPERTIES:
     :CUSTOM_ID: format-of-gnutls-cryptography-inputs
     :END:

The inputs to GnuTLS cryptographic functions can be specified in several ways, both as primitive Emacs Lisp types or as lists.

The list form is currently similar to how =md5= and =secure-hash= operate.

- buffer

  Simply passing a buffer as input means the whole buffer should be used.

- string

  A string as input will be used directly. It may be modified by the function (unlike most other Emacs Lisp functions) to reduce the chance of exposing sensitive data after the function does its work.

- =(=buffer-or-string start end coding-system noerror=)=

  This specifies a buffer or a string as described above, but an optional range can be specified with start and end. In addition an optional coding-system can be specified if needed. The last optional item, noerror, overrides the normal error when the text can't be encoded using the specified or chosen coding system. When noerror is non-=nil=, this function silently uses =raw-text= coding instead.

- =(iv-auto=length=)=

  This will generate an IV (Initialization Vector) of the specified length using the GnuTLS =GNUTLS_RND_NONCE= generator and pass it to the function. This ensures that the IV is unpredictable and unlikely to be reused in the same session. The actual value of the IV is returned by the function as described below.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#GnuTLS-Cryptography][GnuTLS Cryptography]]

** 32.27.2 GnuTLS Cryptographic Functions
     :PROPERTIES:
     :CUSTOM_ID: gnutls-cryptographic-functions
     :END:

--- Function: *gnutls-digests*

#+BEGIN_QUOTE
  This function returns the alist of the GnuTLS digest algorithms.

  Each entry has a key which represents the algorithm, followed by a plist with internal details about the algorithm. The plist will have =:type gnutls-digest-algorithm= and also will have the key =:digest-algorithm-length 64= to indicate the size, in bytes, of the resulting digest.

  There is a name parallel between GnuTLS MAC and digest algorithms but they are separate things internally and should not be mixed.
#+END_QUOTE

--- Function: *gnutls-hash-digest* digest-method input

#+BEGIN_QUOTE
  The digest-method can be the whole plist from =gnutls-digests=, or just the symbol key, or a string with the name of that symbol.

  The input can be specified as a buffer or string or in other ways (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]]).

  This function returns =nil= on error, and signals a Lisp error if the digest-method or input are invalid. On success, it returns a list of a binary string (the output) and the IV used.
#+END_QUOTE

--- Function: *gnutls-macs*

#+BEGIN_QUOTE
  This function returns the alist of the GnuTLS MAC algorithms.

  Each entry has a key which represents the algorithm, followed by a plist with internal details about the algorithm. The plist will have =:type gnutls-mac-algorithm= and also will have the keys =:mac-algorithm-length= =:mac-algorithm-keysize= =:mac-algorithm-noncesize= to indicate the size, in bytes, of the resulting hash, the key, and the nonce respectively.

  The nonce is currently unused and only some MACs support it.

  There is a name parallel between GnuTLS MAC and digest algorithms but they are separate things internally and should not be mixed.
#+END_QUOTE

--- Function: *gnutls-hash-mac* hash-method key input

#+BEGIN_QUOTE
  The hash-method can be the whole plist from =gnutls-macs=, or just the symbol key, or a string with the name of that symbol.

  The key can be specified as a buffer or string or in other ways (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]]). The key will be wiped after use if it's a string.

  The input can be specified as a buffer or string or in other ways (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]]).

  This function returns =nil= on error, and signals a Lisp error if the hash-method or key or input are invalid.

  On success, it returns a list of a binary string (the output) and the IV used.
#+END_QUOTE

--- Function: *gnutls-ciphers*

#+BEGIN_QUOTE
  This function returns the alist of the GnuTLS ciphers.

  Each entry has a key which represents the cipher, followed by a plist with internal details about the algorithm. The plist will have =:type gnutls-symmetric-cipher= and also will have the keys =:cipher-aead-capable= set to =nil= or =t= to indicate AEAD capability; and =:cipher-tagsize= =:cipher-blocksize= =:cipher-keysize= =:cipher-ivsize= to indicate the size, in bytes, of the tag, block size of the resulting data, the key, and the IV respectively.
#+END_QUOTE

--- Function: *gnutls-symmetric-encrypt* cipher key iv input &optional aead\_auth

#+BEGIN_QUOTE
  The cipher can be the whole plist from =gnutls-ciphers=, or just the symbol key, or a string with the name of that symbol.

  The key can be specified as a buffer or string or in other ways (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]]). The key will be wiped after use if it's a string.

  The iv and input and the optional aead\_auth can be specified as a buffer or string or in other ways (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]]).

  aead\_auth is only checked with AEAD ciphers, that is, ciphers whose plist has =:cipher-aead-capable t=. Otherwise it's ignored.

  This function returns =nil= on error, and signals a Lisp error if the cipher or key, iv, or input are invalid, or if aead\_auth was specified with an AEAD cipher and was invalid.

  On success, it returns a list of a binary string (the output) and the IV used.
#+END_QUOTE

--- Function: *gnutls-symmetric-decrypt* cipher key iv input &optional aead\_auth

#+BEGIN_QUOTE
  The cipher can be the whole plist from =gnutls-ciphers=, or just the symbol key, or a string with the name of that symbol.

  The key can be specified as a buffer or string or in other ways (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]]). The key will be wiped after use if it's a string.

  The iv and input and the optional aead\_auth can be specified as a buffer or string or in other ways (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Format-of-GnuTLS-Cryptography-Inputs][Format of GnuTLS Cryptography Inputs]]).

  aead\_auth is only checked with AEAD ciphers, that is, ciphers whose plist has =:cipher-aead-capable t=. Otherwise it's ignored.

  This function returns =nil= on decryption error, and signals a Lisp error if the cipher or key, iv, or input are invalid, or if aead\_auth was specified with an AEAD cipher and was invalid.

  On success, it returns a list of a binary string (the output) and the IV used.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Changes][Atomic Changes]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#GnuTLS-Cryptography][GnuTLS Cryptography]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.28 Parsing HTML and XML
    :PROPERTIES:
    :CUSTOM_ID: parsing-html-and-xml
    :END:

When Emacs is compiled with libxml2 support, the following functions are available to parse HTML or XML text into Lisp object trees.

--- Function: *libxml-parse-html-region* start end &optional base-url discard-comments

#+BEGIN_QUOTE
  This function parses the text between start and end as HTML, and returns a list representing the HTML parse tree. It attempts to handle real-world HTML by robustly coping with syntax mistakes.

  The optional argument base-url, if non-=nil=, should be a string specifying the base URL for relative URLs occurring in links.

  If the optional argument discard-comments is non-=nil=, then the parse tree is created without any comments.

  In the parse tree, each HTML node is represented by a list in which the first element is a symbol representing the node name, the second element is an alist of node attributes, and the remaining elements are the subnodes.

  The following example demonstrates this. Given this (malformed) HTML document:

  #+BEGIN_EXAMPLE
                <html><head></head><body width=101><div class=thing>Foo<div>Yes
  #+END_EXAMPLE

  A call to =libxml-parse-html-region= returns this DOM (document object model):

  #+BEGIN_EXAMPLE
                (html nil
                 (head nil)
                 (body ((width . "101"))
                  (div ((class . "thing"))
                   "Foo"
                   (div nil
                    "Yes"))))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *shr-insert-document* dom

#+BEGIN_QUOTE
  This function renders the parsed HTML in dom into the current buffer. The argument dom should be a list as generated by =libxml-parse-html-region=. This function is, e.g., used by [[https://www.gnu.org/software/emacs/manual/html_mono/eww.html#Top][EWW]].
#+END_QUOTE

--- Function: *libxml-parse-xml-region* start end &optional base-url discard-comments

#+BEGIN_QUOTE
  This function is the same as =libxml-parse-html-region=, except that it parses the text as XML rather than HTML (so it is stricter about syntax).
#+END_QUOTE

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Document-Object-Model][Document Object Model]]: Access, manipulate and search the DOM.

Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Parsing-HTML_002fXML][Parsing HTML/XML]]

** 32.28.1 Document Object Model
     :PROPERTIES:
     :CUSTOM_ID: document-object-model
     :END:

The DOM returned by =libxml-parse-html-region= (and the other XML parsing functions) is a tree structure where each node has a node name (called a tag), and optional key/value attribute list, and then a list of child nodes. The child nodes are either strings or DOM objects.

#+BEGIN_EXAMPLE
         (body ((width . "101"))
          (div ((class . "thing"))
           "Foo"
           (div nil
            "Yes")))
#+END_EXAMPLE

--- Function: *dom-node* tag &optional attributes &rest children

#+BEGIN_QUOTE
  This function creates a DOM node of type tag. If given, attributes should be a key/value pair list. If given, children should be DOM nodes.
#+END_QUOTE

The following functions can be used to work with this structure. Each function takes a DOM node, or a list of nodes. In the latter case, only the first node in the list is used.

Simple accessors:

- =dom-tag=node

  Return the tag (also called "node name") of the node.

- =dom-attr=node attribute

  Return the value of attribute in the node. A common usage would be: =(dom-attr img 'href)          => "https://fsf.org/logo.png"=

- =dom-children=node

  Return all the children of the node.

- =dom-non-text-children=node

  Return all the non-string children of the node.

- =dom-attributes=node

  Return the key/value pair list of attributes of the node.

- =dom-text=node

  Return all the textual elements of the node as a concatenated string.

- =dom-texts=node

  Return all the textual elements of the node, as well as the textual elements of all the children of the node, recursively, as a concatenated string. This function also takes an optional separator to be inserted between the textual elements.

- =dom-parent=dom node

  Return the parent of node in dom.

- =dom-remove=dom node

  Remove node from dom.

The following are functions for altering the DOM.

- =dom-set-attribute=node attribute value

  Set the attribute of the node to value.

- =dom-append-child=node child

  Append child as the last child of node.

- =dom-add-child-before=node child before

  Add child to node's child list before the before node. If before is =nil=, make child the first child.

- =dom-set-attributes=node attributes

  Replace all the attributes of the node with a new key/value list.

The following are functions for searching for elements in the DOM. They all return lists of matching nodes.

- =dom-by-tag=dom tag

  Return all nodes in dom that are of type tag. A typical use would be: =(dom-by-tag dom 'td)          => '((td ...) (td ...) (td ...))=

- =dom-by-class=dom match

  Return all nodes in dom that have class names that match match, which is a regular expression.

- =dom-by-style=dom style

  Return all nodes in dom that have styles that match match, which is a regular expression.

- =dom-by-id=dom style

  Return all nodes in dom that have IDs that match match, which is a regular expression.

- =dom-strings=dom

  Return all strings in dom.

Utility functions:

- =dom-pp=dom=&optional=remove-empty

  Pretty-print dom at point. If remove-empty, don't print textual nodes that just contain white-space.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Change-Hooks][Change Hooks]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Parsing-HTML_002fXML][Parsing HTML/XML]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.29 Atomic Change Groups
    :PROPERTIES:
    :CUSTOM_ID: atomic-change-groups
    :END:

In database terminology, an atomic change is an indivisible change---it can succeed entirely or it can fail entirely, but it cannot partly succeed. A Lisp program can make a series of changes to one or several buffers as an atomic change group, meaning that either the entire series of changes will be installed in their buffers or, in case of an error, none of them will be.

To do this for one buffer, the one already current, simply write a call to =atomic-change-group= around the code that makes the changes, like this:

#+BEGIN_EXAMPLE
         (atomic-change-group
           (insert foo)
           (delete-region x y))
#+END_EXAMPLE

If an error (or other nonlocal exit) occurs inside the body of =atomic-change-group=, it unmakes all the changes in that buffer that were during the execution of the body. This kind of change group has no effect on any other buffers---any such changes remain.

If you need something more sophisticated, such as to make changes in various buffers constitute one atomic group, you must directly call lower-level functions that =atomic-change-group= uses.

--- Function: *prepare-change-group* &optional buffer

#+BEGIN_QUOTE
  This function sets up a change group for buffer buffer, which defaults to the current buffer. It returns a handle that represents the change group. You must use this handle to activate the change group and subsequently to finish it.
#+END_QUOTE

To use the change group, you must activate it. You must do this before making any changes in the text of buffer.

--- Function: *activate-change-group* handle

#+BEGIN_QUOTE
  This function activates the change group that handle designates.
#+END_QUOTE

After you activate the change group, any changes you make in that buffer become part of it. Once you have made all the desired changes in the buffer, you must finish the change group. There are two ways to do this: you can either accept (and finalize) all the changes, or cancel them all.

--- Function: *accept-change-group* handle

#+BEGIN_QUOTE
  This function accepts all the changes in the change group specified by handle, making them final.
#+END_QUOTE

--- Function: *cancel-change-group* handle

#+BEGIN_QUOTE
  This function cancels and undoes all the changes in the change group specified by handle.
#+END_QUOTE

Your code should use =unwind-protect= to make sure the group is always finished. The call to =activate-change-group= should be inside the =unwind-protect=, in case the user types C-g just after it runs. (This is one reason why =prepare-change-group= and =activate-change-group= are separate functions, because normally you would call =prepare-change-group= before the start of that =unwind-protect=.) Once you finish the group, don't use the handle again---in particular, don't try to finish the same group twice.

To make a multibuffer change group, call =prepare-change-group= once for each buffer you want to cover, then use =nconc= to combine the returned values, like this:

#+BEGIN_EXAMPLE
         (nconc (prepare-change-group buffer-1)
                (prepare-change-group buffer-2))
#+END_EXAMPLE

You can then activate the multibuffer change group with a single call to =activate-change-group=, and finish it with a single call to =accept-change-group= or =cancel-change-group=.

Nested use of several change groups for the same buffer works as you would expect. Non-nested use of change groups for the same buffer will get Emacs confused, so don't let it happen; the first change group you start for any given buffer should be the last one finished.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Changes][Atomic Changes]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]

* 32.30 Change Hooks
    :PROPERTIES:
    :CUSTOM_ID: change-hooks
    :END:

These hook variables let you arrange to take notice of changes in buffers (or in a particular buffer, if you make them buffer-local). See also [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]], for how to detect changes to specific parts of the text.

The functions you use in these hooks should save and restore the match data if they do anything that uses regular expressions; otherwise, they will interfere in bizarre ways with the editing operations that call them.

--- Variable: *before-change-functions*

#+BEGIN_QUOTE
  This variable holds a list of functions to call when Emacs is about to modify a buffer. Each function gets two arguments, the beginning and end of the region that is about to change, represented as integers. The buffer that is about to change is always the current buffer when the function is called.
#+END_QUOTE

--- Variable: *after-change-functions*

#+BEGIN_QUOTE
  This variable holds a list of functions to call after Emacs modifies a buffer. Each function receives three arguments: the beginning and end of the region just changed, and the length of the text that existed before the change. All three arguments are integers. The buffer that has been changed is always the current buffer when the function is called.

  The length of the old text is the difference between the buffer positions before and after that text as it was before the change. As for the changed text, its length is simply the difference between the first two arguments.
#+END_QUOTE

Output of messages into the /Messages/ buffer does not call these functions, and neither do certain internal buffer changes, such as changes in buffers created by Emacs internally for certain jobs, that should not be visible to Lisp programs.

The vast majority of buffer changing primitives will call =before-change-functions= and =after-change-functions= in balanced pairs, once for each change, where the arguments to these hooks exactly delimit the change being made. Yet, hook functions should not rely on this always being the case, because some complex primitives call =before-change-functions= once before making changes, and then call =after-change-functions= zero or more times, depending on how many individual changes the primitive is making. When that happens, the arguments to =before-change-functions= will enclose a region in which the individual changes are made, but won't necessarily be the minimal such region, and the arguments to each successive call of =after-change-functions= will then delimit the part of text being changed exactly. In general, we advise to use either before- or the after-change hooks, but not both.

--- Macro: *combine-after-change-calls* body...

#+BEGIN_QUOTE
  The macro executes body normally, but arranges to call the after-change functions just once for a series of several changes---if that seems safe.

  If a program makes several text changes in the same area of the buffer, using the macro =combine-after-change-calls= around that part of the program can make it run considerably faster when after-change hooks are in use. When the after-change hooks are ultimately called, the arguments specify a portion of the buffer including all of the changes made within the =combine-after-change-calls= body.

  *Warning:* You must not alter the values of =after-change-functions= within the body of a =combine-after-change-calls= form.

  *Warning:* if the changes you combine occur in widely scattered parts of the buffer, this will still work, but it is not advisable, because it may lead to inefficient behavior for some change hook functions.
#+END_QUOTE

--- Variable: *first-change-hook*

#+BEGIN_QUOTE
  This variable is a normal hook that is run whenever a buffer is changed that was previously in the unmodified state.
#+END_QUOTE

--- Variable: *inhibit-modification-hooks*

#+BEGIN_QUOTE
  If this variable is non-=nil=, all of the change hooks are disabled; none of them run. This affects all the hook variables described above in this section, as well as the hooks attached to certain special text properties (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]]) and overlay properties (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlay-Properties][Overlay Properties]]).

  Also, this variable is bound to non-=nil= while running those same hook variables, so that by default modifying the buffer from a modification hook does not cause other modification hooks to be run. If you do want modification hooks to be run in a particular piece of code that is itself run from a modification hook, then rebind locally =inhibit-modification-hooks= to =nil=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Searching-and-Matching][Searching and Matching]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Top][Top]]

