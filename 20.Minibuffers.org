#+TITLE: 20.Minibuffers
* 20 Minibuffers
   :PROPERTIES:
   :CUSTOM_ID: minibuffers
   :END:

A minibuffer is a special buffer that Emacs commands use to read arguments more complicated than the single numeric prefix argument. These arguments include file names, buffer names, and command names (as in M-x). The minibuffer is displayed on the bottom line of the frame, in the same place as the echo area (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Echo-Area][The Echo Area]]), but only while it is in use for reading an argument.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Intro-to-Minibuffers][Intro to Minibuffers]]: Basic information about minibuffers.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-from-Minibuffer][Text from Minibuffer]]: How to read a straight text string.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Object-from-Minibuffer][Object from Minibuffer]]: How to read a Lisp object or expression.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-History][Minibuffer History]]: Recording previous minibuffer inputs so the user can reuse them.
5) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Initial-Input][Initial Input]]: Specifying initial contents for the minibuffer.
6) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]: How to invoke and customize completion.
7) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yes_002dor_002dNo-Queries][Yes-or-No Queries]]: Asking a question with a simple answer.
8) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Multiple-Queries][Multiple Queries]]: Asking complex questions.
9) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Reading-a-Password][Reading a Password]]: Reading a password from the terminal.
10) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Commands][Minibuffer Commands]]: Commands used as key bindings in minibuffers.
11) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Windows][Minibuffer Windows]]: Operating on the special minibuffer windows.
12) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Contents][Minibuffer Contents]]: How such commands access the minibuffer text.
13) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recursive-Mini][Recursive Mini]]: Whether recursive entry to minibuffer is allowed.
14) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Misc][Minibuffer Misc]]: Various customization hooks and variables.


* 20.1 Introduction to Minibuffers
    :PROPERTIES:
    :CUSTOM_ID: introduction-to-minibuffers
    :END:

In most ways, a minibuffer is a normal Emacs buffer. Most operations /within/ a buffer, such as editing commands, work normally in a minibuffer. However, many operations for managing buffers do not apply to minibuffers. The name of a minibuffer always has the form ‘ /Minibuf-number/', and it cannot be changed. Minibuffers are displayed only in special windows used only for minibuffers; these windows always appear at the bottom of a frame. (Sometimes frames have no minibuffer window, and sometimes a special kind of frame contains nothing but a minibuffer window; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers-and-Frames][Minibuffers and Frames]].)

The text in the minibuffer always starts with the prompt string, the text that was specified by the program that is using the minibuffer to tell the user what sort of input to type. This text is marked read-only so you won't accidentally delete or change it. It is also marked as a field (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Fields][Fields]]), so that certain motion functions, including =beginning-of-line=, =forward-word=, =forward-sentence=, and =forward-paragraph=, stop at the boundary between the prompt and the actual text.

The minibuffer's window is normally a single line; it grows automatically if the contents require more space. Whilst the minibuffer is active, you can explicitly resize its window temporarily with the window sizing commands; the window reverts to its normal size when the minibuffer is exited. When the minibuffer is not active, you can resize its window permanently by using the window sizing commands in the frame's other window, or dragging the mode line with the mouse. (Due to details of the current implementation, for this to work =resize-mini-windows= must be =nil=.) If the frame contains just a minibuffer window, you can change its size by changing the frame's size.

Use of the minibuffer reads input events, and that alters the values of variables such as =this-command= and =last-command= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Command-Loop-Info][Command Loop Info]]). Your program should bind them around the code that uses the minibuffer, if you do not want that to change them.

Under some circumstances, a command can use a minibuffer even if there is an active minibuffer; such a minibuffer is called a recursive minibuffer. The first minibuffer is named ‘ /Minibuf-1/'. Recursive minibuffers are named by incrementing the number at the end of the name. (The names begin with a space so that they won't show up in normal buffer lists.) Of several recursive minibuffers, the innermost (or most recently entered) is the active minibuffer. We usually call this /the/ minibuffer. You can permit or forbid recursive minibuffers by setting the variable =enable-recursive-minibuffers=, or by putting properties of that name on command symbols (See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recursive-Mini][Recursive Mini]].)

Like other buffers, a minibuffer uses a local keymap (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymaps][Keymaps]]) to specify special key bindings. The function that invokes the minibuffer also sets up its local map according to the job to be done. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-from-Minibuffer][Text from Minibuffer]], for the non-completion minibuffer local maps. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Commands][Completion Commands]], for the minibuffer local maps for completion.

When a minibuffer is inactive, its major mode is =minibuffer-inactive-mode=, with keymap =minibuffer-inactive-mode-map=. This is only really useful if the minibuffer is in a separate frame. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers-and-Frames][Minibuffers and Frames]].

When Emacs is running in batch mode, any request to read from the minibuffer actually reads a line from the standard input descriptor that was supplied when Emacs was started. This supports only basic input: none of the special minibuffer features (history, completion, etc.) are available in batch mode.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Object-from-Minibuffer][Object from Minibuffer]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Intro-to-Minibuffers][Intro to Minibuffers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.2 Reading Text Strings with the Minibuffer
    :PROPERTIES:
    :CUSTOM_ID: reading-text-strings-with-the-minibuffer
    :END:

The most basic primitive for minibuffer input is =read-from-minibuffer=, which can be used to read either a string or a Lisp object in textual form. The function =read-regexp= is used for reading regular expressions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Regular-Expressions][Regular Expressions]]), which are a special kind of string. There are also specialized functions for reading commands, variables, file names, etc. (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]).

In most cases, you should not call minibuffer input functions in the middle of a Lisp function. Instead, do all minibuffer input as part of reading the arguments for a command, in the =interactive= specification. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Defining-Commands][Defining Commands]].

--- Function: *read-from-minibuffer* prompt &optional initial keymap read history default inherit-input-method

#+BEGIN_QUOTE
  This function is the most general way to get input from the minibuffer. By default, it accepts arbitrary text and returns it as a string; however, if read is non-=nil=, then it uses =read= to convert the text into a Lisp object (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Functions][Input Functions]]).

  The first thing this function does is to activate a minibuffer and display it with prompt (which must be a string) as the prompt. Then the user can edit text in the minibuffer.

  When the user types a command to exit the minibuffer, =read-from-minibuffer= constructs the return value from the text in the minibuffer. Normally it returns a string containing that text. However, if read is non-=nil=, =read-from-minibuffer= reads the text and returns the resulting Lisp object, unevaluated. (See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Functions][Input Functions]], for information about reading.)

  The argument default specifies default values to make available through the history commands. It should be a string, a list of strings, or =nil=. The string or strings become the minibuffer's "future history", available to the user with M-n.

  If read is non-=nil=, then default is also used as the input to =read=, if the user enters empty input. If default is a list of strings, the first string is used as the input. If default is =nil=, empty input results in an =end-of-file= error. However, in the usual case (where read is =nil=), =read-from-minibuffer= ignores default when the user enters empty input and returns an empty string, =""=. In this respect, it differs from all the other minibuffer input functions in this chapter.

  If keymap is non-=nil=, that keymap is the local keymap to use in the minibuffer. If keymap is omitted or =nil=, the value of =minibuffer-local-map= is used as the keymap. Specifying a keymap is the most important way to customize the minibuffer for various applications such as completion.

  The argument history specifies a history list variable to use for saving the input and for history commands used in the minibuffer. It defaults to =minibuffer-history=. You can optionally specify a starting position in the history list as well. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-History][Minibuffer History]].

  If the variable =minibuffer-allow-text-properties= is non-=nil=, then the string that is returned includes whatever text properties were present in the minibuffer. Otherwise all the text properties are stripped when the value is returned.

  The text properties in =minibuffer-prompt-properties= are applied to the prompt. By default, this property list defines a face to use for the prompt. This face, if present, is applied to the end of the face list and merged before display.

  If the user wants to completely control the look of the prompt, the most convenient way to do that is to specify the =default= face at the end of all face lists. For instance:

  #+BEGIN_EXAMPLE
                (read-from-minibuffer
                 (concat
                  (propertize "Bold" 'face '(bold default))
                  (propertize " and normal: " 'face '(default))))
  #+END_EXAMPLE

  If the argument inherit-input-method is non-=nil=, then the minibuffer inherits the current input method (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Methods][Input Methods]]) and the setting of =enable-multibyte-characters= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Representations][Text Representations]]) from whichever buffer was current before entering the minibuffer.

  Use of initial is mostly deprecated; we recommend using a non-=nil= value only in conjunction with specifying a cons cell for history. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Initial-Input][Initial Input]].
#+END_QUOTE

--- Function: *read-string* prompt &optional initial history default inherit-input-method

#+BEGIN_QUOTE
  This function reads a string from the minibuffer and returns it. The arguments prompt, initial, history and inherit-input-method are used as in =read-from-minibuffer=. The keymap used is =minibuffer-local-map=.

  The optional argument default is used as in =read-from-minibuffer=, except that, if non-=nil=, it also specifies a default value to return if the user enters null input. As in =read-from-minibuffer= it should be a string, a list of strings, or =nil=, which is equivalent to an empty string. When default is a string, that string is the default value. When it is a list of strings, the first string is the default value. (All these strings are available to the user in the "future minibuffer history".)

  This function works by calling the =read-from-minibuffer= function:

  #+BEGIN_EXAMPLE
                (read-string prompt initial history default inherit)
                ==
                (let ((value
                       (read-from-minibuffer prompt initial nil nil
                                             history default inherit)))
                  (if (and (equal value "") default)
                      (if (consp default) (car default) default)
                    value))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *read-regexp* prompt &optional defaults history

#+BEGIN_QUOTE
  This function reads a regular expression as a string from the minibuffer and returns it. If the minibuffer prompt string prompt does not end in ':' (followed by optional whitespace), the function adds ':' to the end, preceded by the default return value (see below), if that is non-empty.

  The optional argument defaults controls the default value to return if the user enters null input, and should be one of: a string; =nil=, which is equivalent to an empty string; a list of strings; or a symbol.

  If defaults is a symbol, =read-regexp= consults the value of the variable =read-regexp-defaults-function= (see below), and if that is non-=nil= uses it in preference to defaults. The value in this case should be either:

  - =regexp-history-last=, which means to use the first element of the appropriate minibuffer history list (see below).\\
  - A function of no arguments, whose return value (which should be =nil=, a string, or a list of strings) becomes the value of defaults.

  =read-regexp= now ensures that the result of processing defaults is a list (i.e., if the value is =nil= or a string, it converts it to a list of one element). To this list, =read-regexp= then appends a few potentially useful candidates for input. These are:

  - The word or symbol at point.
  - The last regexp used in an incremental search.
  - The last string used in an incremental search.
  - The last string or pattern used in query-replace commands.

  The function now has a list of regular expressions that it passes to =read-from-minibuffer= to obtain the user's input. The first element of the list is the default result in case of empty input. All elements of the list are available to the user as the "future minibuffer history" list (see [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Minibuffer-History][future list]]).

  The optional argument history, if non-=nil=, is a symbol specifying a minibuffer history list to use (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-History][Minibuffer History]]). If it is omitted or =nil=, the history list defaults to =regexp-history=.
#+END_QUOTE

--- User Option: *read-regexp-defaults-function*

#+BEGIN_QUOTE
  The function =read-regexp= may use the value of this variable to determine its list of default regular expressions. If non-=nil=, the value of this variable should be either:

  - The symbol =regexp-history-last=.\\
  - A function of no arguments that returns either =nil=, a string, or a list of strings.

  See =read-regexp= above for details of how these values are used.
#+END_QUOTE

--- Variable: *minibuffer-allow-text-properties*

#+BEGIN_QUOTE
  If this variable is =nil=, then =read-from-minibuffer= and =read-string= strip all text properties from the minibuffer input before returning it. However, =read-no-blanks-input= (see below), as well as =read-minibuffer= and related functions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Object-from-Minibuffer][Reading Lisp Objects With the Minibuffer]]), and all functions that do minibuffer input with completion, discard text properties unconditionally, regardless of the value of this variable.
#+END_QUOTE

--- Variable: *minibuffer-local-map*

#+BEGIN_QUOTE
  This is the default local keymap for reading from the minibuffer. By default, it makes the following bindings:

  - C-j

    =exit-minibuffer=

  -

    =exit-minibuffer=

  - C-g

    =abort-recursive-edit=

  - M-n

  -

    =next-history-element=

  - M-p

  -

    =previous-history-element=

  - M-s

    =next-matching-history-element=

  - M-r

    =previous-matching-history-element=

#+END_QUOTE

--- Function: *read-no-blanks-input* prompt &optional initial inherit-input-method

#+BEGIN_QUOTE
  This function reads a string from the minibuffer, but does not allow whitespace characters as part of the input: instead, those characters terminate the input. The arguments prompt, initial, and inherit-input-method are used as in =read-from-minibuffer=.

  This is a simplified interface to the =read-from-minibuffer= function, and passes the value of the =minibuffer-local-ns-map= keymap as the keymap argument for that function. Since the keymap =minibuffer-local-ns-map= does not rebind C-q, it /is/ possible to put a space into the string, by quoting it.

  This function discards text properties, regardless of the value of =minibuffer-allow-text-properties=.

  #+BEGIN_EXAMPLE
                (read-no-blanks-input prompt initial)
                ==
                (let (minibuffer-allow-text-properties)
                  (read-from-minibuffer prompt initial minibuffer-local-ns-map))
  #+END_EXAMPLE
#+END_QUOTE

--- Variable: *minibuffer-local-ns-map*

#+BEGIN_QUOTE
  This built-in variable is the keymap used as the minibuffer local keymap in the function =read-no-blanks-input=. By default, it makes the following bindings, in addition to those of =minibuffer-local-map=:

  -

    =exit-minibuffer=

  -

    =exit-minibuffer=

  - ?

    =self-insert-and-exit=

#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-History][Minibuffer History]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-from-Minibuffer][Text from Minibuffer]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.3 Reading Lisp Objects with the Minibuffer
    :PROPERTIES:
    :CUSTOM_ID: reading-lisp-objects-with-the-minibuffer
    :END:

This section describes functions for reading Lisp objects with the minibuffer.

--- Function: *read-minibuffer* prompt &optional initial

#+BEGIN_QUOTE
  This function reads a Lisp object using the minibuffer, and returns it without evaluating it. The arguments prompt and initial are used as in =read-from-minibuffer=.

  This is a simplified interface to the =read-from-minibuffer= function:

  #+BEGIN_EXAMPLE
                (read-minibuffer prompt initial)
                ==
                (let (minibuffer-allow-text-properties)
                  (read-from-minibuffer prompt initial nil t))
  #+END_EXAMPLE

  Here is an example in which we supply the string ="(testing)"= as initial input:

  #+BEGIN_EXAMPLE
                (read-minibuffer
                 "Enter an expression: " (format "%s" '(testing)))

                ;; Here is how the minibuffer is displayed:

                ---------- Buffer: Minibuffer ----------
                Enter an expression: (testing)-!-
                ---------- Buffer: Minibuffer ----------
  #+END_EXAMPLE

  The user can type immediately to use the initial input as a default, or can edit the input.
#+END_QUOTE

--- Function: *eval-minibuffer* prompt &optional initial

#+BEGIN_QUOTE
  This function reads a Lisp expression using the minibuffer, evaluates it, then returns the result. The arguments prompt and initial are used as in =read-from-minibuffer=.

  This function simply evaluates the result of a call to =read-minibuffer=:

  #+BEGIN_EXAMPLE
                (eval-minibuffer prompt initial)
                ==
                (eval (read-minibuffer prompt initial))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *edit-and-eval-command* prompt form

#+BEGIN_QUOTE
  This function reads a Lisp expression in the minibuffer, evaluates it, then returns the result. The difference between this command and =eval-minibuffer= is that here the initial form is not optional and it is treated as a Lisp object to be converted to printed representation rather than as a string of text. It is printed with =prin1=, so if it is a string, double-quote characters ('"') appear in the initial text. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Output-Functions][Output Functions]].

  In the following example, we offer the user an expression with initial text that is already a valid form:

  #+BEGIN_EXAMPLE
                (edit-and-eval-command "Please edit: " '(forward-word 1))

                ;; After evaluation of the preceding expression,
                ;;   the following appears in the minibuffer:

                ---------- Buffer: Minibuffer ----------
                Please edit: (forward-word 1)-!-
                ---------- Buffer: Minibuffer ----------
  #+END_EXAMPLE

  Typing right away would exit the minibuffer and evaluate the expression, thus moving point forward one word.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Initial-Input][Initial Input]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Object-from-Minibuffer][Object from Minibuffer]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.4 Minibuffer History
    :PROPERTIES:
    :CUSTOM_ID: minibuffer-history
    :END:

A minibuffer history list records previous minibuffer inputs so the user can reuse them conveniently. It is a variable whose value is a list of strings (previous inputs), most recent first.

There are many separate minibuffer history lists, used for different kinds of inputs. It's the Lisp programmer's job to specify the right history list for each use of the minibuffer.

You specify a minibuffer history list with the optional history argument to =read-from-minibuffer= or =completing-read=. Here are the possible values for it:

- variable

  Use variable (a symbol) as the history list.

- (variable . startpos)

  Use variable (a symbol) as the history list, and assume that the initial history position is startpos (a nonnegative integer). Specifying 0 for startpos is equivalent to just specifying the symbol variable. =previous-history-element= will display the most recent element of the history list in the minibuffer. If you specify a positive startpos, the minibuffer history functions behave as if =(elt=variable=(1-=startpos=))= were the history element currently shown in the minibuffer. For consistency, you should also specify that element of the history as the initial minibuffer contents, using the initial argument to the minibuffer input function (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Initial-Input][Initial Input]]).

If you don't specify history, then the default history list =minibuffer-history= is used. For other standard history lists, see below. You can also create your own history list variable; just initialize it to =nil= before the first use.

Both =read-from-minibuffer= and =completing-read= add new elements to the history list automatically, and provide commands to allow the user to reuse items on the list. The only thing your program needs to do to use a history list is to initialize it and to pass its name to the input functions when you wish. But it is safe to modify the list by hand when the minibuffer input functions are not using it.

Emacs functions that add a new element to a history list can also delete old elements if the list gets too long. The variable =history-length= specifies the maximum length for most history lists. To specify a different maximum length for a particular history list, put the length in the =history-length= property of the history list symbol. The variable =history-delete-duplicates= specifies whether to delete duplicates in history.

--- Function: *add-to-history* history-var newelt &optional maxelt keep-all

#+BEGIN_QUOTE
  This function adds a new element newelt, if it isn't the empty string, to the history list stored in the variable history-var, and returns the updated history list. It limits the list length to the value of maxelt (if non-=nil=) or =history-length= (described below). The possible values of maxelt have the same meaning as the values of =history-length=.

  Normally, =add-to-history= removes duplicate members from the history list if =history-delete-duplicates= is non-=nil=. However, if keep-all is non-=nil=, that says not to remove duplicates, and to add newelt to the list even if it is empty.
#+END_QUOTE

--- Variable: *history-add-new-input*

#+BEGIN_QUOTE
  If the value of this variable is =nil=, standard functions that read from the minibuffer don't add new elements to the history list. This lets Lisp programs explicitly manage input history by using =add-to-history=. The default value is =t=.
#+END_QUOTE

--- User Option: *history-length*

#+BEGIN_QUOTE
  The value of this variable specifies the maximum length for all history lists that don't specify their own maximum lengths. If the value is =t=, that means there is no maximum (don't delete old elements). If a history list variable's symbol has a non-=nil= =history-length= property, it overrides this variable for that particular history list.
#+END_QUOTE

--- User Option: *history-delete-duplicates*

#+BEGIN_QUOTE
  If the value of this variable is =t=, that means when adding a new history element, all previous identical elements are deleted.
#+END_QUOTE

Here are some of the standard minibuffer history list variables:

--- Variable: *minibuffer-history*

#+BEGIN_QUOTE
  The default history list for minibuffer history input.
#+END_QUOTE

--- Variable: *query-replace-history*

#+BEGIN_QUOTE
  A history list for arguments to =query-replace= (and similar arguments to other commands).
#+END_QUOTE

--- Variable: *file-name-history*

#+BEGIN_QUOTE
  A history list for file-name arguments.
#+END_QUOTE

--- Variable: *buffer-name-history*

#+BEGIN_QUOTE
  A history list for buffer-name arguments.
#+END_QUOTE

--- Variable: *regexp-history*

#+BEGIN_QUOTE
  A history list for regular expression arguments.
#+END_QUOTE

--- Variable: *extended-command-history*

#+BEGIN_QUOTE
  A history list for arguments that are names of extended commands.
#+END_QUOTE

--- Variable: *shell-command-history*

#+BEGIN_QUOTE
  A history list for arguments that are shell commands.
#+END_QUOTE

--- Variable: *read-expression-history*

#+BEGIN_QUOTE
  A history list for arguments that are Lisp expressions to evaluate.
#+END_QUOTE

--- Variable: *face-name-history*

#+BEGIN_QUOTE
  A history list for arguments that are faces.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-History][Minibuffer History]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.5 Initial Input
    :PROPERTIES:
    :CUSTOM_ID: initial-input
    :END:

Several of the functions for minibuffer input have an argument called initial. This is a mostly-deprecated feature for specifying that the minibuffer should start out with certain text, instead of empty as usual.

If initial is a string, the minibuffer starts out containing the text of the string, with point at the end, when the user starts to edit the text. If the user simply types to exit the minibuffer, it will use the initial input string to determine the value to return.

*We discourage use of a non-*=nil= *value for* initial, because initial input is an intrusive interface. History lists and default values provide a much more convenient method to offer useful default inputs to the user.

There is just one situation where you should specify a string for an initial argument. This is when you specify a cons cell for the history argument. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-History][Minibuffer History]].

initial can also be a cons cell of the form =(=string=.=position=)=. This means to insert string in the minibuffer but put point at position within the string's text.

As a historical accident, position was implemented inconsistently in different functions. In =completing-read=, position's value is interpreted as origin-zero; that is, a value of 0 means the beginning of the string, 1 means after the first character, etc. In =read-minibuffer=, and the other non-completion minibuffer input functions that support this argument, 1 means the beginning of the string, 2 means after the first character, etc.

Use of a cons cell as the value for initial arguments is deprecated.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yes_002dor_002dNo-Queries][Yes-or-No Queries]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Initial-Input][Initial Input]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.6 Completion
    :PROPERTIES:
    :CUSTOM_ID: completion
    :END:

Completion is a feature that fills in the rest of a name starting from an abbreviation for it. Completion works by comparing the user's input against a list of valid names and determining how much of the name is determined uniquely by what the user has typed. For example, when you type C-x b (=switch-to-buffer=) and then type the first few letters of the name of the buffer to which you wish to switch, and then type (=minibuffer-complete=), Emacs extends the name as far as it can.

Standard Emacs commands offer completion for names of symbols, files, buffers, and processes; with the functions in this section, you can implement completion for other kinds of names.

The =try-completion= function is the basic primitive for completion: it returns the longest determined completion of a given initial string, with a given set of strings to match against.

The function =completing-read= provides a higher-level interface for completion. A call to =completing-read= specifies how to determine the list of valid names. The function then activates the minibuffer with a local keymap that binds a few keys to commands useful for completion. Other functions provide convenient simple interfaces for reading certain kinds of names with completion.

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]: Low-level functions for completing strings.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Completion][Minibuffer Completion]]: Invoking the minibuffer with completion.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Commands][Completion Commands]]: Minibuffer commands that do completion.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#High_002dLevel-Completion][High-Level Completion]]: Convenient special cases of completion (reading buffer names, variable names, etc.).
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Reading-File-Names][Reading File Names]]: Using completion to read file names and shell commands.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Variables][Completion Variables]]: Variables controlling completion behavior.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programmed-Completion][Programmed Completion]]: Writing your own completion function.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-in-Buffers][Completion in Buffers]]: Completing text in ordinary buffers.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Completion][Minibuffer Completion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]

** 20.6.1 Basic Completion Functions
     :PROPERTIES:
     :CUSTOM_ID: basic-completion-functions
     :END:

The following completion functions have nothing in themselves to do with minibuffers. We describe them here to keep them near the higher-level completion features that do use the minibuffer.

--- Function: *try-completion* string collection &optional predicate

#+BEGIN_QUOTE
  This function returns the longest common substring of all possible completions of string in collection.

  collection is called the completion table. Its value must be a list of strings or cons cells, an obarray, a hash table, or a completion function.

  =try-completion= compares string against each of the permissible completions specified by the completion table. If no permissible completions match, it returns =nil=. If there is just one matching completion, and the match is exact, it returns =t=. Otherwise, it returns the longest initial sequence common to all possible matching completions.

  If collection is a list, the permissible completions are specified by the elements of the list, each of which should be either a string, or a cons cell whose car is either a string or a symbol (a symbol is converted to a string using =symbol-name=). If the list contains elements of any other type, those are ignored.

  If collection is an obarray (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Symbols][Creating Symbols]]), the names of all symbols in the obarray form the set of permissible completions.

  If collection is a hash table, then the keys that are strings or symbols are the possible completions. Other keys are ignored.

  You can also use a function as collection. Then the function is solely responsible for performing completion; =try-completion= returns whatever this function returns. The function is called with three arguments: string, predicate and =nil= (the third argument is so that the same function can be used in =all-completions= and do the appropriate thing in either case). See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programmed-Completion][Programmed Completion]].

  If the argument predicate is non-=nil=, then it must be a function of one argument, unless collection is a hash table, in which case it should be a function of two arguments. It is used to test each possible match, and the match is accepted only if predicate returns non-=nil=. The argument given to predicate is either a string or a cons cell (the car of which is a string) from the alist, or a symbol (/not/ a symbol name) from the obarray. If collection is a hash table, predicate is called with two arguments, the string key and the associated value.

  In addition, to be acceptable, a completion must also match all the regular expressions in =completion-regexp-list=. (Unless collection is a function, in which case that function has to handle =completion-regexp-list= itself.)

  In the first of the following examples, the string 'foo' is matched by three of the alist cars. All of the matches begin with the characters 'fooba', so that is the result. In the second example, there is only one possible match, and it is exact, so the return value is =t=.

  #+BEGIN_EXAMPLE
                (try-completion
                 "foo"
                 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
                     ⇒ "fooba"

                (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
                     ⇒ t
  #+END_EXAMPLE

  In the following example, numerous symbols begin with the characters 'forw', and all of them begin with the word 'forward'. In most of the symbols, this is followed with a '-', but not in all, so no more than 'forward' can be completed.

  #+BEGIN_EXAMPLE
                (try-completion "forw" obarray)
                     ⇒ "forward"
  #+END_EXAMPLE

  Finally, in the following example, only two of the three possible matches pass the predicate =test= (the string 'foobaz' is too short). Both of those begin with the string 'foobar'.

  #+BEGIN_EXAMPLE
                (defun test (s)
                  (> (length (car s)) 6))
                     ⇒ test
                (try-completion
                 "foo"
                 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
                 'test)
                     ⇒ "foobar"
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *all-completions* string collection &optional predicate

#+BEGIN_QUOTE
  This function returns a list of all possible completions of string. The arguments to this function are the same as those of =try-completion=, and it uses =completion-regexp-list= in the same way that =try-completion= does.

  If collection is a function, it is called with three arguments: string, predicate and =t=; then =all-completions= returns whatever the function returns. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programmed-Completion][Programmed Completion]].

  Here is an example, using the function =test= shown in the example for =try-completion=:

  #+BEGIN_EXAMPLE
                (defun test (s)
                  (> (length (car s)) 6))
                     ⇒ test

                (all-completions
                 "foo"
                 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
                 'test)
                     ⇒ ("foobar1" "foobar2")
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *test-completion* string collection &optional predicate

#+BEGIN_QUOTE
  This function returns non-=nil= if string is a valid completion alternative specified by collection and predicate. The arguments are the same as in =try-completion=. For instance, if collection is a list of strings, this is true if string appears in the list and predicate is satisfied.

  This function uses =completion-regexp-list= in the same way that =try-completion= does.

  If predicate is non-=nil= and if collection contains several strings that are equal to each other, as determined by =compare-strings= according to =completion-ignore-case=, then predicate should accept either all or none of them. Otherwise, the return value of =test-completion= is essentially unpredictable.

  If collection is a function, it is called with three arguments, the values string, predicate and =lambda=; whatever it returns, =test-completion= returns in turn.
#+END_QUOTE

--- Function: *completion-boundaries* string collection predicate suffix

#+BEGIN_QUOTE
  This function returns the boundaries of the field on which collection will operate, assuming that string holds the text before point and suffix holds the text after point.

  Normally completion operates on the whole string, so for all normal collections, this will always return =(0 . (length=suffix=))=. But more complex completion such as completion on files is done one field at a time. For example, completion of ="/usr/sh"= will include ="/usr/share/"= but not ="/usr/share/doc"= even if ="/usr/share/doc"= exists. Also =all-completions= on ="/usr/sh"= will not include ="/usr/share/"= but only ="share/"=. So if string is ="/usr/sh"= and suffix is ="e/doc"=, =completion-boundaries= will return =(5 . 1)= which tells us that the collection will only return completion information that pertains to the area after ="/usr/"= and before ="/doc"=.
#+END_QUOTE

If you store a completion alist in a variable, you should mark the variable as risky by giving it a non-=nil= =risky-local-variable= property. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#File-Local-Variables][File Local Variables]].

--- Variable: *completion-ignore-case*

#+BEGIN_QUOTE
  If the value of this variable is non-=nil=, case is not considered significant in completion. Within =read-file-name=, this variable is overridden by =read-file-name-completion-ignore-case= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Reading-File-Names][Reading File Names]]); within =read-buffer=, it is overridden by =read-buffer-completion-ignore-case= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#High_002dLevel-Completion][High-Level Completion]]).
#+END_QUOTE

--- Variable: *completion-regexp-list*

#+BEGIN_QUOTE
  This is a list of regular expressions. The completion functions only consider a completion acceptable if it matches all regular expressions in this list, with =case-fold-search= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Searching-and-Case][Searching and Case]]) bound to the value of =completion-ignore-case=.
#+END_QUOTE

--- Macro: *lazy-completion-table* var fun

#+BEGIN_QUOTE
  This macro provides a way to initialize the variable var as a collection for completion in a lazy way, not computing its actual contents until they are first needed. You use this macro to produce a value that you store in var. The actual computation of the proper value is done the first time you do completion using var. It is done by calling fun with no arguments. The value fun returns becomes the permanent value of var.

  Here is an example:

  #+BEGIN_EXAMPLE
                (defvar foo (lazy-completion-table foo make-my-alist))
  #+END_EXAMPLE
#+END_QUOTE

There are several functions that take an existing completion table and return a modified version. =completion-table-case-fold= returns a case-insensitive table. =completion-table-in-turn= and =completion-table-merge= combine multiple input tables in different ways. =completion-table-subvert= alters a table to use a different initial prefix. =completion-table-with-quoting= returns a table suitable for operating on quoted text. =completion-table-with-predicate= filters a table with a predicate function. =completion-table-with-terminator= adds a terminating string.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Commands][Completion Commands]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]

** 20.6.2 Completion and the Minibuffer
     :PROPERTIES:
     :CUSTOM_ID: completion-and-the-minibuffer
     :END:

This section describes the basic interface for reading from the minibuffer with completion.

--- Function: *completing-read* prompt collection &optional predicate require-match initial history default inherit-input-method

#+BEGIN_QUOTE
  This function reads a string in the minibuffer, assisting the user by providing completion. It activates the minibuffer with prompt prompt, which must be a string.

  The actual completion is done by passing the completion table collection and the completion predicate predicate to the function =try-completion= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]). This happens in certain commands bound in the local keymaps used for completion. Some of these commands also call =test-completion=. Thus, if predicate is non-=nil=, it should be compatible with collection and =completion-ignore-case=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Definition-of-test_002dcompletion][Definition of test-completion]].

  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programmed-Completion][Programmed Completion]], for detailed requirements when collection is a function.

  The value of the optional argument require-match determines how the user may exit the minibuffer:

  - If =nil=, the usual minibuffer exit commands work regardless of the input in the minibuffer.\\
  - If =t=, the usual minibuffer exit commands won't exit unless the input completes to an element of collection.\\
  - If =confirm=, the user can exit with any input, but is asked for confirmation if the input is not an element of collection.\\
  - If =confirm-after-completion=, the user can exit with any input, but is asked for confirmation if the preceding command was a completion command (i.e., one of the commands in =minibuffer-confirm-exit-commands=) and the resulting input is not an element of collection. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Commands][Completion Commands]].\\
  - Any other value of require-match behaves like =t=, except that the exit commands won't exit if it performs completion.

  However, empty input is always permitted, regardless of the value of require-match; in that case, =completing-read= returns the first element of default, if it is a list; =""=, if default is =nil=; or default. The string or strings in default are also available to the user through the history commands.

  The function =completing-read= uses =minibuffer-local-completion-map= as the keymap if require-match is =nil=, and uses =minibuffer-local-must-match-map= if require-match is non-=nil=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Commands][Completion Commands]].

  The argument history specifies which history list variable to use for saving the input and for minibuffer history commands. It defaults to =minibuffer-history=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-History][Minibuffer History]].

  The argument initial is mostly deprecated; we recommend using a non-=nil= value only in conjunction with specifying a cons cell for history. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Initial-Input][Initial Input]]. For default input, use default instead.

  If the argument inherit-input-method is non-=nil=, then the minibuffer inherits the current input method (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Methods][Input Methods]]) and the setting of =enable-multibyte-characters= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Representations][Text Representations]]) from whichever buffer was current before entering the minibuffer.

  If the variable =completion-ignore-case= is non-=nil=, completion ignores case when comparing the input against the possible matches. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]. In this mode of operation, predicate must also ignore case, or you will get surprising results.

  Here's an example of using =completing-read=:

  #+BEGIN_EXAMPLE
                (completing-read
                 "Complete a foo: "
                 '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
                 nil t "fo")

                ;; After evaluation of the preceding expression,
                ;;   the following appears in the minibuffer:

                ---------- Buffer: Minibuffer ----------
                Complete a foo: fo-!-
                ---------- Buffer: Minibuffer ----------
  #+END_EXAMPLE

  If the user then types b , =completing-read= returns =barfoo=.

  The =completing-read= function binds variables to pass information to the commands that actually do completion. They are described in the following section.
#+END_QUOTE

--- Variable: *completing-read-function*

#+BEGIN_QUOTE
  The value of this variable must be a function, which is called by =completing-read= to actually do its work. It should accept the same arguments as =completing-read=. This can be bound to a different function to completely override the normal behavior of =completing-read=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#High_002dLevel-Completion][High-Level Completion]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Completion][Minibuffer Completion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]

** 20.6.3 Minibuffer Commands that Do Completion
     :PROPERTIES:
     :CUSTOM_ID: minibuffer-commands-that-do-completion
     :END:

This section describes the keymaps, commands and user options used in the minibuffer to do completion.

--- Variable: *minibuffer-completion-table*

#+BEGIN_QUOTE
  The value of this variable is the completion table (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]) used for completion in the minibuffer. This is the global variable that contains what =completing-read= passes to =try-completion=. It is used by minibuffer completion commands such as =minibuffer-complete-word=.
#+END_QUOTE

--- Variable: *minibuffer-completion-predicate*

#+BEGIN_QUOTE
  This variable's value is the predicate that =completing-read= passes to =try-completion=. The variable is also used by the other minibuffer completion functions.
#+END_QUOTE

--- Variable: *minibuffer-completion-confirm*

#+BEGIN_QUOTE
  This variable determines whether Emacs asks for confirmation before exiting the minibuffer; =completing-read= binds this variable, and the function =minibuffer-complete-and-exit= checks the value before exiting. If the value is =nil=, confirmation is not required. If the value is =confirm=, the user may exit with an input that is not a valid completion alternative, but Emacs asks for confirmation. If the value is =confirm-after-completion=, the user may exit with an input that is not a valid completion alternative, but Emacs asks for confirmation if the user submitted the input right after any of the completion commands in =minibuffer-confirm-exit-commands=.
#+END_QUOTE

--- Variable: *minibuffer-confirm-exit-commands*

#+BEGIN_QUOTE
  This variable holds a list of commands that cause Emacs to ask for confirmation before exiting the minibuffer, if the require-match argument to =completing-read= is =confirm-after-completion=. The confirmation is requested if the user attempts to exit the minibuffer immediately after calling any command in this list.
#+END_QUOTE

--- Command: *minibuffer-complete-word*

#+BEGIN_QUOTE
  This function completes the minibuffer contents by at most a single word. Even if the minibuffer contents have only one completion, =minibuffer-complete-word= does not add any characters beyond the first character that is not a word constituent. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Tables][Syntax Tables]].
#+END_QUOTE

--- Command: *minibuffer-complete*

#+BEGIN_QUOTE
  This function completes the minibuffer contents as far as possible.
#+END_QUOTE

--- Command: *minibuffer-complete-and-exit*

#+BEGIN_QUOTE
  This function completes the minibuffer contents, and exits if confirmation is not required, i.e., if =minibuffer-completion-confirm= is =nil=. If confirmation /is/ required, it is given by repeating this command immediately---the command is programmed to work without confirmation when run twice in succession.
#+END_QUOTE

--- Command: *minibuffer-completion-help*

#+BEGIN_QUOTE
  This function creates a list of the possible completions of the current minibuffer contents. It works by calling =all-completions= using the value of the variable =minibuffer-completion-table= as the collection argument, and the value of =minibuffer-completion-predicate= as the predicate argument. The list of completions is displayed as text in a buffer named /Completions/.
#+END_QUOTE

--- Function: *display-completion-list* completions

#+BEGIN_QUOTE
  This function displays completions to the stream in =standard-output=, usually a buffer. (See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-and-Print][Read and Print]], for more information about streams.) The argument completions is normally a list of completions just returned by =all-completions=, but it does not have to be. Each element may be a symbol or a string, either of which is simply printed. It can also be a list of two strings, which is printed as if the strings were concatenated. The first of the two strings is the actual completion, the second string serves as annotation.

  This function is called by =minibuffer-completion-help=. A common way to use it is together with =with-output-to-temp-buffer=, like this:

  #+BEGIN_EXAMPLE
                (with-output-to-temp-buffer "*Completions*"
                  (display-completion-list
                    (all-completions (buffer-string) my-alist)))
  #+END_EXAMPLE
#+END_QUOTE

--- User Option: *completion-auto-help*

#+BEGIN_QUOTE
  If this variable is non-=nil=, the completion commands automatically display a list of possible completions whenever nothing can be completed because the next character is not uniquely determined.
#+END_QUOTE

--- Variable: *minibuffer-local-completion-map*

#+BEGIN_QUOTE
  =completing-read= uses this value as the local keymap when an exact match of one of the completions is not required. By default, this keymap makes the following bindings:

  - ?

    =minibuffer-completion-help=

  -

    =minibuffer-complete-word=

  -

    =minibuffer-complete=

  and uses =minibuffer-local-map= as its parent keymap (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Definition-of-minibuffer_002dlocal_002dmap][Definition of minibuffer-local-map]]).
#+END_QUOTE

--- Variable: *minibuffer-local-must-match-map*

#+BEGIN_QUOTE
  =completing-read= uses this value as the local keymap when an exact match of one of the completions is required. Therefore, no keys are bound to =exit-minibuffer=, the command that exits the minibuffer unconditionally. By default, this keymap makes the following bindings:

  - C-j

    =minibuffer-complete-and-exit=

  -

    =minibuffer-complete-and-exit=

  and uses =minibuffer-local-completion-map= as its parent keymap.
#+END_QUOTE

--- Variable: *minibuffer-local-filename-completion-map*

#+BEGIN_QUOTE
  This is a sparse keymap that simply unbinds ; because filenames can contain spaces. The function =read-file-name= combines this keymap with either =minibuffer-local-completion-map= or =minibuffer-local-must-match-map=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Reading-File-Names][Reading File Names]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Commands][Completion Commands]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]

** 20.6.4 High-Level Completion Functions
     :PROPERTIES:
     :CUSTOM_ID: high-level-completion-functions
     :END:

This section describes the higher-level convenience functions for reading certain sorts of names with completion.

In most cases, you should not call these functions in the middle of a Lisp function. When possible, do all minibuffer input as part of reading the arguments for a command, in the =interactive= specification. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Defining-Commands][Defining Commands]].

--- Function: *read-buffer* prompt &optional default require-match predicate

#+BEGIN_QUOTE
  This function reads the name of a buffer and returns it as a string. It prompts with prompt. The argument default is the default name to use, the value to return if the user exits with an empty minibuffer. If non-=nil=, it should be a string, a list of strings, or a buffer. If it is a list, the default value is the first element of this list. It is mentioned in the prompt, but is not inserted in the minibuffer as initial input.

  The argument prompt should be a string ending with a colon and a space. If default is non-=nil=, the function inserts it in prompt before the colon to follow the convention for reading from the minibuffer with a default value (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Tips][Programming Tips]]).

  The optional argument require-match has the same meaning as in =completing-read=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Completion][Minibuffer Completion]].

  The optional argument predicate, if non-=nil=, specifies a function to filter the buffers that should be considered: the function will be called with every potential candidate as its argument, and should return =nil= to reject the candidate, non-=nil= to accept it.

  In the following example, the user enters 'minibuffer.t', and then types . The argument require-match is =t=, and the only buffer name starting with the given input is 'minibuffer.texi', so that name is the value.

  #+BEGIN_EXAMPLE
                (read-buffer "Buffer name: " "foo" t)
                ;; After evaluation of the preceding expression,
                ;;   the following prompt appears,
                ;;   with an empty minibuffer:

                ---------- Buffer: Minibuffer ----------
                Buffer name (default foo): -!-
                ---------- Buffer: Minibuffer ----------

                ;; The user types minibuffer.t <RET>.
                     ⇒ "minibuffer.texi"
  #+END_EXAMPLE
#+END_QUOTE

--- User Option: *read-buffer-function*

#+BEGIN_QUOTE
  This variable, if non-=nil=, specifies a function for reading buffer names. =read-buffer= calls this function instead of doing its usual work, with the same arguments passed to =read-buffer=.
#+END_QUOTE

--- User Option: *read-buffer-completion-ignore-case*

#+BEGIN_QUOTE
  If this variable is non-=nil=, =read-buffer= ignores case when performing completion while reading the buffer name.
#+END_QUOTE

--- Function: *read-command* prompt &optional default

#+BEGIN_QUOTE
  This function reads the name of a command and returns it as a Lisp symbol. The argument prompt is used as in =read-from-minibuffer=. Recall that a command is anything for which =commandp= returns =t=, and a command name is a symbol for which =commandp= returns =t=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Interactive-Call][Interactive Call]].

  The argument default specifies what to return if the user enters null input. It can be a symbol, a string or a list of strings. If it is a string, =read-command= interns it before returning it. If it is a list, =read-command= interns the first element of this list. If default is =nil=, that means no default has been specified; then if the user enters null input, the return value is =(intern "")=, that is, a symbol whose name is an empty string, and whose printed representation is =##= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Symbol-Type][Symbol Type]]).

  #+BEGIN_EXAMPLE
                (read-command "Command name? ")

                ;; After evaluation of the preceding expression,
                ;;   the following prompt appears with an empty minibuffer:

                ---------- Buffer: Minibuffer ----------
                Command name?
                ---------- Buffer: Minibuffer ----------
  #+END_EXAMPLE

  If the user types forward-c , then this function returns =forward-char=.

  The =read-command= function is a simplified interface to =completing-read=. It uses the variable =obarray= so as to complete in the set of extant Lisp symbols, and it uses the =commandp= predicate so as to accept only command names:

  ​

  #+BEGIN_EXAMPLE
                (read-command prompt)
                ==
                (intern (completing-read prompt obarray
                                         'commandp t nil))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *read-variable* prompt &optional default

#+BEGIN_QUOTE
  This function reads the name of a customizable variable and returns it as a symbol. Its arguments have the same form as those of =read-command=. It behaves just like =read-command=, except that it uses the predicate =custom-variable-p= instead of =commandp=.
#+END_QUOTE

--- Command: *read-color* &optional prompt convert allow-empty display

#+BEGIN_QUOTE
  This function reads a string that is a color specification, either the color's name or an RGB hex value such as =#RRRGGGBBB=. It prompts with prompt (default: ="Color (name or #RGB triplet):"=) and provides completion for color names, but not for hex RGB values. In addition to names of standard colors, completion candidates include the foreground and background colors at point.

  Valid RGB values are described in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Color-Names][Color Names]].

  The function's return value is the string typed by the user in the minibuffer. However, when called interactively or if the optional argument convert is non-=nil=, it converts any input color name into the corresponding RGB value string and instead returns that. This function requires a valid color specification to be input. Empty color names are allowed when allow-empty is non-=nil= and the user enters null input.

  Interactively, or when display is non-=nil=, the return value is also displayed in the echo area.
#+END_QUOTE

See also the functions =read-coding-system= and =read-non-nil-coding-system=, in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#User_002dChosen-Coding-Systems][User-Chosen Coding Systems]], and =read-input-method-name=, in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Methods][Input Methods]].

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Variables][Completion Variables]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#High_002dLevel-Completion][High-Level Completion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]

** 20.6.5 Reading File Names
     :PROPERTIES:
     :CUSTOM_ID: reading-file-names
     :END:

The high-level completion functions =read-file-name=, =read-directory-name=, and =read-shell-command= are designed to read file names, directory names, and shell commands, respectively. They provide special features, including automatic insertion of the default directory.

--- Function: *read-file-name* prompt &optional directory default require-match initial predicate

#+BEGIN_QUOTE
  This function reads a file name, prompting with prompt and providing completion.

  As an exception, this function reads a file name using a graphical file dialog instead of the minibuffer, if all of the following are true:

  1. It is invoked via a mouse command.\\
  2. The selected frame is on a graphical display supporting such dialogs.\\
  3. The variable =use-dialog-box= is non-=nil=. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Dialog-Boxes][Dialog Boxes]].\\
  4. The directory argument, described below, does not specify a remote file. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Remote-Files][Remote Files]].

  The exact behavior when using a graphical file dialog is platform-dependent. Here, we simply document the behavior when using the minibuffer.

  =read-file-name= does not automatically expand the returned file name. You can call =expand-file-name= yourself if an absolute file name is required.

  The optional argument require-match has the same meaning as in =completing-read=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Completion][Minibuffer Completion]].

  The argument directory specifies the directory to use for completing relative file names. It should be an absolute directory name. If the variable =insert-default-directory= is non-=nil=, directory is also inserted in the minibuffer as initial input. It defaults to the current buffer's value of =default-directory=.

  If you specify initial, that is an initial file name to insert in the buffer (after directory, if that is inserted). In this case, point goes at the beginning of initial. The default for initial is =nil=---don't insert any file name. To see what initial does, try the command C-x C-v in a buffer visiting a file. *Please note:* we recommend using default rather than initial in most cases.

  If default is non-=nil=, then the function returns default if the user exits the minibuffer with the same non-empty contents that =read-file-name= inserted initially. The initial minibuffer contents are always non-empty if =insert-default-directory= is non-=nil=, as it is by default. default is not checked for validity, regardless of the value of require-match. However, if require-match is non-=nil=, the initial minibuffer contents should be a valid file (or directory) name. Otherwise =read-file-name= attempts completion if the user exits without any editing, and does not return default. default is also available through the history commands.

  If default is =nil=, =read-file-name= tries to find a substitute default to use in its place, which it treats in exactly the same way as if it had been specified explicitly. If default is =nil=, but initial is non-=nil=, then the default is the absolute file name obtained from directory and initial. If both default and initial are =nil= and the buffer is visiting a file, =read-file-name= uses the absolute file name of that file as default. If the buffer is not visiting a file, then there is no default. In that case, if the user types without any editing, =read-file-name= simply returns the pre-inserted contents of the minibuffer.

  If the user types in an empty minibuffer, this function returns an empty string, regardless of the value of require-match. This is, for instance, how the user can make the current buffer visit no file using M-x set-visited-file-name.

  If predicate is non-=nil=, it specifies a function of one argument that decides which file names are acceptable completion alternatives. A file name is an acceptable value if predicate returns non-=nil= for it.

  Here is an example of using =read-file-name=:

  #+BEGIN_EXAMPLE
                (read-file-name "The file is ")

                ;; After evaluation of the preceding expression,
                ;;   the following appears in the minibuffer:

                ---------- Buffer: Minibuffer ----------
                The file is /gp/gnu/elisp/-!-
                ---------- Buffer: Minibuffer ----------
  #+END_EXAMPLE

  Typing manual results in the following:

  #+BEGIN_EXAMPLE
                ---------- Buffer: Minibuffer ----------
                The file is /gp/gnu/elisp/manual.texi-!-
                ---------- Buffer: Minibuffer ----------
  #+END_EXAMPLE

  If the user types , =read-file-name= returns the file name as the string ="/gp/gnu/elisp/manual.texi"=.
#+END_QUOTE

--- Variable: *read-file-name-function*

#+BEGIN_QUOTE
  If non-=nil=, this should be a function that accepts the same arguments as =read-file-name=. When =read-file-name= is called, it calls this function with the supplied arguments instead of doing its usual work.
#+END_QUOTE

--- User Option: *read-file-name-completion-ignore-case*

#+BEGIN_QUOTE
  If this variable is non-=nil=, =read-file-name= ignores case when performing completion.
#+END_QUOTE

--- Function: *read-directory-name* prompt &optional directory default require-match initial

#+BEGIN_QUOTE
  This function is like =read-file-name= but allows only directory names as completion alternatives.

  If default is =nil= and initial is non-=nil=, =read-directory-name= constructs a substitute default by combining directory (or the current buffer's default directory if directory is =nil=) and initial. If both default and initial are =nil=, this function uses directory as substitute default, or the current buffer's default directory if directory is =nil=.
#+END_QUOTE

--- User Option: *insert-default-directory*

#+BEGIN_QUOTE
  This variable is used by =read-file-name=, and thus, indirectly, by most commands reading file names. (This includes all commands that use the code letters 'f' or 'F' in their interactive form. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Interactive-Codes][Code Characters for interactive]].) Its value controls whether =read-file-name= starts by placing the name of the default directory in the minibuffer, plus the initial file name, if any. If the value of this variable is =nil=, then =read-file-name= does not place any initial input in the minibuffer (unless you specify initial input with the initial argument). In that case, the default directory is still used for completion of relative file names, but is not displayed.

  If this variable is =nil= and the initial minibuffer contents are empty, the user may have to explicitly fetch the next history element to access a default value. If the variable is non-=nil=, the initial minibuffer contents are always non-empty and the user can always request a default value by immediately typing in an unedited minibuffer. (See above.)

  For example:

  #+BEGIN_EXAMPLE
                ;; Here the minibuffer starts out with the default directory.
                (let ((insert-default-directory t))
                  (read-file-name "The file is "))

                ---------- Buffer: Minibuffer ----------
                The file is ~lewis/manual/-!-
                ---------- Buffer: Minibuffer ----------

                ;; Here the minibuffer is empty and only the prompt
                ;;   appears on its line.
                (let ((insert-default-directory nil))
                  (read-file-name "The file is "))

                ---------- Buffer: Minibuffer ----------
                The file is -!-
                ---------- Buffer: Minibuffer ----------
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *read-shell-command* prompt &optional initial history &rest args

#+BEGIN_QUOTE
  This function reads a shell command from the minibuffer, prompting with prompt and providing intelligent completion. It completes the first word of the command using candidates that are appropriate for command names, and the rest of the command words as file names.

  This function uses =minibuffer-local-shell-command-map= as the keymap for minibuffer input. The history argument specifies the history list to use; if is omitted or =nil=, it defaults to =shell-command-history= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-History][shell-command-history]]). The optional argument initial specifies the initial content of the minibuffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Initial-Input][Initial Input]]). The rest of args, if present, are used as the default and inherit-input-method arguments in =read-from-minibuffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-from-Minibuffer][Text from Minibuffer]]).
#+END_QUOTE

--- Variable: *minibuffer-local-shell-command-map*

#+BEGIN_QUOTE
  This keymap is used by =read-shell-command= for completing command and file names that are part of a shell command. It uses =minibuffer-local-map= as its parent keymap, and binds to =completion-at-point=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programmed-Completion][Programmed Completion]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Reading-File-Names][Reading File Names]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]

** 20.6.6 Completion Variables
     :PROPERTIES:
     :CUSTOM_ID: completion-variables
     :END:

Here are some variables that can be used to alter the default completion behavior.

--- User Option: *completion-styles*

#+BEGIN_QUOTE
  The value of this variable is a list of completion style (symbols) to use for performing completion. A completion style is a set of rules for generating completions. Each symbol occurring this list must have a corresponding entry in =completion-styles-alist=.
#+END_QUOTE

--- Variable: *completion-styles-alist*

#+BEGIN_QUOTE
  This variable stores a list of available completion styles. Each element in the list has the form

  #+BEGIN_EXAMPLE
                (style try-completion all-completions doc)
  #+END_EXAMPLE

  Here, style is the name of the completion style (a symbol), which may be used in the =completion-styles= variable to refer to this style; try-completion is the function that does the completion; all-completions is the function that lists the completions; and doc is a string describing the completion style.

  The try-completion and all-completions functions should each accept four arguments: string, collection, predicate, and point. The string, collection, and predicate arguments have the same meanings as in =try-completion= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]), and the point argument is the position of point within string. Each function should return a non-=nil= value if it performed its job, and =nil= if it did not (e.g., if there is no way to complete string according to the completion style).

  When the user calls a completion command like =minibuffer-complete= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Commands][Completion Commands]]), Emacs looks for the first style listed in =completion-styles= and calls its try-completion function. If this function returns =nil=, Emacs moves to the next listed completion style and calls its try-completion function, and so on until one of the try-completion functions successfully performs completion and returns a non-=nil= value. A similar procedure is used for listing completions, via the all-completions functions.

  See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Completion-Styles][Completion Styles]], for a description of the available completion styles.
#+END_QUOTE

--- User Option: *completion-category-overrides*

#+BEGIN_QUOTE
  This variable specifies special completion styles and other completion behaviors to use when completing certain types of text. Its value should be an alist with elements of the form =(=category=.=alist=)=. category is a symbol describing what is being completed; currently, the =buffer=, =file=, and =unicode-name= categories are defined, but others can be defined via specialized completion functions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programmed-Completion][Programmed Completion]]). alist is an association list describing how completion should behave for the corresponding category. The following alist keys are supported:

  - =styles=

    The value should be a list of completion styles (symbols).

  - =cycle=

    The value should be a value for =completion-cycle-threshold= (see [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Completion-Options][Completion Options]]) for this category.

  Additional alist entries may be defined in the future.
#+END_QUOTE

--- Variable: *completion-extra-properties*

#+BEGIN_QUOTE
  This variable is used to specify extra properties of the current completion command. It is intended to be let-bound by specialized completion commands. Its value should be a list of property and value pairs. The following properties are supported:

  - =:annotation-function=

    The value should be a function to add annotations in the completions buffer. This function must accept one argument, a completion, and should either return =nil= or a string to be displayed next to the completion.

  - =:exit-function=

    The value should be a function to run after performing completion. The function should accept two arguments, string and status, where string is the text to which the field was completed, and status indicates what kind of operation happened: =finished= if text is now complete, =sole= if the text cannot be further completed but completion is not finished, or =exact= if the text is a valid completion but may be further completed.

#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-in-Buffers][Completion in Buffers]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Variables][Completion Variables]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]

** 20.6.7 Programmed Completion
     :PROPERTIES:
     :CUSTOM_ID: programmed-completion
     :END:

Sometimes it is not possible or convenient to create an alist or an obarray containing all the intended possible completions ahead of time. In such a case, you can supply your own function to compute the completion of a given string. This is called programmed completion. Emacs uses programmed completion when completing file names (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#File-Name-Completion][File Name Completion]]), among many other cases.

To use this feature, pass a function as the collection argument to =completing-read=. The function =completing-read= arranges to pass your completion function along to =try-completion=, =all-completions=, and other basic completion functions, which will then let your function do all the work.

The completion function should accept three arguments:

- The string to be completed.

- A predicate function with which to filter possible matches, or =nil= if none. The function should call the predicate for each possible match, and ignore the match if the predicate returns =nil=.

- A flag specifying the type of completion operation to perform; see

  Basic Completion

  , for the details of those operations. This flag may be one of the following values.

  - =nil=

    This specifies a =try-completion= operation. The function should return =nil= if there are no matches; it should return =t= if the specified string is a unique and exact match; and it should return the longest common prefix substring of all matches otherwise.

  - =t=

    This specifies an =all-completions= operation. The function should return a list of all possible completions of the specified string.

  - =lambda=

    This specifies a =test-completion= operation. The function should return =t= if the specified string is an exact match for some completion alternative; =nil= otherwise.

  - =(boundaries .=suffix=)=

    This specifies a =completion-boundaries= operation. The function should return =(boundaries=start=.=end=)=, where start is the position of the beginning boundary in the specified string, and end is the position of the end boundary in suffix.

  - =metadata=

    This specifies a request for information about the state of the current completion. The return value should have the form =(metadata .=alist=)=, where alist is an alist whose elements are described below.

  If the flag has any other value, the completion function should return =nil=.

The following is a list of metadata entries that a completion function may return in response to a =metadata= flag argument:

- =category=

  The value should be a symbol describing what kind of text the completion function is trying to complete. If the symbol matches one of the keys in =completion-category-overrides=, the usual completion behavior is overridden. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Variables][Completion Variables]].

- =annotation-function=

  The value should be a function for annotating completions. The function should take one argument, string, which is a possible completion. It should return a string, which is displayed after the completion string in the /Completions/ buffer.

- =display-sort-function=

  The value should be a function for sorting completions. The function should take one argument, a list of completion strings, and return a sorted list of completion strings. It is allowed to alter the input list destructively.

- =cycle-sort-function=

  The value should be a function for sorting completions, when =completion-cycle-threshold= is non-=nil= and the user is cycling through completion alternatives. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Completion-Options][Completion Options]]. Its argument list and return value are the same as for =display-sort-function=.

--- Function: *completion-table-dynamic* function &optional switch-buffer

#+BEGIN_QUOTE
  This function is a convenient way to write a function that can act as a programmed completion function. The argument function should be a function that takes one argument, a string, and returns a completion table (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]) containing all the possible completions. The table returned by function can also include elements that don't match the string argument; they are automatically filtered out by =completion-table-dynamic=. In particular, function can ignore its argument and return a full list of all possible completions. You can think of =completion-table-dynamic= as a transducer between function and the interface for programmed completion functions.

  If the optional argument switch-buffer is non-=nil=, and completion is performed in the minibuffer, function will be called with current buffer set to the buffer from which the minibuffer was entered.

  The return value of =completion-table-dynamic= is a function that can be used as the 2nd argument to =try-completion= and =all-completions=. Note that this function will always return empty metadata and trivial boundaries (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programmed-Completion][Programmed Completion]]).
#+END_QUOTE

--- Function: *completion-table-with-cache* function &optional ignore-case

#+BEGIN_QUOTE
  This is a wrapper for =completion-table-dynamic= that saves the last argument-result pair. This means that multiple lookups with the same argument only need to call function once. This can be useful when a slow operation is involved, such as calling an external process.
#+END_QUOTE

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programmed-Completion][Programmed Completion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]]

** 20.6.8 Completion in Ordinary Buffers
     :PROPERTIES:
     :CUSTOM_ID: completion-in-ordinary-buffers
     :END:

Although completion is usually done in the minibuffer, the completion facility can also be used on the text in ordinary Emacs buffers. In many major modes, in-buffer completion is performed by the C-M-i or M- command, bound to =completion-at-point=. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Symbol-Completion][Symbol Completion]]. This command uses the abnormal hook variable =completion-at-point-functions=:

--- Variable: *completion-at-point-functions*

#+BEGIN_QUOTE
  The value of this abnormal hook should be a list of functions, which are used to compute a completion table (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]) for completing the text at point. It can be used by major modes to provide mode-specific completion tables (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Major-Mode-Conventions][Major Mode Conventions]]).

  When the command =completion-at-point= runs, it calls the functions in the list one by one, without any argument. Each function should return =nil= unless it can and wants to take responsibility for the completion data for the text at point. Otherwise it should return a list of the following form:

  #+BEGIN_EXAMPLE
                (start end collection . props)
  #+END_EXAMPLE

  start and end delimit the text to complete (which should enclose point). collection is a completion table for completing that text, in a form suitable for passing as the second argument to =try-completion= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]); completion alternatives will be generated from this completion table in the usual way, via the completion styles defined in =completion-styles= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Variables][Completion Variables]]). props is a property list for additional information; any of the properties in =completion-extra-properties= are recognized (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion-Variables][Completion Variables]]), as well as the following additional ones:

  - =:predicate=

    The value should be a predicate that completion candidates need to satisfy.

  - =:exclusive=

    If the value is =no=, then if the completion table fails to match the text at point, =completion-at-point= moves on to the next function in =completion-at-point-functions= instead of reporting a completion failure.

  The functions on this hook should generally return quickly, since they may be called very often (e.g., from =post-command-hook=). Supplying a function for collection is strongly recommended if generating the list of completions is an expensive operation. Emacs may internally call functions in =completion-at-point-functions= many times, but care about the value of collection for only some of these calls. By supplying a function for collection, Emacs can defer generating completions until necessary. You can use =completion-table-dynamic= to create a wrapper function:

  #+BEGIN_EXAMPLE
                ;; Avoid this pattern.
                (let ((beg ...) (end ...) (my-completions (my-make-completions)))
                  (list beg end my-completions))

                ;; Use this instead.
                (let ((beg ...) (end ...))
                  (list beg
                        end
                        (completion-table-dynamic
                          (lambda (_)
                            (my-make-completions)))))
  #+END_EXAMPLE

  Additionally, the collection should generally not be pre-filtered based on the current text between start and end, because that is the responsibility of the caller of =completion-at-point-functions= to do that according to the completion styles it decides to use.

  A function in =completion-at-point-functions= may also return a function instead of a list as described above. In that case, that returned function is called, with no argument, and it is entirely responsible for performing the completion. We discourage this usage; it is only intended to help convert old code to using =completion-at-point=.

  The first function in =completion-at-point-functions= to return a non-=nil= value is used by =completion-at-point=. The remaining functions are not called. The exception to this is when there is an =:exclusive= specification, as described above.
#+END_QUOTE

The following function provides a convenient way to perform completion on an arbitrary stretch of text in an Emacs buffer:

--- Function: *completion-in-region* start end collection &optional predicate

#+BEGIN_QUOTE
  This function completes the text in the current buffer between the positions start and end, using collection. The argument collection has the same meaning as in =try-completion= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Completion][Basic Completion]]).

  This function inserts the completion text directly into the current buffer. Unlike =completing-read= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Completion][Minibuffer Completion]]), it does not activate the minibuffer.

  For this function to work, point must be somewhere between start and end.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Multiple-Queries][Multiple Queries]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Completion][Completion]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.7 Yes-or-No Queries
    :PROPERTIES:
    :CUSTOM_ID: yes-or-no-queries
    :END:

This section describes functions used to ask the user a yes-or-no question. The function =y-or-n-p= can be answered with a single character; it is useful for questions where an inadvertent wrong answer will not have serious consequences. =yes-or-no-p= is suitable for more momentous questions, since it requires three or four characters to answer.

If either of these functions is called in a command that was invoked using the mouse---more precisely, if =last-nonmenu-event= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Command-Loop-Info][Command Loop Info]]) is either =nil= or a list---then it uses a dialog box or pop-up menu to ask the question. Otherwise, it uses keyboard input. You can force use either of the mouse or of keyboard input by binding =last-nonmenu-event= to a suitable value around the call.

Strictly speaking, =yes-or-no-p= uses the minibuffer and =y-or-n-p= does not; but it seems best to describe them together.

--- Function: *y-or-n-p* prompt

#+BEGIN_QUOTE
  This function asks the user a question, expecting input in the echo area. It returns =t= if the user types y, =nil= if the user types n. This function also accepts to mean yes and to mean no. It accepts C-] to quit, like C-g, because the question might look like a minibuffer and for that reason the user might try to use C-] to get out. The answer is a single character, with no needed to terminate it. Upper and lower case are equivalent.

  "Asking the question" means printing prompt in the echo area, followed by the string '(y or n)'. If the input is not one of the expected answers (y, n, , , or something that quits), the function responds 'Please answer y or n.', and repeats the request.

  This function does not actually use the minibuffer, since it does not allow editing of the answer. It actually uses the echo area (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Echo-Area][The Echo Area]]), which uses the same screen space as the minibuffer. The cursor moves to the echo area while the question is being asked.

  The answers and their meanings, even 'y' and 'n', are not hardwired, and are specified by the keymap =query-replace-map= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Search-and-Replace][Search and Replace]]). In particular, if the user enters the special responses =recenter=, =scroll-up=, =scroll-down=, =scroll-other-window=, or =scroll-other-window-down= (respectively bound to C-l, C-v, M-v, C-M-v and C-M-S-v in =query-replace-map=), this function performs the specified window recentering or scrolling operation, and poses the question again.

  We show successive lines of echo area messages, but only one actually appears on the screen at a time.
#+END_QUOTE

--- Function: *y-or-n-p-with-timeout* prompt seconds default

#+BEGIN_QUOTE
  Like =y-or-n-p=, except that if the user fails to answer within seconds seconds, this function stops waiting and returns default. It works by setting up a timer; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Timers][Timers]]. The argument seconds should be a number.
#+END_QUOTE

--- Function: *yes-or-no-p* prompt

#+BEGIN_QUOTE
  This function asks the user a question, expecting input in the minibuffer. It returns =t= if the user enters 'yes', =nil= if the user types 'no'. The user must type to finalize the response. Upper and lower case are equivalent.

  =yes-or-no-p= starts by displaying prompt in the echo area, followed by '(yes or no)'. The user must type one of the expected responses; otherwise, the function responds 'Please answer yes or no.', waits about two seconds and repeats the request.

  =yes-or-no-p= requires more work from the user than =y-or-n-p= and is appropriate for more crucial decisions.

  Here is an example:

  #+BEGIN_EXAMPLE
                (yes-or-no-p "Do you really want to remove everything? ")

                ;; After evaluation of the preceding expression,
                ;;   the following prompt appears,
                ;;   with an empty minibuffer:

                ---------- Buffer: minibuffer ----------
                Do you really want to remove everything? (yes or no)
                ---------- Buffer: minibuffer ----------
  #+END_EXAMPLE

  If the user first types y , which is invalid because this function demands the entire word 'yes', it responds by displaying these prompts, with a brief pause between them:

  #+BEGIN_EXAMPLE
                ---------- Buffer: minibuffer ----------
                Please answer yes or no.
                Do you really want to remove everything? (yes or no)
                ---------- Buffer: minibuffer ----------
  #+END_EXAMPLE
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Reading-a-Password][Reading a Password]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Yes_002dor_002dNo-Queries][Yes-or-No Queries]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.8 Asking Multiple-Choice Questions
    :PROPERTIES:
    :CUSTOM_ID: asking-multiple-choice-questions
    :END:

This section describes facilities for asking the user more complex questions or several similar questions.

When you have a series of similar questions to ask, such as "Do you want to save this buffer?" for each buffer in turn, you should use =map-y-or-n-p= to ask the collection of questions, rather than asking each question individually. This gives the user certain convenient facilities such as the ability to answer the whole series at once.

--- Function: *map-y-or-n-p* prompter actor list &optional help action-alist no-cursor-in-echo-area

#+BEGIN_QUOTE
  This function asks the user a series of questions, reading a single-character answer in the echo area for each one.

  The value of list specifies the objects to ask questions about. It should be either a list of objects or a generator function. If it is a function, it should expect no arguments, and should return either the next object to ask about, or =nil=, meaning to stop asking questions.

  The argument prompter specifies how to ask each question. If prompter is a string, the question text is computed like this:

  #+BEGIN_EXAMPLE
                (format prompter object)
  #+END_EXAMPLE

  where object is the next object to ask about (as obtained from list).

  If not a string, prompter should be a function of one argument (the next object to ask about) and should return the question text. If the value is a string, that is the question to ask the user. The function can also return =t=, meaning do act on this object (and don't ask the user), or =nil=, meaning ignore this object (and don't ask the user).

  The argument actor says how to act on the answers that the user gives. It should be a function of one argument, and it is called with each object that the user says yes for. Its argument is always an object obtained from list.

  If the argument help is given, it should be a list of this form:

  #+BEGIN_EXAMPLE
                (singular plural action)
  #+END_EXAMPLE

  where singular is a string containing a singular noun that describes the objects conceptually being acted on, plural is the corresponding plural noun, and action is a transitive verb describing what actor does.

  If you don't specify help, the default is =("object" "objects" "act on")=.

  Each time a question is asked, the user may enter y, Y, or to act on that object; n, N, or to skip that object; ! to act on all following objects; or q to exit (skip all following objects); . (period) to act on the current object and then exit; or C-h to get help. These are the same answers that =query-replace= accepts. The keymap =query-replace-map= defines their meaning for =map-y-or-n-p= as well as for =query-replace=; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Search-and-Replace][Search and Replace]].

  You can use action-alist to specify additional possible answers and what they mean. It is an alist of elements of the form =(=char function help=)=, each of which defines one additional answer. In this element, char is a character (the answer); function is a function of one argument (an object from list); help is a string.

  When the user responds with char, =map-y-or-n-p= calls function. If it returns non-=nil=, the object is considered acted upon, and =map-y-or-n-p= advances to the next object in list. If it returns =nil=, the prompt is repeated for the same object.

  Normally, =map-y-or-n-p= binds =cursor-in-echo-area= while prompting. But if no-cursor-in-echo-area is non-=nil=, it does not do that.

  If =map-y-or-n-p= is called in a command that was invoked using the mouse---more precisely, if =last-nonmenu-event= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Command-Loop-Info][Command Loop Info]]) is either =nil= or a list---then it uses a dialog box or pop-up menu to ask the question. In this case, it does not use keyboard input or the echo area. You can force use either of the mouse or of keyboard input by binding =last-nonmenu-event= to a suitable value around the call.

  The return value of =map-y-or-n-p= is the number of objects acted on.
#+END_QUOTE

If you need to ask the user a question that might have more than just 2 answers, use =read-answer=.

--- Function: *read-answer* question answers

#+BEGIN_QUOTE
  This function prompts the user with text in question, which should end in the 'SPC' character. The function includes in the prompt the possible responses in answers by appending them to the end of question. The possible responses are provided in answers as an alist whose elements are of the following form:

  #+BEGIN_EXAMPLE
                (long-answer short-answer help-message)
  #+END_EXAMPLE

  where long-answer is the complete text of the user response, a string; short-answer is a short form of the same response, a single character; and help-message is the text that describes the meaning of the answer. If the variable =read-answer-short= is non-=nil=, the prompt will show the short variants of the possible answers and the user is expected to type the single characters shown in the prompt; otherwise the prompt will show the long variants of the answers, and the user is expected to type the full text of one of the answers and end by pressing . If =use-dialog-box= is non-=nil=, and this function was invoked by mouse events, the question and the answers will be displayed in a GUI dialog box.

  The function returns the text of the long-answer selected by the user, regardless of whether long or short answers were shown in the prompt and typed by the user.

  Here is an example of using this function:

  #+BEGIN_EXAMPLE
                (let ((read-answer-short t))
                  (read-answer "Foo "
                     '(("yes"  ?y "perform the action")
                       ("no"   ?n "skip to the next")
                       ("all"  ?! "perform for the rest without more questions")
                       ("help" ?h "show help")
                       ("quit" ?q "exit"))))
  #+END_EXAMPLE
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Commands][Minibuffer Commands]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Multiple-Queries][Multiple Queries]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.9 Reading a Password
    :PROPERTIES:
    :CUSTOM_ID: reading-a-password
    :END:

To read a password to pass to another program, you can use the function =read-passwd=.

--- Function: *read-passwd* prompt &optional confirm default

#+BEGIN_QUOTE
  This function reads a password, prompting with prompt. It does not echo the password as the user types it; instead, it echoes '.' for each character in the password. If you want to apply another character to hide the password, let-bind the variable =read-hide-char= with that character.

  The optional argument confirm, if non-=nil=, says to read the password twice and insist it must be the same both times. If it isn't the same, the user has to type it over and over until the last two times match.

  The optional argument default specifies the default password to return if the user enters empty input. If default is =nil=, then =read-passwd= returns the null string in that case.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Windows][Minibuffer Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Reading-a-Password][Reading a Password]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.10 Minibuffer Commands
    :PROPERTIES:
    :CUSTOM_ID: minibuffer-commands
    :END:

This section describes some commands meant for use in the minibuffer.

--- Command: *exit-minibuffer*

#+BEGIN_QUOTE
  This command exits the active minibuffer. It is normally bound to keys in minibuffer local keymaps.
#+END_QUOTE

--- Command: *self-insert-and-exit*

#+BEGIN_QUOTE
  This command exits the active minibuffer after inserting the last character typed on the keyboard (found in =last-command-event=; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Command-Loop-Info][Command Loop Info]]).
#+END_QUOTE

--- Command: *previous-history-element* n

#+BEGIN_QUOTE
  This command replaces the minibuffer contents with the value of the nth previous (older) history element.
#+END_QUOTE

--- Command: *next-history-element* n

#+BEGIN_QUOTE
  This command replaces the minibuffer contents with the value of the nth more recent history element.
#+END_QUOTE

--- Command: *previous-matching-history-element* pattern n

#+BEGIN_QUOTE
  This command replaces the minibuffer contents with the value of the nth previous (older) history element that matches pattern (a regular expression).
#+END_QUOTE

--- Command: *next-matching-history-element* pattern n

#+BEGIN_QUOTE
  This command replaces the minibuffer contents with the value of the nth next (newer) history element that matches pattern (a regular expression).
#+END_QUOTE

--- Command: *previous-complete-history-element* n

#+BEGIN_QUOTE
  This command replaces the minibuffer contents with the value of the nth previous (older) history element that completes the current contents of the minibuffer before the point.
#+END_QUOTE

--- Command: *next-complete-history-element* n

#+BEGIN_QUOTE
  This command replaces the minibuffer contents with the value of the nth next (newer) history element that completes the current contents of the minibuffer before the point.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Contents][Minibuffer Contents]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Commands][Minibuffer Commands]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.11 Minibuffer Windows
    :PROPERTIES:
    :CUSTOM_ID: minibuffer-windows
    :END:

These functions access and select minibuffer windows, test whether they are active and control how they get resized.

--- Function: *minibuffer-window* &optional frame

#+BEGIN_QUOTE
  This function returns the minibuffer window used for frame frame. If frame is =nil=, that stands for the selected frame.

  Note that the minibuffer window used by a frame need not be part of that frame---a frame that has no minibuffer of its own necessarily uses some other frame's minibuffer window. The minibuffer window of a minibuffer-less frame can be changed by setting that frame's =minibuffer= frame parameter (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Parameters][Buffer Parameters]]).
#+END_QUOTE

--- Function: *set-minibuffer-window* window

#+BEGIN_QUOTE
  This function specifies window as the minibuffer window to use. This affects where the minibuffer is displayed if you put text in it without invoking the usual minibuffer commands. It has no effect on the usual minibuffer input functions because they all start by choosing the minibuffer window according to the selected frame.
#+END_QUOTE

--- Function: *window-minibuffer-p* &optional window

#+BEGIN_QUOTE
  This function returns non-=nil= if window is a minibuffer window. window defaults to the selected window.
#+END_QUOTE

The following function returns the window showing the currently active minibuffer.

--- Function: *active-minibuffer-window*

#+BEGIN_QUOTE
  This function returns the window of the currently active minibuffer, or =nil= if there is no active minibuffer.
#+END_QUOTE

It is not sufficient to determine whether a given window shows the currently active minibuffer by comparing it with the result of =(minibuffer-window)=, because there can be more than one minibuffer window if there is more than one frame.

--- Function: *minibuffer-window-active-p* window

#+BEGIN_QUOTE
  This function returns non-=nil= if window shows the currently active minibuffer.
#+END_QUOTE

The following two options control whether minibuffer windows are resized automatically and how large they can get in the process.

--- User Option: *resize-mini-windows*

#+BEGIN_QUOTE
  This option specifies whether minibuffer windows are resized automatically. The default value is =grow-only=, which means that a minibuffer window by default expands automatically to accommodate the text it displays and shrinks back to one line as soon as the minibuffer gets empty. If the value is =t=, Emacs will always try to fit the height of a minibuffer window to the text it displays (with a minimum of one line). If the value is =nil=, a minibuffer window never changes size automatically. In that case the window resizing commands (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]]) can be used to adjust its height.
#+END_QUOTE

--- User Option: *max-mini-window-height*

#+BEGIN_QUOTE
  This option provides a maximum height for resizing minibuffer windows automatically. A floating-point number specifies a fraction of the frame's height; an integer specifies the maximum number of lines. The default value is 0.25.
#+END_QUOTE

Note that the values of the above two variables take effect at display time, so let-binding them around code which produces echo-area messages will not work. If you want to prevent resizing of minibuffer windows when displaying long messages, bind the =message-truncate-lines= variable instead (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Echo-Area-Customization][Echo Area Customization]]).

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recursive-Mini][Recursive Mini]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Windows][Minibuffer Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.12 Minibuffer Contents
    :PROPERTIES:
    :CUSTOM_ID: minibuffer-contents
    :END:

These functions access the minibuffer prompt and contents.

--- Function: *minibuffer-prompt*

#+BEGIN_QUOTE
  This function returns the prompt string of the currently active minibuffer. If no minibuffer is active, it returns =nil=.
#+END_QUOTE

--- Function: *minibuffer-prompt-end*

#+BEGIN_QUOTE
  This function returns the current position of the end of the minibuffer prompt, if a minibuffer is current. Otherwise, it returns the minimum valid buffer position.
#+END_QUOTE

--- Function: *minibuffer-prompt-width*

#+BEGIN_QUOTE
  This function returns the current display-width of the minibuffer prompt, if a minibuffer is current. Otherwise, it returns zero.
#+END_QUOTE

--- Function: *minibuffer-contents*

#+BEGIN_QUOTE
  This function returns the editable contents of the minibuffer (that is, everything except the prompt) as a string, if a minibuffer is current. Otherwise, it returns the entire contents of the current buffer.
#+END_QUOTE

--- Function: *minibuffer-contents-no-properties*

#+BEGIN_QUOTE
  This is like =minibuffer-contents=, except that it does not copy text properties, just the characters themselves. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]].
#+END_QUOTE

--- Command: *delete-minibuffer-contents*

#+BEGIN_QUOTE
  This command erases the editable contents of the minibuffer (that is, everything except the prompt), if a minibuffer is current. Otherwise, it erases the entire current buffer.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Misc][Minibuffer Misc]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Contents][Minibuffer Contents]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.13 Recursive Minibuffers
    :PROPERTIES:
    :CUSTOM_ID: recursive-minibuffers
    :END:

These functions and variables deal with recursive minibuffers (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recursive-Editing][Recursive Editing]]):

--- Function: *minibuffer-depth*

#+BEGIN_QUOTE
  This function returns the current depth of activations of the minibuffer, a nonnegative integer. If no minibuffers are active, it returns zero.
#+END_QUOTE

--- User Option: *enable-recursive-minibuffers*

#+BEGIN_QUOTE
  If this variable is non-=nil=, you can invoke commands (such as =find-file=) that use minibuffers even while the minibuffer is active. Such invocation produces a recursive editing level for a new minibuffer. The outer-level minibuffer is invisible while you are editing the inner one.

  If this variable is =nil=, you cannot invoke minibuffer commands when the minibuffer is active, not even if you switch to another window to do it.
#+END_QUOTE

If a command name has a property =enable-recursive-minibuffers= that is non-=nil=, then the command can use the minibuffer to read arguments even if it is invoked from the minibuffer. A command can also achieve this by binding =enable-recursive-minibuffers= to =t= in the interactive declaration (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Using-Interactive][Using Interactive]]). The minibuffer command =next-matching-history-element= (normally M-s in the minibuffer) does the latter.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recursive-Mini][Recursive Mini]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]

* 20.14 Minibuffer Miscellany
    :PROPERTIES:
    :CUSTOM_ID: minibuffer-miscellany
    :END:

--- Function: *minibufferp* &optional buffer-or-name

#+BEGIN_QUOTE
  This function returns non-=nil= if buffer-or-name is a minibuffer. If buffer-or-name is omitted, it tests the current buffer.
#+END_QUOTE

--- Variable: *minibuffer-setup-hook*

#+BEGIN_QUOTE
  This is a normal hook that is run whenever the minibuffer is entered. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Hooks][Hooks]].
#+END_QUOTE

--- Macro: *minibuffer-with-setup-hook* function &rest body

#+BEGIN_QUOTE
  This macro executes body after arranging for the specified function to be called via =minibuffer-setup-hook=. By default, function is called before the other functions in the =minibuffer-setup-hook= list, but if function is of the form =(:append=func=)=, func will be called /after/ the other hook functions.

  The body forms should not use the minibuffer more than once. If the minibuffer is re-entered recursively, function will only be called once, for the outermost use of the minibuffer.
#+END_QUOTE

--- Variable: *minibuffer-exit-hook*

#+BEGIN_QUOTE
  This is a normal hook that is run whenever the minibuffer is exited. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Hooks][Hooks]].
#+END_QUOTE

--- Variable: *minibuffer-help-form*

#+BEGIN_QUOTE
  The current value of this variable is used to rebind =help-form= locally inside the minibuffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Help-Functions][Help Functions]]).
#+END_QUOTE

--- Variable: *minibuffer-scroll-window*

#+BEGIN_QUOTE
  If the value of this variable is non-=nil=, it should be a window object. When the function =scroll-other-window= is called in the minibuffer, it scrolls this window.
#+END_QUOTE

--- Function: *minibuffer-selected-window*

#+BEGIN_QUOTE
  This function returns the window that was selected just before the minibuffer window was selected. If the selected window is not a minibuffer window, it returns =nil=.
#+END_QUOTE

--- Function: *minibuffer-message* string &rest args

#+BEGIN_QUOTE
  This function displays string temporarily at the end of the minibuffer text, for a few seconds, or until the next input event arrives, whichever comes first. The variable =minibuffer-message-timeout= specifies the number of seconds to wait in the absence of input. It defaults to 2. If args is non-=nil=, the actual message is obtained by passing string and args through =format-message=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Formatting-Strings][Formatting Strings]].
#+END_QUOTE

--- Command: *minibuffer-inactive-mode*

#+BEGIN_QUOTE
  This is the major mode used in inactive minibuffers. It uses keymap =minibuffer-inactive-mode-map=. This can be useful if the minibuffer is in a separate frame. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers-and-Frames][Minibuffers and Frames]].
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymaps][Keymaps]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Top][Top]]
