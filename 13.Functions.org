#+TITLE: 13.Functions
* 13 Functions

A Lisp program is composed mainly of Lisp functions. This chapter explains what functions are, how they accept arguments, and how to define them.

* 13.1 What Is a Function?

In a general sense, a function is a rule for carrying out a computation given input values called arguments. The result of the computation is called the value or return value of the function. The computation can also have side effects, such as lasting changes in the values of variables or the contents of data structures (see [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-side-effect][Definition of side effect]]). A pure function is a function which, in addition to having no side effects, always returns the same value for the same combination of arguments, regardless of external factors such as machine type or system state.

In most computer languages, every function has a name. But in Lisp, a function in the strictest sense has no name: it is an object which can /optionally/ be associated with a symbol (e.g., =car=) that serves as the function name. See [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]]. When a function has been given a name, we usually also refer to that symbol as a "function" (e.g., we refer to "the function =car="). In this manual, the distinction between a function name and the function object itself is usually unimportant, but we will take note wherever it is relevant.

Certain function-like objects, called special forms and macros, also accept arguments to carry out computations. However, as explained below, these are not considered functions in Emacs Lisp.

Here are important terms for functions and function-like objects:

1) lambda expression

   A function (in the strict sense, i.e., a function object) which is written in Lisp. These are described in the following section. See [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]].

2) primitive

   A function which is callable from Lisp but is actually written in C. Primitives are also called built-in functions, or subrs. Examples include functions like =car= and =append=. In addition, all special forms (see below) are also considered primitives. Usually, a function is implemented as a primitive because it is a fundamental part of Lisp (e.g., =car=), or because it provides a low-level interface to operating system services, or because it needs to run fast. Unlike functions defined in Lisp, primitives can be modified or added only by changing the C sources and recompiling Emacs. See [[file:///home/gaowei/Desktop/elisp-manual.html#Writing-Emacs-Primitives][Writing Emacs Primitives]].

3) special form

   A primitive that is like a function but does not evaluate all of its arguments in the usual way. It may evaluate only some of the arguments, or may evaluate them in an unusual order, or several times. Examples include =if=, =and=, and =while=. See [[file:///home/gaowei/Desktop/elisp-manual.html#Special-Forms][Special Forms]].

4) macro

   A construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression which is to be evaluated instead of the original expression. Macros enable Lisp programmers to do the sorts of things that special forms can do. See [[file:///home/gaowei/Desktop/elisp-manual.html#Macros][Macros]].

5) command

   An object which can be invoked via the =command-execute= primitive, usually due to the user typing in a key sequence bound to that command. See [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]]. A command is usually a function; if the function is written in Lisp, it is made into a command by an =interactive= form in the function definition (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Commands][Defining Commands]]). Commands that are functions can also be called from Lisp expressions, just like other functions. Keyboard macros (strings and vectors) are commands also, even though they are not functions. See [[file:///home/gaowei/Desktop/elisp-manual.html#Keyboard-Macros][Keyboard Macros]]. We say that a symbol is a command if its function cell contains a command (see [[file:///home/gaowei/Desktop/elisp-manual.html#Symbol-Components][Symbol Components]]); such a named command can be invoked with M-x.

6) closure

   A function object that is much like a lambda expression, except that it also encloses an environment of lexical variable bindings. See [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]].

7) byte-code function

   A function that has been compiled by the byte compiler. See [[file:///home/gaowei/Desktop/elisp-manual.html#Byte_002dCode-Type][Byte-Code Type]].

8) autoload object

   A place-holder for a real function. If the autoload object is called, Emacs loads the file containing the definition of the real function, and then calls the real function. See [[file:///home/gaowei/Desktop/elisp-manual.html#Autoload][Autoload]].

You can use the function =functionp= to test if an object is a function:

--- Function: *functionp* object


  This function returns =t= if object is any kind of function, i.e., can be passed to =funcall=. Note that =functionp= returns =t= for symbols that are function names, and returns =nil= for special forms.


It is also possible to find out how many arguments an arbitrary function expects:

--- Function: *func-arity* function


  This function provides information about the argument list of the specified function. The returned value is a cons cell of the form =(=min=.=max=)=, where min is the minimum number of arguments, and max is either the maximum number of arguments, or the symbol =many= for functions with =&rest= arguments, or the symbol =unevalled= if function is a special form.

  Note that this function might return inaccurate results in some situations, such as the following:

  - Functions defined using =apply-partially= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][apply-partially]]).\\
  - Functions that are advised using =advice-add= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Named-Functions][Advising Named Functions]]).\\
  - Functions that determine the argument list dynamically, as part of their code.


Unlike =functionp=, the next three functions do /not/ treat a symbol as its function definition.

--- Function: *subrp* object


  This function returns =t= if object is a built-in function (i.e., a Lisp primitive).

  #+begin_src elisp
                (subrp 'message)            ; message is a symbol,
                     ⇒ nil                 ;   not a subr object.
                (subrp (symbol-function 'message))
                     ⇒ t
  #+end_src


--- Function: *byte-code-function-p* object


  This function returns =t= if object is a byte-code function. For example:

  #+begin_src elisp
                (byte-code-function-p (symbol-function 'next-line))
                     ⇒ t
  #+end_src


--- Function: *subr-arity* subr


  This works like =func-arity=, but only for built-in functions and without symbol indirection. It signals an error for non-built-in functions. We recommend to use =func-arity= instead.


Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#What-Is-a-Function][What Is a Function]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.2 Lambda Expressions
    :PROPERTIES:
    :CUSTOM_ID: lambda-expressions
    :END:

A lambda expression is a function object written in Lisp. Here is an example:

#+begin_src elisp
         (lambda (x)
           "Return the hyperbolic cosine of X."
           (* 0.5 (+ (exp x) (exp (- x)))))
#+end_src

In Emacs Lisp, such a list is a valid expression which evaluates to a function object.

A lambda expression, by itself, has no name; it is an anonymous function. Although lambda expressions can be used this way (see [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]]), they are more commonly associated with symbols to make named functions (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]]). Before going into these details, the following subsections describe the components of a lambda expression and what they do.

- [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Components][Lambda Components]]: The parts of a lambda expression.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Simple-Lambda][Simple Lambda]]: A simple example.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Argument-List][Argument List]]: Details and special features of argument lists.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]]: How to put documentation in a function.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Simple-Lambda][Simple Lambda]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]]

** 13.2.1 Components of a Lambda Expression
     :PROPERTIES:
     :CUSTOM_ID: components-of-a-lambda-expression
     :END:

A lambda expression is a list that looks like this:

#+begin_src elisp
         (lambda (arg-variables...)
           [documentation-string]
           [interactive-declaration]
           body-forms...)
#+end_src

The first element of a lambda expression is always the symbol =lambda=. This indicates that the list represents a function. The reason functions are defined to start with =lambda= is so that other lists, intended for other uses, will not accidentally be valid as functions.

The second element is a list of symbols---the argument variable names. This is called the lambda list. When a Lisp function is called, the argument values are matched up against the variables in the lambda list, which are given local bindings with the values provided. See [[file:///home/gaowei/Desktop/elisp-manual.html#Local-Variables][Local Variables]].

The documentation string is a Lisp string object placed within the function definition to describe the function for the Emacs help facilities. See [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]].

The interactive declaration is a list of the form =(interactive=code-string=)=. This declares how to provide arguments if the function is used interactively. Functions with this declaration are called commands; they can be called using M-x or bound to a key. Functions not intended to be called in this way should not have interactive declarations. See [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Commands][Defining Commands]], for how to write an interactive declaration.

The rest of the elements are the body of the function: the Lisp code to do the work of the function (or, as a Lisp programmer would say, "a list of Lisp forms to evaluate"). The value returned by the function is the value returned by the last element of the body.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Argument-List][Argument List]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Components][Lambda Components]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]]

** 13.2.2 A Simple Lambda Expression Example
     :PROPERTIES:
     :CUSTOM_ID: a-simple-lambda-expression-example
     :END:

Consider the following example:

#+begin_src elisp
         (lambda (a b c) (+ a b c))
#+end_src

We can call this function by passing it to =funcall=, like this:

#+begin_src elisp
         (funcall (lambda (a b c) (+ a b c))
                  1 2 3)
#+end_src

This call evaluates the body of the lambda expression with the variable =a= bound to 1, =b= bound to 2, and =c= bound to 3. Evaluation of the body adds these three numbers, producing the result 6; therefore, this call to the function returns the value 6.

Note that the arguments can be the results of other function calls, as in this example:

#+begin_src elisp
         (funcall (lambda (a b c) (+ a b c))
                  1 (* 2 3) (- 5 4))
#+end_src

This evaluates the arguments =1=, =(* 2 3)=, and =(- 5 4)= from left to right. Then it applies the lambda expression to the argument values 1, 6 and 1 to produce the value 8.

As these examples show, you can use a form with a lambda expression as its car to make local variables and give them values. In the old days of Lisp, this technique was the only way to bind and initialize local variables. But nowadays, it is clearer to use the special form =let= for this purpose (see [[file:///home/gaowei/Desktop/elisp-manual.html#Local-Variables][Local Variables]]). Lambda expressions are mainly used as anonymous functions for passing as arguments to other functions (see [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]]), or stored as symbol function definitions to produce named functions (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]]).

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Simple-Lambda][Simple Lambda]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]]

** 13.2.3 Other Features of Argument Lists
     :PROPERTIES:
     :CUSTOM_ID: other-features-of-argument-lists
     :END:

Our simple sample function, =(lambda (a b c) (+ a b c))=, specifies three argument variables, so it must be called with three arguments: if you try to call it with only two arguments or four arguments, you get a =wrong-number-of-arguments= error (see [[file:///home/gaowei/Desktop/elisp-manual.html#Errors][Errors]]).

It is often convenient to write a function that allows certain arguments to be omitted. For example, the function =substring= accepts three arguments---a string, the start index and the end index---but the third argument defaults to the length of the string if you omit it. It is also convenient for certain functions to accept an indefinite number of arguments, as the functions =list= and =+= do.

To specify optional arguments that may be omitted when a function is called, simply include the keyword =&optional= before the optional arguments. To specify a list of zero or more extra arguments, include the keyword =&rest= before one final argument.

Thus, the complete syntax for an argument list is as follows:

#+begin_src elisp
         (required-vars...
          [&optional optional-vars...]
          [&rest rest-var])
#+end_src

The square brackets indicate that the =&optional= and =&rest= clauses, and the variables that follow them, are optional.

A call to the function requires one actual argument for each of the required-vars. There may be actual arguments for zero or more of the optional-vars, and there cannot be any actual arguments beyond that unless the lambda list uses =&rest=. In that case, there may be any number of extra actual arguments.

If actual arguments for the optional and rest variables are omitted, then they always default to =nil=. There is no way for the function to distinguish between an explicit argument of =nil= and an omitted argument. However, the body of the function is free to consider =nil= an abbreviation for some other meaningful value. This is what =substring= does; =nil= as the third argument to =substring= means to use the length of the string supplied.


  *Common Lisp note:* Common Lisp allows the function to specify what default value to use when an optional argument is omitted; Emacs Lisp always uses =nil=. Emacs Lisp does not support =supplied-p= variables that tell you whether an argument was explicitly passed.


For example, an argument list that looks like this:

#+begin_src elisp
         (a b &optional c d &rest e)
#+end_src

binds =a= and =b= to the first two actual arguments, which are required. If one or two more arguments are provided, =c= and =d= are bound to them respectively; any arguments after the first four are collected into a list and =e= is bound to that list. Thus, if there are only two arguments, =c=, =d= and =e= are =nil=; if two or three arguments, =d= and =e= are =nil=; if four arguments or fewer, =e= is =nil=. Note that exactly five arguments with an explicit =nil= argument provided for =e= will cause that =nil= argument to be passed as a list with one element, =(nil)=, as with any other single value for =e=.

There is no way to have required arguments following optional ones---it would not make sense. To see why this must be so, suppose that =c= in the example were optional and =d= were required. Suppose three actual arguments are given; which variable would the third argument be for? Would it be used for the c, or for d? One can argue for both possibilities. Similarly, it makes no sense to have any more arguments (either required or optional) after a =&rest= argument.

Here are some examples of argument lists and proper calls:

#+begin_src elisp
         (funcall (lambda (n) (1+ n))        ; One required:
                  1)                         ; requires exactly one argument.
              ⇒ 2
         (funcall (lambda (n &optional n1)   ; One required and one optional:
                    (if n1 (+ n n1) (1+ n))) ; 1 or 2 arguments.
                  1 2)
              ⇒ 3
         (funcall (lambda (n &rest ns)       ; One required and one rest:
                    (+ n (apply '+ ns)))     ; 1 or more arguments.
                  1 2 3 4 5)
              ⇒ 15
#+end_src

Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Argument-List][Argument List]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]]

** 13.2.4 Documentation Strings of Functions
     :PROPERTIES:
     :CUSTOM_ID: documentation-strings-of-functions
     :END:

A lambda expression may optionally have a documentation string just after the lambda list. This string does not affect execution of the function; it is a kind of comment, but a systematized comment which actually appears inside the Lisp world and can be used by the Emacs help facilities. See [[file:///home/gaowei/Desktop/elisp-manual.html#Documentation][Documentation]], for how the documentation string is accessed.

It is a good idea to provide documentation strings for all the functions in your program, even those that are called only from within your program. Documentation strings are like comments, except that they are easier to access.

The first line of the documentation string should stand on its own, because =apropos= displays just this first line. It should consist of one or two complete sentences that summarize the function's purpose.

The start of the documentation string is usually indented in the source file, but since these spaces come before the starting double-quote, they are not part of the string. Some people make a practice of indenting any additional lines of the string so that the text lines up in the program source. /That is a mistake./ The indentation of the following lines is inside the string; what looks nice in the source code will look ugly when displayed by the help commands.

You may wonder how the documentation string could be optional, since there are required components of the function that follow it (the body). Since evaluation of a string returns that string, without any side effects, it has no effect if it is not the last form in the body. Thus, in practice, there is no confusion between the first form of the body and the documentation string; if the only body form is a string then it serves both as the return value and as the documentation.

The last line of the documentation string can specify calling conventions different from the actual function arguments. Write text like this:

#+begin_src elisp
         \(fn arglist)
#+end_src

following a blank line, at the beginning of the line, with no newline following it inside the documentation string. (The ‘' is used to avoid confusing the Emacs motion commands.) The calling convention specified in this way appears in help messages in place of the one derived from the actual arguments of the function.

This feature is particularly useful for macro definitions, since the arguments written in a macro definition often do not correspond to the way users think of the parts of the macro call.

Do not use this feature if you want to deprecate the calling convention and favor the one you advertise by the above specification. Instead, use the =advertised-calling-convention= declaration (see [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]]) or =set-advertised-calling-convention= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]]), because these two will cause the byte compiler emit a warning message when it compiles Lisp programs which use the deprecated calling convention.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.3 Naming a Function
    :PROPERTIES:
    :CUSTOM_ID: naming-a-function
    :END:

A symbol can serve as the name of a function. This happens when the symbol's function cell (see [[file:///home/gaowei/Desktop/elisp-manual.html#Symbol-Components][Symbol Components]]) contains a function object (e.g., a lambda expression). Then the symbol itself becomes a valid, callable function, equivalent to the function object in its function cell.

The contents of the function cell are also called the symbol's function definition. The procedure of using a symbol's function definition in place of the symbol is called symbol function indirection; see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Indirection][Function Indirection]]. If you have not given a symbol a function definition, its function cell is said to be void, and it cannot be used as a function.

In practice, nearly all functions have names, and are referred to by their names. You can create a named Lisp function by defining a lambda expression and putting it in a function cell (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Cells][Function Cells]]). However, it is more common to use the =defun= special form, described in the next section. See [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]].

We give functions names because it is convenient to refer to them by their names in Lisp expressions. Also, a named Lisp function can easily refer to itself---it can be recursive. Furthermore, primitives can only be referred to textually by their names, since primitive function objects (see [[file:///home/gaowei/Desktop/elisp-manual.html#Primitive-Function-Type][Primitive Function Type]]) have no read syntax.

A function need not have a unique name. A given function object /usually/ appears in the function cell of only one symbol, but this is just a convention. It is easy to store it in several symbols using =fset=; then each of the symbols is a valid name for the same function.

Note that a symbol used as a function name may also be used as a variable; these two uses of a symbol are independent and do not conflict. (This is not the case in some dialects of Lisp, like Scheme.)

By convention, if a function's symbol consists of two names separated by '--', the function is intended for internal use and the first part names the file defining the function. For example, a function named =vc-git--rev-parse= is an internal function defined in vc-git.el. Internal-use functions written in C have names ending in '-internal', e.g., =bury-buffer-internal=. Emacs code contributed before 2018 may follow other internal-use naming conventions, which are being phased out.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.4 Defining Functions
    :PROPERTIES:
    :CUSTOM_ID: defining-functions
    :END:

We usually give a name to a function when it is first created. This is called defining a function, and it is done with the =defun= macro.

--- Macro: *defun* name args [doc] [declare] [interactive] body...


  =defun= is the usual way to define new Lisp functions. It defines the symbol name as a function with argument list args and body forms given by body. Neither name nor args should be quoted.

  doc, if present, should be a string specifying the function's documentation string (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]]). declare, if present, should be a =declare= form specifying function metadata (see [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]]). interactive, if present, should be an =interactive= form specifying how the function is to be called interactively (see [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]]).

  The return value of =defun= is undefined.

  Here are some examples:

  #+begin_src elisp
                (defun foo () 5)
                (foo)
                     ⇒ 5

                (defun bar (a &optional b &rest c)
                    (list a b c))
                (bar 1 2 3 4 5)
                     ⇒ (1 2 (3 4 5))
                (bar 1)
                     ⇒ (1 nil nil)
                (bar)
                error--> Wrong number of arguments.

                (defun capitalize-backwards ()
                  "Upcase the last letter of the word at point."
                  (interactive)
                  (backward-word 1)
                  (forward-word 1)
                  (backward-char 1)
                  (capitalize-word 1))
  #+end_src

  Be careful not to redefine existing functions unintentionally. =defun= redefines even primitive functions such as =car= without any hesitation or notification. Emacs does not prevent you from doing this, because redefining a function is sometimes done deliberately, and there is no way to distinguish deliberate redefinition from unintentional redefinition.


--- Function: *defalias* name definition &optional doc


  This function defines the symbol name as a function, with definition definition (which can be any valid Lisp function). Its return value is /undefined/.

  If doc is non-=nil=, it becomes the function documentation of name. Otherwise, any documentation provided by definition is used.

  Internally, =defalias= normally uses =fset= to set the definition. If name has a =defalias-fset-function= property, however, the associated value is used as a function to call in place of =fset=.

  The proper place to use =defalias= is where a specific function name is being defined---especially where that name appears explicitly in the source file being loaded. This is because =defalias= records which file defined the function, just like =defun= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Unloading][Unloading]]).

  By contrast, in programs that manipulate function definitions for other purposes, it is better to use =fset=, which does not keep such records. See [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Cells][Function Cells]].


You cannot create a new primitive function with =defun= or =defalias=, but you can use them to change the function definition of any symbol, even one such as =car= or =x-popup-menu= whose normal definition is a primitive. However, this is risky: for instance, it is next to impossible to redefine =car= without breaking Lisp completely. Redefining an obscure function such as =x-popup-menu= is less dangerous, but it still may not work as you expect. If there are calls to the primitive from C code, they call the primitive's C definition directly, so changing the symbol's definition will have no effect on them.

See also =defsubst=, which defines a function like =defun= and tells the Lisp compiler to perform inline expansion on it. See [[file:///home/gaowei/Desktop/elisp-manual.html#Inline-Functions][Inline Functions]].

Alternatively, you can define a function by providing the code which will inline it as a compiler macro. The following macros make this possible.

--- Macro: *define-inline* name args [doc] [declare] body...


  Define a function name by providing code that does its inlining, as a compiler macro. The function will accept the argument list args and will have the specified body.

  If present, doc should be the function's documentation string (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]]); declare, if present, should be a =declare= form (see [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]]) specifying the function's metadata.


Functions defined via =define-inline= have several advantages with respect to macros defined by =defsubst= or =defmacro=:

- They can be passed to =mapcar= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]]).\\
- They are more efficient.\\
- They can be used as place forms to store values (see [[file:///home/gaowei/Desktop/elisp-manual.html#Generalized-Variables][Generalized Variables]]).\\
- They behave in a more predictable way than =cl-defsubst= (see [[https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Argument-Lists][Argument Lists]]).

Like =defmacro=, a function inlined with =define-inline= inherits the scoping rules, either dynamic or lexical, from the call site. See [[file:///home/gaowei/Desktop/elisp-manual.html#Variable-Scoping][Variable Scoping]].

The following macros should be used in the body of a function defined by =define-inline=.

--- Macro: *inline-quote* expression


  Quote expression for =define-inline=. This is similar to the backquote (see [[file:///home/gaowei/Desktop/elisp-manual.html#Backquote][Backquote]]), but quotes code and accepts only =,=, not =,@=.


--- Macro: *inline-letevals* (bindings...) body...


  This is similar to =let= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Local-Variables][Local Variables]]): it sets up local variables as specified by bindings, and then evaluates body with those bindings in effect. Each element of bindings should be either a symbol or a list of the form =(=var==expr=)=; the result is to evaluate expr and bind var to the result. The tail of bindings can be either =nil= or a symbol which should hold a list of arguments, in which case each argument is evaluated, and the symbol is bound to the resulting list.


--- Macro: *inline-const-p* expression


  Return non-=nil= if the value of expression is already known.


--- Macro: *inline-const-val* expression


  Return the value of expression.


--- Macro: *inline-error* format &rest args


  Signal an error, formatting args according to format.


Here's an example of using =define-inline=:

#+begin_src elisp
         (define-inline myaccessor (obj)
           (inline-letevals (obj)
             (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
#+end_src

This is equivalent to

#+begin_src elisp
         (defsubst myaccessor (obj)
           (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
#+end_src

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.5 Calling Functions


Defining functions is only half the battle. Functions don't do anything until you call them, i.e., tell them to run. Calling a function is also known as invocation.

The most common way of invoking a function is by evaluating a list. For example, evaluating the list =(concat "a" "b")= calls the function =concat= with arguments ="a"= and ="b"=. See [[file:///home/gaowei/Desktop/elisp-manual.html#Evaluation][Evaluation]], for a description of evaluation.

When you write a list as an expression in your program, you specify which function to call, and how many arguments to give it, in the text of the program. Usually that's just what you want. Occasionally you need to compute at run time which function to call. To do that, use the function =funcall=. When you also need to determine at run time how many arguments to pass, use =apply=.

--- Function: *funcall* function &rest arguments


  =funcall= calls function with arguments, and returns whatever function returns.

  Since =funcall= is a function, all of its arguments, including function, are evaluated before =funcall= is called. This means that you can use any expression to obtain the function to be called. It also means that =funcall= does not see the expressions you write for the arguments, only their values. These values are /not/ evaluated a second time in the act of calling function; the operation of =funcall= is like the normal procedure for calling a function, once its arguments have already been evaluated.

  The argument function must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. =funcall= cannot provide these because, as we saw above, it never knows them in the first place.

  If you need to use =funcall= to call a command and make it behave as if invoked interactively, use =funcall-interactively= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]]).

  #+begin_src elisp
                (setq f 'list)
                     ⇒ list
                (funcall f 'x 'y 'z)
                     ⇒ (x y z)
                (funcall f 'x 'y '(z))
                     ⇒ (x y (z))
                (funcall 'and t nil)
                error--> Invalid function: #<subr and>
  #+end_src

  Compare these examples with the examples of =apply=.


--- Function: *apply* function &rest arguments


  =apply= calls function with arguments, just like =funcall= but with one difference: the last of arguments is a list of objects, which are passed to function as separate arguments, rather than a single list. We say that =apply= spreads this list so that each individual element becomes an argument.

  =apply= returns the result of calling function. As with =funcall=, function must either be a Lisp function or a primitive function; special forms and macros do not make sense in =apply=.

  #+begin_src elisp
                (setq f 'list)
                     ⇒ list
                (apply f 'x 'y 'z)
                error--> Wrong type argument: listp, z
                (apply '+ 1 2 '(3 4))
                     ⇒ 10
                (apply '+ '(1 2 3 4))
                     ⇒ 10

                (apply 'append '((a b c) nil (x y z) nil))
                     ⇒ (a b c x y z)
  #+end_src

  For an interesting example of using =apply=, see [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-mapcar][Definition of mapcar]].


Sometimes it is useful to fix some of the function's arguments at certain values, and leave the rest of arguments for when the function is actually called. The act of fixing some of the function's arguments is called partial application of the function[[file:///home/gaowei/Desktop/elisp-manual.html#fn-10][10]]. The result is a new function that accepts the rest of arguments and calls the original function with all the arguments combined.

Here's how to do partial application in Emacs Lisp:

--- Function: *apply-partially* func &rest args


  This function returns a new function which, when called, will call func with the list of arguments composed from args and additional arguments specified at the time of the call. If func accepts n arguments, then a call to =apply-partially= with m=<=n arguments will produce a new function of n=-=m arguments.

  Here's how we could define the built-in function =1+=, if it didn't exist, using =apply-partially= and =+=, another built-in function:

  #+begin_src elisp
                (defalias '1+ (apply-partially '+ 1)
                  "Increment argument by one.")
                (1+ 10)
                     ⇒ 11
  #+end_src


It is common for Lisp functions to accept functions as arguments or find them in data structures (especially in hook variables and property lists) and call them using =funcall= or =apply=. Functions that accept function arguments are often called functionals.

Sometimes, when you call a functional, it is useful to supply a no-op function as the argument. Here are two different kinds of no-op function:

--- Function: *identity* arg


  This function returns arg and has no side effects.


--- Function: *ignore* &rest args


  This function ignores any arguments and returns =nil=.


Some functions are user-visible commands, which can be called interactively (usually by a key sequence). It is possible to invoke such a command exactly as though it was called interactively, by using the =call-interactively= function. See [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]].

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.6 Mapping Functions
    :PROPERTIES:
    :CUSTOM_ID: mapping-functions
    :END:

A mapping function applies a given function (/not/ a special form or macro) to each element of a list or other collection. Emacs Lisp has several such functions; this section describes =mapcar=, =mapc=, =mapconcat=, and =mapcan=, which map over a list. See [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-mapatoms][Definition of mapatoms]], for the function =mapatoms= which maps over the symbols in an obarray. See [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-maphash][Definition of maphash]], for the function =maphash= which maps over key/value associations in a hash table.

These mapping functions do not allow char-tables because a char-table is a sparse array whose nominal range of indices is very large. To map over a char-table in a way that deals properly with its sparse nature, use the function =map-char-table= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Char_002dTables][Char-Tables]]).

--- Function: *mapcar* function sequence


  =mapcar= applies function to each element of sequence in turn, and returns a list of the results.

  The argument sequence can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string. The result is always a list. The length of the result is the same as the length of sequence. For example:

  #+begin_src elisp
                (mapcar 'car '((a b) (c d) (e f)))
                     ⇒ (a c e)
                (mapcar '1+ [1 2 3])
                     ⇒ (2 3 4)
                (mapcar 'string "abc")
                     ⇒ ("a" "b" "c")

                ;; Call each function in my-hooks.
                (mapcar 'funcall my-hooks)

                (defun mapcar* (function &rest args)
                  "Apply FUNCTION to successive cars of all ARGS.
                Return the list of results."
                  ;; If no list is exhausted,
                  (if (not (memq nil args))
                      ;; apply function to cars.
                      (cons (apply function (mapcar 'car args))
                            (apply 'mapcar* function
                                   ;; Recurse for rest of elements.
                                   (mapcar 'cdr args)))))

                (mapcar* 'cons '(a b c) '(1 2 3 4))
                     ⇒ ((a . 1) (b . 2) (c . 3))
  #+end_src


--- Function: *mapcan* function sequence


  This function applies function to each element of sequence, like =mapcar=, but instead of collecting the results into a list, it returns a single list with all the elements of the results (which must be lists), by altering the results (using =nconc=; see [[file:///home/gaowei/Desktop/elisp-manual.html#Rearrangement][Rearrangement]]). Like with =mapcar=, sequence can be of any type except a char-table.

  #+begin_src elisp
                ;; Contrast this:
                (mapcar 'list '(a b c d))
                     ⇒ ((a) (b) (c) (d))
                ;; with this:
                (mapcan 'list '(a b c d))
                     ⇒ (a b c d)
  #+end_src


--- Function: *mapc* function sequence


  =mapc= is like =mapcar= except that function is used for side-effects only---the values it returns are ignored, not collected into a list. =mapc= always returns sequence.


--- Function: *mapconcat* function sequence separator


  =mapconcat= applies function to each element of sequence; the results, which must be sequences of characters (strings, vectors, or lists), are concatenated into a single string return value. Between each pair of result sequences, =mapconcat= inserts the characters from separator, which also must be a string, or a vector or list of characters. See [[file:///home/gaowei/Desktop/elisp-manual.html#Sequences-Arrays-Vectors][Sequences Arrays Vectors]].

  The argument function must be a function that can take one argument and returns a sequence of characters: a string, a vector, or a list. The argument sequence can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string.

  #+begin_src elisp
                (mapconcat 'symbol-name
                           '(The cat in the hat)
                           " ")
                     ⇒ "The cat in the hat"

                (mapconcat (function (lambda (x) (format "%c" (1+ x))))
                           "HAL-8000"
                           "")
                     ⇒ "IBM.9111"
  #+end_src


Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Generic-Functions][Generic Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.7 Anonymous Functions
    :PROPERTIES:
    :CUSTOM_ID: anonymous-functions
    :END:

Although functions are usually defined with =defun= and given names at the same time, it is sometimes convenient to use an explicit lambda expression---an anonymous function. Anonymous functions are valid wherever function names are. They are often assigned as variable values, or as arguments to functions; for instance, you might pass one as the function argument to =mapcar=, which applies that function to each element of a list (see [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]]). See [[file:///home/gaowei/Desktop/elisp-manual.html#describe_002dsymbols-example][describe-symbols example]], for a realistic example of this.

When defining a lambda expression that is to be used as an anonymous function, you can in principle use any method to construct the list. But typically you should use the =lambda= macro, or the =function= special form, or the =#'= read syntax:

--- Macro: *lambda* args [doc] [interactive] body...

#+BEGIN_QUOT
  This macro returns an anonymous function with argument list args, documentation string doc (if any), interactive spec interactive (if any), and body forms given by body.

  Under dynamic binding, this macro effectively makes =lambda= forms self-quoting: evaluating a form whose car is =lambda= yields the form itself:

  #+begin_src elisp
                (lambda (x) (* x x))
                     ⇒ (lambda (x) (* x x))
  #+end_src

  Note that when evaluating under lexical binding the result is a closure object (see [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]]).

  The =lambda= form has one other effect: it tells the Emacs evaluator and byte-compiler that its argument is a function, by using =function= as a subroutine (see below).


--- Special Form: *function* function-object


  This special form returns function-object without evaluating it. In this, it is similar to =quote= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Quoting][Quoting]]). But unlike =quote=, it also serves as a note to the Emacs evaluator and byte-compiler that function-object is intended to be used as a function. Assuming function-object is a valid lambda expression, this has two effects:

  - When the code is byte-compiled, function-object is compiled into a byte-code function object (see [[file:///home/gaowei/Desktop/elisp-manual.html#Byte-Compilation][Byte Compilation]]).\\
  - When lexical binding is enabled, function-object is converted into a closure. See [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]].


The read syntax =#'= is a short-hand for using =function=. The following forms are all equivalent:

#+begin_src elisp
         (lambda (x) (* x x))
         (function (lambda (x) (* x x)))
         #'(lambda (x) (* x x))
#+end_src

In the following example, we define a =change-property= function that takes a function as its third argument, followed by a =double-property= function that makes use of =change-property= by passing it an anonymous function:

#+begin_src elisp
         (defun change-property (symbol prop function)
           (let ((value (get symbol prop)))
             (put symbol prop (funcall function value))))

         (defun double-property (symbol prop)
           (change-property symbol prop (lambda (x) (* 2 x))))
#+end_src

Note that we do not quote the =lambda= form.

If you compile the above code, the anonymous function is also compiled. This would not happen if, say, you had constructed the anonymous function by quoting it as a list:

#+begin_src elisp
         (defun double-property (symbol prop)
           (change-property symbol prop '(lambda (x) (* 2 x))))
#+end_src

In that case, the anonymous function is kept as a lambda expression in the compiled code. The byte-compiler cannot assume this list is a function, even though it looks like one, since it does not know that =change-property= intends to use it as a function.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Cells][Function Cells]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.8 Generic Functions
    :PROPERTIES:
    :CUSTOM_ID: generic-functions
    :END:

Functions defined using =defun= have a hard-coded set of assumptions about the types and expected values of their arguments. For example, a function that was designed to handle values of its argument that are either numbers or lists of numbers will fail or signal an error if called with a value of any other type, such as a vector or a string. This happens because the implementation of the function is not prepared to deal with types other than those assumed during the design.

By contrast, object-oriented programs use polymorphic functions: a set of specialized functions having the same name, each one of which was written for a certain specific set of argument types. Which of the functions is actually called is decided at run time based on the types of the actual arguments.

Emacs provides support for polymorphism. Like other Lisp environments, notably Common Lisp and its Common Lisp Object System (CLOS), this support is based on generic functions. The Emacs generic functions closely follow CLOS, including use of similar names, so if you have experience with CLOS, the rest of this section will sound very familiar.

A generic function specifies an abstract operation, by defining its name and list of arguments, but (usually) no implementation. The actual implementation for several specific classes of arguments is provided by methods, which should be defined separately. Each method that implements a generic function has the same name as the generic function, but the method's definition indicates what kinds of arguments it can handle by specializing the arguments defined by the generic function. These argument specializers can be more or less specific; for example, a =string= type is more specific than a more general type, such as =sequence=.

Note that, unlike in message-based OO languages, such as C=++= and Simula, methods that implement generic functions don't belong to a class, they belong to the generic function they implement.

When a generic function is invoked, it selects the applicable methods by comparing the actual arguments passed by the caller with the argument specializers of each method. A method is applicable if the actual arguments of the call are compatible with the method's specializers. If more than one method is applicable, they are combined using certain rules, described below, and the combination then handles the call.

--- Macro: *cl-defgeneric* name arguments [documentation] [options-and-methods...] &rest body


  This macro defines a generic function with the specified name and arguments. If body is present, it provides the default implementation. If documentation is present (it should always be), it specifies the documentation string for the generic function, in the form =(:documentation=docstring=)=. The optional options-and-methods can be one of the following forms:

  - =(declare=declarations=)=

    A declare form, as described in [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]].

  - =(:argument-precedence-order &rest=args=)=

    This form affects the sorting order for combining applicable methods. Normally, when two methods are compared during combination, method arguments are examined left to right, and the first method whose argument specializer is more specific will come before the other one. The order defined by this form overrides that, and the arguments are examined according to their order in this form, and not left to right.

  - =(:method [=qualifiers=...] args &rest body)=

    This form defines a method like =cl-defmethod= does.



--- Macro: *cl-defmethod* name [qualifier] arguments &rest [docstring] body


  This macro defines a particular implementation for the generic function called name. The implementation code is given by body. If present, docstring is the documentation string for the method. The arguments list, which must be identical in all the methods that implement a generic function, and must match the argument list of that function, provides argument specializers of the form =(=arg spec=)=, where arg is the argument name as specified in the =cl-defgeneric= call, and spec is one of the following specializer forms:

  - type

    This specializer requires the argument to be of the given type, one of the types from the type hierarchy described below.

  - =(eql=object=)=

    This specializer requires the argument be =eql= to the given object.

  - =(head=object=)=

    The argument must be a cons cell whose =car= is =eql= to object.

  - struct-type

    The argument must be an instance of a class named struct-type defined with =cl-defstruct= (see [[https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Structures][Structures]]), or of one of its child classes.

  Alternatively, the argument specializer can be of the form =&context (=expr spec=)=, in which case the value of expr must be compatible with the specializer provided by spec; spec can be any of the forms described above. In other words, this form of specializer uses the value of expr instead of arguments for the decision whether the method is applicable. For example, =&context (overwrite-mode (eql t))= will make the method compatible only when =overwrite-mode= is turned on.

  The type specializer, =(=arg type=)=, can specify one of the system types in the following list. When a parent type is specified, an argument whose type is any of its more specific child types, as well as grand-children, grand-grand-children, etc. will also be compatible.

  - =integer=

    Parent type: =number=.

  - =number=

  - =null=

    Parent type: =symbol=

  - =symbol=

  - =string=

    Parent type: =array=.

  - =array=

    Parent type: =sequence=.

  - =cons=

    Parent type: =list=.

  - =list=

    Parent type: =sequence=.

  - =marker=

  - =overlay=

  - =float=

    Parent type: =number=.

  - =window-configuration=

  - =process=

  - =window=

  - =subr=

  - =compiled-function=

  - =buffer=

  - =char-table=

    Parent type: =array=.

  - =bool-vector=

    Parent type: =array=.

  - =vector=

    Parent type: =array=.

  - =frame=

  - =hash-table=

  - =font-spec=

  - =font-entity=

  - =font-object=

  The optional qualifier allows combining several applicable methods. If it is not present, the defined method is a primary method, responsible for providing the primary implementation of the generic function for the specialized arguments. You can also define auxiliary methods, by using one of the following values as qualifier:

  - =:before=

    This auxiliary method will run before the primary method. More accurately, all the =:before= methods will run before the primary, in the most-specific-first order.

  - =:after=

    This auxiliary method will run after the primary method. More accurately, all such methods will run after the primary, in the most-specific-last order.

  - =:around=

    This auxiliary method will run /instead/ of the primary method. The most specific of such methods will be run before any other method. Such methods normally use =cl-call-next-method=, described below, to invoke the other auxiliary or primary methods.

  - =:extra=string

    This allows you to add more methods, distinguished by string, for the same specializers and qualifiers.

  Functions defined using =cl-defmethod= cannot be made interactive, i.e. commands (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Commands][Defining Commands]]), by adding the =interactive= form to them. If you need a polymorphic command, we recommend defining a normal command that calls a polymorphic function defined via =cl-defgeneric= and =cl-defmethod=.


Each time a generic function is called, it builds the effective method which will handle this invocation by combining the applicable methods defined for the function. The process of finding the applicable methods and producing the effective method is called dispatch. The applicable methods are those all of whose specializers are compatible with the actual arguments of the call. Since all of the arguments must be compatible with the specializers, they all determine whether a method is applicable. Methods that explicitly specialize more than one argument are called multiple-dispatch methods.

The applicable methods are sorted into the order in which they will be combined. The method whose left-most argument specializer is the most specific one will come first in the order. (Specifying =:argument-precedence-order= as part of =cl-defmethod= overrides that, as described above.) If the method body calls =cl-call-next-method=, the next most-specific method will run. If there are applicable =:around= methods, the most-specific of them will run first; it should call =cl-call-next-method= to run any of the less specific =:around= methods. Next, the =:before= methods run in the order of their specificity, followed by the primary method, and lastly the =:after= methods in the reverse order of their specificity.

--- Function: *cl-call-next-method* &rest args


  When invoked from within the lexical body of a primary or an =:around= auxiliary method, call the next applicable method for the same generic function. Normally, it is called with no arguments, which means to call the next applicable method with the same arguments that the calling method was invoked. Otherwise, the specified arguments are used instead.


--- Function: *cl-next-method-p*


  This function, when called from within the lexical body of a primary or an =:around= auxiliary method, returns non-=nil= if there is a next method to call.


Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Generic-Functions][Generic Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.9 Accessing Function Cell Contents
    :PROPERTIES:
    :CUSTOM_ID: accessing-function-cell-contents
    :END:

The function definition of a symbol is the object stored in the function cell of the symbol. The functions described here access, test, and set the function cell of symbols.

See also the function =indirect-function=. See [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-indirect_002dfunction][Definition of indirect-function]].

--- Function: *symbol-function* symbol


  This returns the object in the function cell of symbol. It does not check that the returned object is a legitimate function.

  If the function cell is void, the return value is =nil=. To distinguish between a function cell that is void and one set to =nil=, use =fboundp= (see below).

  #+begin_src elisp
                (defun bar (n) (+ n 2))
                (symbol-function 'bar)
                     ⇒ (lambda (n) (+ n 2))
                (fset 'baz 'bar)
                     ⇒ bar
                (symbol-function 'baz)
                     ⇒ bar
  #+end_src


If you have never given a symbol any function definition, we say that that symbol's function cell is void. In other words, the function cell does not have any Lisp object in it. If you try to call the symbol as a function, Emacs signals a =void-function= error.

Note that void is not the same as =nil= or the symbol =void=. The symbols =nil= and =void= are Lisp objects, and can be stored into a function cell just as any other object can be (and they can be valid functions if you define them in turn with =defun=). A void function cell contains no object whatsoever.

You can test the voidness of a symbol's function definition with =fboundp=. After you have given a symbol a function definition, you can make it void once more using =fmakunbound=.

--- Function: *fboundp* symbol


  This function returns =t= if the symbol has an object in its function cell, =nil= otherwise. It does not check that the object is a legitimate function.


--- Function: *fmakunbound* symbol


  This function makes symbol's function cell void, so that a subsequent attempt to access this cell will cause a =void-function= error. It returns symbol. (See also =makunbound=, in [[file:///home/gaowei/Desktop/elisp-manual.html#Void-Variables][Void Variables]].)

  #+begin_src elisp
                (defun foo (x) x)
                (foo 1)
                     ⇒1
                (fmakunbound 'foo)
                     ⇒ foo
                (foo 1)
                error--> Symbol's function definition is void: foo
  #+end_src


--- Function: *fset* symbol definition


  This function stores definition in the function cell of symbol. The result is definition. Normally definition should be a function or the name of a function, but this is not checked. The argument symbol is an ordinary evaluated argument.

  The primary use of this function is as a subroutine by constructs that define or alter functions, like =defun= or =advice-add= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]). You can also use it to give a symbol a function definition that is not a function, e.g., a keyboard macro (see [[file:///home/gaowei/Desktop/elisp-manual.html#Keyboard-Macros][Keyboard Macros]]):

  #+begin_src elisp
                ;; Define a named keyboard macro.
                (fset 'kill-two-lines "\^u2\^k")
                     ⇒ "\^u2\^k"
  #+end_src

  It you wish to use =fset= to make an alternate name for a function, consider using =defalias= instead. See [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-defalias][Definition of defalias]].


Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Cells][Function Cells]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.10 Closures
    :PROPERTIES:
    :CUSTOM_ID: closures
    :END:

As explained in [[file:///home/gaowei/Desktop/elisp-manual.html#Variable-Scoping][Variable Scoping]], Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with =defun=), as well as any anonymous function that you create using the =lambda= macro or the =function= special form or the =#'= syntax (see [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]]), is automatically converted into a closure.

A closure is a function that also carries a record of the lexical environment that existed when the function was defined. When it is invoked, any lexical variable references within its definition use the retained lexical environment. In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions.

See [[file:///home/gaowei/Desktop/elisp-manual.html#Lexical-Binding][Lexical Binding]], for an example of using a closure.

Currently, an Emacs Lisp closure object is represented by a list with the symbol =closure= as the first element, a list representing the lexical environment as the second element, and the argument list and body forms as the remaining elements:

#+begin_src elisp
         ;; lexical binding is enabled.
         (lambda (x) (* x x))
              ⇒ (closure (t) (x) (* x x))
#+end_src
# 洞见, lambda就是closure
However, the fact that the internal structure of a closure is exposed to the rest of the Lisp world is considered an internal implementation detail. For this reason, we recommend against directly examining or altering the structure of closure objects.

* 13.11 Advising Emacs Lisp Functions
    :PROPERTIES:
    :CUSTOM_ID: advising-emacs-lisp-functions
    :END:

When you need to modify a function defined in another library, or when you need to modify a hook like foo=-function=, a process filter, or basically any variable or object field which holds a function value, you can use the appropriate setter function, such as =fset= or =defun= for named functions, =setq= for hook variables, or =set-process-filter= for process filters, but those are often too blunt, completely throwing away the previous value.

The advice feature lets you add to the existing definition of a function, by advising the function. This is a cleaner method than redefining the whole function.

Emacs's advice system provides two sets of primitives for that: the core set, for function values held in variables and object fields (with the corresponding primitives being =add-function= and =remove-function=) and another set layered on top of it for named functions (with the main primitives being =advice-add= and =advice-remove=).

For example, in order to trace the calls to the process filter of a process proc, you could use:

#+begin_src elisp
         (defun my-tracing-function (proc string)
           (message "Proc %S received %S" proc string))

         (add-function :before (process-filter proc) #'my-tracing-function)
#+end_src

This will cause the process's output to be passed to =my-tracing-function= before being passed to the original process filter. =my-tracing-function= receives the same arguments as the original function. When you're done with it, you can revert to the untraced behavior with:

#+begin_src elisp
         (remove-function (process-filter proc) #'my-tracing-function)
#+end_src

Similarly, if you want to trace the execution of the function named =display-buffer=, you could use:

#+begin_src elisp
         (defun his-tracing-function (orig-fun &rest args)
           (message "display-buffer called with args %S" args)
           (let ((res (apply orig-fun args)))
             (message "display-buffer returned %S" res)
             res))

         (advice-add 'display-buffer :around #'his-tracing-function)
#+end_src

Here, =his-tracing-function= is called instead of the original function and receives the original function (additionally to that function's arguments) as argument, so it can call it if and when it needs to. When you're tired of seeing this output, you can revert to the untraced behavior with:

#+begin_src elisp
         (advice-remove 'display-buffer #'his-tracing-function)
#+end_src

The arguments =:before= and =:around= used in the above examples specify how the two functions are composed, since there are many different ways to do it. The added function is also called a piece of /advice/.

- [[file:///home/gaowei/Desktop/elisp-manual.html#Core-Advising-Primitives][Core Advising Primitives]]: Primitives to manipulate advice.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Named-Functions][Advising Named Functions]]: Advising named functions.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Advice-combinators][Advice combinators]]: Ways to compose advice.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Porting-old-advice][Porting old advice]]: Adapting code using the old defadvice.


** 13.11.1 Primitives to manipulate advices
     :PROPERTIES:
     :CUSTOM_ID: primitives-to-manipulate-advices
     :END:

--- Macro: *add-function* where place function &optional props


  This macro is the handy way to add the advice function to the function stored in place (see [[file:///home/gaowei/Desktop/elisp-manual.html#Generalized-Variables][Generalized Variables]]).

  where determines how function is composed with the existing function, e.g., whether function should be called before, or after the original function. See [[file:///home/gaowei/Desktop/elisp-manual.html#Advice-combinators][Advice combinators]], for the list of available ways to compose the two functions.

  When modifying a variable (whose name will usually end with =-function=), you can choose whether function is used globally or only in the current buffer: if place is just a symbol, then function is added to the global value of place. Whereas if place is of the form =(local=symbol=)=, where symbol is an expression which returns the variable name, then function will only be added in the current buffer. Finally, if you want to modify a lexical variable, you will have to use =(var=variable=)=.

  Every function added with =add-function= can be accompanied by an association list of properties props. Currently only two of those properties have a special meaning:

  - =name=

    This gives a name to the advice, which =remove-function= can use to identify which function to remove. Typically used when function is an anonymous function.

  - =depth=

    This specifies how to order the advice, should several pieces of advice be present. By default, the depth is 0. A depth of 100 indicates that this piece of advice should be kept as deep as possible, whereas a depth of −100 indicates that it should stay as the outermost piece. When two pieces of advice specify the same depth, the most recently added one will be outermost. For =:before= advice, being outermost means that this advice will be run first, before any other advice, whereas being innermost means that it will run right before the original function, with no other advice run between itself and the original function. Similarly, for =:after= advice innermost means that it will run right after the original function, with no other advice run in between, whereas outermost means that it will be run right at the end after all other advice. An innermost =:override= piece of advice will only override the original function and other pieces of advice will apply to it, whereas an outermost =:override= piece of advice will override not only the original function but all other advice applied to it as well.

  If function is not interactive, then the combined function will inherit the interactive spec, if any, of the original function. Else, the combined function will be interactive and will use the interactive spec of function. One exception: if the interactive spec of function is a function (rather than an expression or a string), then the interactive spec of the combined function will be a call to that function with as sole argument the interactive spec of the original function. To interpret the spec received as argument, use =advice-eval-interactive-spec=.

  Note: The interactive spec of function will apply to the combined function and should hence obey the calling convention of the combined function rather than that of function. In many cases, it makes no difference since they are identical, but it does matter for =:around=, =:filter-args=, and =:filter-return=, where function receives different arguments than the original function stored in place.


--- Macro: *remove-function* place function


  This macro removes function from the function stored in place. This only works if function was added to place using =add-function=.

  function is compared with functions added to place using =equal=, to try and make it work also with lambda expressions. It is additionally compared also with the =name= property of the functions added to place, which can be more reliable than comparing lambda expressions using =equal=.


--- Function: *advice-function-member-p* advice function-def


  Return non-=nil= if advice is already in function-def. Like for =remove-function= above, instead of advice being the actual function, it can also be the =name= of the piece of advice.


--- Function: *advice-function-mapc* f function-def


  Call the function f for every piece of advice that was added to function-def. f is called with two arguments: the advice function and its properties.


--- Function: *advice-eval-interactive-spec* spec


  Evaluate the interactive spec just like an interactive call to a function with such a spec would, and then return the corresponding list of arguments that was built. E.g., =(advice-eval-interactive-spec "r\nP")= will return a list of three elements, containing the boundaries of the region and the current prefix argument.


Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Advice-combinators][Advice combinators]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Core-Advising-Primitives][Core Advising Primitives]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]

** 13.11.2 Advising Named Functions
     :PROPERTIES:
     :CUSTOM_ID: advising-named-functions
     :END:

A common use of advice is for named functions and macros. You could just use =add-function= as in:

#+begin_src elisp
         (add-function :around (symbol-function 'fun) #'his-tracing-function)
#+end_src

But you should use =advice-add= and =advice-remove= for that instead. This separate set of functions to manipulate pieces of advice applied to named functions, offers the following extra features compared to =add-function=: they know how to deal with macros and autoloaded functions, they let =describe-function= preserve the original docstring as well as document the added advice, and they let you add and remove advice before a function is even defined.

=advice-add= can be useful for altering the behavior of existing calls to an existing function without having to redefine the whole function. However, it can be a source of bugs, since existing callers to the function may assume the old behavior, and work incorrectly when the behavior is changed by advice. Advice can also cause confusion in debugging, if the person doing the debugging does not notice or remember that the function has been modified by advice.

For these reasons, advice should be reserved for the cases where you cannot modify a function's behavior in any other way. If it is possible to do the same thing via a hook, that is preferable (see [[file:///home/gaowei/Desktop/elisp-manual.html#Hooks][Hooks]]). If you simply want to change what a particular key does, it may be better to write a new command, and remap the old command's key bindings to the new one (see [[file:///home/gaowei/Desktop/elisp-manual.html#Remapping-Commands][Remapping Commands]]). In particular, Emacs's own source files should not put advice on functions in Emacs. (There are currently a few exceptions to this convention, but we aim to correct them.)

Special forms (see [[file:///home/gaowei/Desktop/elisp-manual.html#Special-Forms][Special Forms]]) cannot be advised, however macros can be advised, in much the same way as functions. Of course, this will not affect code that has already been macro-expanded, so you need to make sure the advice is installed before the macro is expanded.

It is possible to advise a primitive (see [[file:///home/gaowei/Desktop/elisp-manual.html#What-Is-a-Function][What Is a Function]]), but one should typically /not/ do so, for two reasons. Firstly, some primitives are used by the advice mechanism, and advising them could cause an infinite recursion. Secondly, many primitives are called directly from C, and such calls ignore advice; hence, one ends up in a confusing situation where some calls (occurring from Lisp code) obey the advice and other calls (from C code) do not.

--- Macro: *define-advice* symbol (where lambda-list &optional name depth) &rest body


  This macro defines a piece of advice and adds it to the function named symbol. The advice is an anonymous function if name is =nil= or a function named =symbol@name=. See =advice-add= for explanation of other arguments.


--- Function: *advice-add* symbol where function &optional props


  Add the advice function to the named function symbol. where and props have the same meaning as for =add-function= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Core-Advising-Primitives][Core Advising Primitives]]).


--- Function: *advice-remove* symbol function


  Remove the advice function from the named function symbol. function can also be the =name= of a piece of advice.


--- Function: *advice-member-p* function symbol


  Return non-=nil= if the advice function is already in the named function symbol. function can also be the =name= of a piece of advice.


--- Function: *advice-mapc* function symbol


  Call function for every piece of advice that was added to the named function symbol. function is called with two arguments: the advice function and its properties.


Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Porting-old-advice][Porting old advice]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Named-Functions][Advising Named Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]

** 13.11.3 Ways to compose advice
     :PROPERTIES:
     :CUSTOM_ID: ways-to-compose-advice
     :END:

Here are the different possible values for the where argument of =add-function= and =advice-add=, specifying how the advice function and the original function should be composed.

- =:before=

  Call function before the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (apply function r) (apply oldfun r))= =(add-function :before=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function=)= for normal hooks.

- =:after=

  Call function after the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (prog1 (apply oldfun r) (apply function r)))= =(add-function :after=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function='append)= for normal hooks.

- =:override=

  This completely replaces the old function with the new one. The old function can of course be recovered if you later call =remove-function=.

- =:around=

  Call function instead of the old function, but provide the old function as an extra argument to function. This is the most flexible composition. For example, it lets you call the old function with different arguments, or many times, or within a let-binding, or you can sometimes delegate the work to the old function and sometimes override it completely. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (apply function oldfun r))=

- =:before-while=

  Call function before the old function and don't call the old function if function returns =nil=. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (and (apply function r) (apply oldfun r)))= =(add-function :before-while=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function=)= when hookvar is run via =run-hook-with-args-until-failure=.

- =:before-until=

  Call function before the old function and only call the old function if function returns =nil=. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (or (apply function r) (apply oldfun r)))= =(add-function :before-until=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function=)= when hookvar is run via =run-hook-with-args-until-success=.

- =:after-while=

  Call function after the old function and only if the old function returned non-=nil=. Both functions receive the same arguments, and the return value of the composition is the return value of function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (and (apply oldfun r) (apply function r)))= =(add-function :after-while=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function='append)= when hookvar is run via =run-hook-with-args-until-failure=.

- =:after-until=

  Call function after the old function and only if the old function returned =nil=. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (or  (apply oldfun r) (apply function r)))= =(add-function :after-until=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function='append)= when hookvar is run via =run-hook-with-args-until-success=.

- =:filter-args=

  Call function first and use the result (which should be a list) as the new arguments to pass to the old function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (apply oldfun (funcall function r)))=

- =:filter-return=

  Call the old function first and pass the result to function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (funcall function (apply oldfun r)))=

Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Advice-combinators][Advice combinators]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]

** 13.11.4 Adapting code using the old defadvice
     :PROPERTIES:
     :CUSTOM_ID: adapting-code-using-the-old-defadvice
     :END:

A lot of code uses the old =defadvice= mechanism, which is largely made obsolete by the new =advice-add=, whose implementation and semantics is significantly simpler.

An old piece of advice such as:

#+begin_src elisp
         (defadvice previous-line (before next-line-at-end
                                          (&optional arg try-vscroll))
           "Insert an empty line when moving up from the top line."
           (if (and next-line-add-newlines (= arg 1)
                    (save-excursion (beginning-of-line) (bobp)))
               (progn
                 (beginning-of-line)
                 (newline))))
#+end_src

could be translated in the new advice mechanism into a plain function:

#+begin_src elisp
         (defun previous-line--next-line-at-end (&optional arg try-vscroll)
           "Insert an empty line when moving up from the top line."
           (if (and next-line-add-newlines (= arg 1)
                    (save-excursion (beginning-of-line) (bobp)))
               (progn
                 (beginning-of-line)
                 (newline))))
#+end_src

Obviously, this does not actually modify =previous-line=. For that the old advice needed:

#+begin_src elisp
         (ad-activate 'previous-line)
#+end_src

whereas the new advice mechanism needs:

#+begin_src elisp
         (advice-add 'previous-line :before #'previous-line--next-line-at-end)
#+end_src

Note that =ad-activate= had a global effect: it activated all pieces of advice enabled for that specified function. If you wanted to only activate or deactivate a particular piece, you needed to /enable/ or /disable/ it with =ad-enable-advice= and =ad-disable-advice=. The new mechanism does away with this distinction.

Around advice such as:

#+begin_src elisp
         (defadvice foo (around foo-around)
           "Ignore case in `foo'."
           (let ((case-fold-search t))
             ad-do-it))
         (ad-activate 'foo)
#+end_src

could translate into:

#+begin_src elisp
         (defun foo--foo-around (orig-fun &rest args)
           "Ignore case in `foo'."
           (let ((case-fold-search t))
             (apply orig-fun args)))
         (advice-add 'foo :around #'foo--foo-around)
#+end_src

Regarding the advice's /class/, note that the new =:before= is not quite equivalent to the old =before=, because in the old advice you could modify the function's arguments (e.g., with =ad-set-arg=), and that would affect the argument values seen by the original function, whereas in the new =:before=, modifying an argument via =setq= in the advice has no effect on the arguments seen by the original function. When porting =before= advice which relied on this behavior, you'll need to turn it into new =:around= or =:filter-args= advice instead.

Similarly old =after= advice could modify the returned value by changing =ad-return-value=, whereas new =:after= advice cannot, so when porting such old =after= advice, you'll need to turn it into new =:around= or =:filter-return= advice instead.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Inline-Functions][Inline Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.12 Declaring Functions Obsolete
    :PROPERTIES:
    :CUSTOM_ID: declaring-functions-obsolete
    :END:

You can mark a named function as obsolete, meaning that it may be removed at some point in the future. This causes Emacs to warn that the function is obsolete whenever it byte-compiles code containing that function, and whenever it displays the documentation for that function. In all other respects, an obsolete function behaves like any other function.

The easiest way to mark a function as obsolete is to put a =(declare (obsolete ...))= form in the function's =defun= definition. See [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]]. Alternatively, you can use the =make-obsolete= function, described below.

A macro (see [[file:///home/gaowei/Desktop/elisp-manual.html#Macros][Macros]]) can also be marked obsolete with =make-obsolete=; this has the same effects as for a function. An alias for a function or macro can also be marked as obsolete; this makes the alias itself obsolete, not the function or macro which it resolves to.

--- Function: *make-obsolete* obsolete-name current-name &optional when


  This function marks obsolete-name as obsolete. obsolete-name should be a symbol naming a function or macro, or an alias for a function or macro.

  If current-name is a symbol, the warning message says to use current-name instead of obsolete-name. current-name does not need to be an alias for obsolete-name; it can be a different function with similar functionality. current-name can also be a string, which serves as the warning message. The message should begin in lower case, and end with a period. It can also be =nil=, in which case the warning message provides no additional details.

  If provided, when should be a string indicating when the function was first made obsolete---for example, a date or a release number.


--- Macro: *define-obsolete-function-alias* obsolete-name current-name &optional when doc


  This convenience macro marks the function obsolete-name obsolete and also defines it as an alias for the function current-name. It is equivalent to the following:

  #+begin_src elisp
                (defalias obsolete-name current-name doc)
                (make-obsolete obsolete-name current-name when)
  #+end_src


In addition, you can mark a particular calling convention for a function as obsolete:

--- Function: *set-advertised-calling-convention* function signature when


  This function specifies the argument list signature as the correct way to call function. This causes the Emacs byte compiler to issue a warning whenever it comes across an Emacs Lisp program that calls function any other way (however, it will still allow the code to be byte compiled). when should be a string indicating when the variable was first made obsolete (usually a version number string).

  For instance, in old versions of Emacs the =sit-for= function accepted three arguments, like this

  #+begin_src elisp
                  (sit-for seconds milliseconds nodisp)
  #+end_src

  However, calling =sit-for= this way is considered obsolete (see [[file:///home/gaowei/Desktop/elisp-manual.html#Waiting][Waiting]]). The old calling convention is deprecated like this:

  #+begin_src elisp
                (set-advertised-calling-convention
                  'sit-for '(seconds &optional nodisp) "22.1")
  #+end_src


Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.13 Inline Functions
    :PROPERTIES:
    :CUSTOM_ID: inline-functions
    :END:

An inline function is a function that works just like an ordinary function, except for one thing: when you byte-compile a call to the function (see [[file:///home/gaowei/Desktop/elisp-manual.html#Byte-Compilation][Byte Compilation]]), the function's definition is expanded into the caller. To define an inline function, use =defsubst= instead of =defun=.

--- Macro: *defsubst* name args [doc] [declare] [interactive] body...


  This macro defines an inline function. Its syntax is exactly the same as =defun= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]]).


Making a function inline often makes its function calls run faster. But it also has disadvantages. For one thing, it reduces flexibility; if you change the definition of the function, calls already inlined still use the old definition until you recompile them.

Another disadvantage is that making a large function inline can increase the size of compiled code both in files and in memory. Since the speed advantage of inline functions is greatest for small functions, you generally should not make large functions inline.

Also, inline functions do not behave well with respect to debugging, tracing, and advising (see [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]). Since ease of debugging and the flexibility of redefining functions are important features of Emacs, you should not make a function inline, even if it's small, unless its speed is really crucial, and you've timed the code to verify that using =defun= actually has performance problems.

After an inline function is defined, its inline expansion can be performed later on in the same file, just like macros.

It's possible to use =defmacro= to define a macro to expand into the same code that an inline function would execute (see [[file:///home/gaowei/Desktop/elisp-manual.html#Macros][Macros]]). But the macro would be limited to direct use in expressions---a macro cannot be called with =apply=, =mapcar= and so on. Also, it takes some work to convert an ordinary function into a macro. To convert it into an inline function is easy; just replace =defun= with =defsubst=. Since each argument of an inline function is evaluated exactly once, you needn't worry about how many times the body uses the arguments, as you do for macros.

As an alternative to =defsubst=, you can use =define-inline= to define functions via their exhaustive compiler macro. See [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][define-inline]].

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Declaring-Functions][Declaring Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Inline-Functions][Inline Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.14 The =declare= Form
    :PROPERTIES:
    :CUSTOM_ID: the-declare-form
    :END:

=declare= is a special macro which can be used to add meta properties to a function or macro: for example, marking it as obsolete, or giving its forms a special indentation convention in Emacs Lisp mode.

--- Macro: *declare* specs...


  This macro ignores its arguments and evaluates to =nil=; it has no run-time effect. However, when a =declare= form occurs in the declare argument of a =defun= or =defsubst= function definition (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]]) or a =defmacro= macro definition (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Macros][Defining Macros]]), it appends the properties specified by specs to the function or macro. This work is specially performed by =defun=, =defsubst=, and =defmacro=.

  Each element in specs should have the form =(=property args=...)=, which should not be quoted. These have the following effects:

  - =(advertised-calling-convention=signature when=)=

    This acts like a call to =set-advertised-calling-convention= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]]); signature specifies the correct argument list for calling the function or macro, and when should be a string indicating when the old argument list was first made obsolete.

  - =(debug=edebug-form-spec=)=

    This is valid for macros only. When stepping through the macro with Edebug, use edebug-form-spec. See [[file:///home/gaowei/Desktop/elisp-manual.html#Instrumenting-Macro-Calls][Instrumenting Macro Calls]].

  - =(doc-string=n=)=

    This is used when defining a function or macro which itself will be used to define entities like functions, macros, or variables. It indicates that the nth argument, if any, should be considered as a documentation string.

  - =(indent=indent-spec=)=

    Indent calls to this function or macro according to indent-spec. This is typically used for macros, though it works for functions too. See [[file:///home/gaowei/Desktop/elisp-manual.html#Indenting-Macros][Indenting Macros]].

  - =(interactive-only=value=)=

    Set the function's =interactive-only= property to value. See [[file:///home/gaowei/Desktop/elisp-manual.html#The-interactive_002donly-property][The interactive-only property]].

  - =(obsolete=current-name when=)=

    Mark the function or macro as obsolete, similar to a call to =make-obsolete= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]]). current-name should be a symbol (in which case the warning message says to use that instead), a string (specifying the warning message), or =nil= (in which case the warning message gives no extra details). when should be a string indicating when the function or macro was first made obsolete.

  - =(compiler-macro=expander=)=

    This can only be used for functions, and tells the compiler to use expander as an optimization function. When encountering a call to the function, of the form =(=function args=...)=, the macro expander will call expander with that form as well as with args..., and expander can either return a new expression to use instead of the function call, or it can return just the form unchanged, to indicate that the function call should be left alone. expander can be a symbol, or it can be a form =(lambda (=arg=)=body=)= in which case arg will hold the original function call expression, and the (unevaluated) arguments to the function can be accessed using the function's formal arguments.

  - =(gv-expander=expander=)=

    Declare expander to be the function to handle calls to the macro (or function) as a generalized variable, similarly to =gv-define-expander=. expander can be a symbol or it can be of the form =(lambda (=arg=)=body=)= in which case that function will additionally have access to the macro (or function)'s arguments.

  - =(gv-setter=setter=)=

    Declare setter to be the function to handle calls to the macro (or function) as a generalized variable. setter can be a symbol in which case it will be passed to =gv-define-simple-setter=, or it can be of the form =(lambda (=arg=)=body=)= in which case that function will additionally have access to the macro (or function)'s arguments and it will passed to =gv-define-setter=.



Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Safety][Function Safety]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.15 Telling the Compiler that a Function is Defined
    :PROPERTIES:
    :CUSTOM_ID: telling-the-compiler-that-a-function-is-defined
    :END:

Byte-compiling a file often produces warnings about functions that the compiler doesn't know about (see [[file:///home/gaowei/Desktop/elisp-manual.html#Compiler-Errors][Compiler Errors]]). Sometimes this indicates a real problem, but usually the functions in question are defined in other files which would be loaded if that code is run. For example, byte-compiling simple.el used to warn:

#+begin_src elisp
         simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be
             defined.
#+end_src

In fact, =shell-mode= is used only in a function that executes =(require 'shell)= before calling =shell-mode=, so =shell-mode= will be defined properly at run-time. When you know that such a warning does not indicate a real problem, it is good to suppress the warning. That makes new warnings which might mean real problems more visible. You do that with =declare-function=.

All you need to do is add a =declare-function= statement before the first use of the function in question:

#+begin_src elisp
         (declare-function shell-mode "shell" ())
#+end_src

This says that =shell-mode= is defined in shell.el (the '.el' can be omitted). The compiler takes for granted that that file really defines the function, and does not check.

The optional third argument specifies the argument list of =shell-mode=. In this case, it takes no arguments (=nil= is different from not specifying a value). In other cases, this might be something like =(file &optional overwrite)=. You don't have to specify the argument list, but if you do the byte compiler can check that the calls match the declaration.

--- Macro: *declare-function* function file &optional arglist fileonly


  Tell the byte compiler to assume that function is defined in the file file. The optional third argument arglist is either =t=, meaning the argument list is unspecified, or a list of formal parameters in the same style as =defun=. An omitted arglist defaults to =t=, not =nil=; this is atypical behavior for omitted arguments, and it means that to supply a fourth but not third argument one must specify =t= for the third-argument placeholder instead of the usual =nil=. The optional fourth argument fileonly non-=nil= means check only that file exists, not that it actually defines function.


To verify that these functions really are declared where =declare-function= says they are, use =check-declare-file= to check all =declare-function= calls in one source file, or use =check-declare-directory= check all the files in and under a certain directory.

These commands find the file that ought to contain a function's definition using =locate-library=; if that finds no file, they expand the definition file name relative to the directory of the file that contains the =declare-function= call.

You can also say that a function is a primitive by specifying a file name ending in '.c' or '.m'. This is useful only when you call a primitive that is defined only on certain systems. Most primitives are always defined, so they will never give you a warning.

Sometimes a file will optionally use functions from an external package. If you prefix the filename in the =declare-function= statement with 'ext:', then it will be checked if it is found, otherwise skipped without error.

There are some function definitions that 'check-declare' does not understand (e.g., =defstruct= and some other macros). In such cases, you can pass a non-=nil= fileonly argument to =declare-function=, meaning to only check that the file exists, not that it actually defines the function. Note that to do this without having to specify an argument list, you should set the arglist argument to =t= (because =nil= means an empty argument list, as opposed to an unspecified one).

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Related-Topics][Related Topics]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Declaring-Functions][Declaring Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.16 Determining whether a Function is Safe to Call
    :PROPERTIES:
    :CUSTOM_ID: determining-whether-a-function-is-safe-to-call
    :END:

Some major modes, such as SES, call functions that are stored in user files. (see [[https://www.gnu.org/software/emacs/manual/html_mono/ses.html#Top][Top]], for more information on SES.) User files sometimes have poor pedigrees---you can get a spreadsheet from someone you've just met, or you can get one through email from someone you've never met. So it is risky to call a function whose source code is stored in a user file until you have determined that it is safe.

--- Function: *unsafep* form &optional unsafep-vars


  Returns =nil= if form is a safe Lisp expression, or returns a list that describes why it might be unsafe. The argument unsafep-vars is a list of symbols known to have temporary bindings at this point; it is mainly used for internal recursive calls. The current buffer is an implicit argument, which provides a list of buffer-local bindings.


Being quick and simple, =unsafep= does a very light analysis and rejects many Lisp expressions that are actually safe. There are no known cases where =unsafep= returns =nil= for an unsafe expression. However, a safe Lisp expression can return a string with a =display= property, containing an associated Lisp expression to be executed after the string is inserted into a buffer. This associated expression can be a virus. In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers.

Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Safety][Function Safety]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

* 13.17 Other Topics Related to Functions
    :PROPERTIES:
    :CUSTOM_ID: other-topics-related-to-functions
    :END:

Here is a table of several functions that do things related to function calling and function definitions. They are documented elsewhere, but we provide cross references here.

- =apply=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]].

- =autoload=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Autoload][Autoload]].

- =call-interactively=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]].

- =called-interactively-p=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Distinguish-Interactive][Distinguish Interactive]].

- =commandp=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]].

- =documentation=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Accessing-Documentation][Accessing Documentation]].

- =eval=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Eval][Eval]].

- =funcall=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]].

- =function=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]].

- =ignore=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]].

- =indirect-function=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Indirection][Function Indirection]].

- =interactive=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Using-Interactive][Using Interactive]].

- =interactive-p=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Distinguish-Interactive][Distinguish Interactive]].

- =mapatoms=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Creating-Symbols][Creating Symbols]].

- =mapcar=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]].

- =map-char-table=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Char_002dTables][Char-Tables]].

- =mapconcat=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]].

- =undefined=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Functions-for-Key-Lookup][Functions for Key Lookup]].

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Customization][Customization]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Top][Top]]

