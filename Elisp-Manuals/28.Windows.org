#+TITLE: 28.Windows
* 28 Windows
   :PROPERTIES:
   :CUSTOM_ID: windows
   :END:

This chapter describes the functions and variables related to Emacs windows. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frames][Frames]], for how windows are assigned an area of screen available for Emacs to use. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Display][Display]], for information on how text is displayed in windows.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Windows][Basic Windows]]: Basic information on using windows.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]: Relating windows to the frame they appear on.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Sizes][Window Sizes]]: Accessing a window's size.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]]: Changing the sizes of windows.
5) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]]: Preserving the size of windows.
6) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]]: Creating a new window.
7) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]: Removing a window from its frame.
8) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recombining-Windows][Recombining Windows]]: Preserving the frame layout when splitting and deleting windows.
9) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Selecting-Windows][Selecting Windows]]: The selected window is the one that you edit in.
10) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]: Moving around the existing windows.
11) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]]: Each window displays the contents of a buffer.
12) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]]: Higher-level functions for switching to a buffer.
13) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]]: Displaying a buffer in a suitable window.
14) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]]: Each window remembers the buffers displayed in it.
15) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]: How to avoid displaying another buffer in a specific window.
16) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]]: How to restore the state prior to displaying a buffer.
17) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]: Special windows on a frame's sides.
18) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]]: Preserving parts of the window layout.
19) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Point][Window Point]]: Each window has its own location of point.
20) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Start-and-End][Window Start and End]]: Buffer positions indicating which text is on-screen in a window.
21) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Textual-Scrolling][Textual Scrolling]]: Moving text up and down through the window.
22) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vertical-Scrolling][Vertical Scrolling]]: Moving the contents up and down on the window.
23) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Horizontal-Scrolling][Horizontal Scrolling]]: Moving the contents sideways on the window.
24) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Coordinates-and-Windows][Coordinates and Windows]]: Converting coordinates to windows.
25) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mouse-Window-Auto_002dselection][Mouse Window Auto-selection]]: Automatically selecting windows with the mouse.
26) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]]: Saving and restoring the state of the screen.
27) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]]: Associating additional information with windows.
28) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Hooks][Window Hooks]]: Hooks for scrolling, window size changes, redisplay going past a certain point, or window configuration changes.
* 28.1 Basic Concepts of Emacs Windows
    :PROPERTIES:
    :CUSTOM_ID: basic-concepts-of-emacs-windows
    :END:

A window is an area of the screen that is used to display a buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]). In Emacs Lisp, windows are represented by a special Lisp object type.

Windows are grouped into frames (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frames][Frames]]). Each frame contains at least one window; the user can subdivide it into multiple, non-overlapping windows to view several buffers at once. Lisp programs can use multiple windows for a variety of purposes. In Rmail, for example, you can view a summary of message titles in one window, and the contents of the selected message in another window.

Emacs uses the word "window" with a different meaning than in graphical desktop environments and window systems, such as the X Window System. When Emacs is run on X, each of its graphical X windows is an Emacs frame (containing one or more Emacs windows). When Emacs is run on a text terminal, the frame fills the entire terminal screen.

Unlike X windows, Emacs windows are tiled; they never overlap within the area of the frame. When a window is created, resized, or deleted, the change in window space is taken from or given to the adjacent windows, so that the total area of the frame is unchanged.

--- Function: *windowp* object

#+BEGIN_QUOTE
  This function returns =t= if object is a window (whether or not it displays a buffer). Otherwise, it returns =nil=.
#+END_QUOTE

A live window is one that is actually displaying a buffer in a frame.

--- Function: *window-live-p* object

#+BEGIN_QUOTE
  This function returns =t= if object is a live window and =nil= otherwise. A live window is one that displays a buffer.
#+END_QUOTE

The windows in each frame are organized into a window tree. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]. The leaf nodes of each window tree are live windows---the ones actually displaying buffers. The internal nodes of the window tree are internal windows, which are not live.

A valid window is one that is either live or internal. A valid window can be deleted, i.e., removed from its frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]); then it is no longer valid, but the Lisp object representing it might be still referenced from other Lisp objects. A deleted window may be made valid again by restoring a saved window configuration (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]]).

You can distinguish valid windows from deleted windows with =window-valid-p=.

--- Function: *window-valid-p* object

#+BEGIN_QUOTE
  This function returns =t= if object is a live window, or an internal window in a window tree. Otherwise, it returns =nil=, including for the case where object is a deleted window.
#+END_QUOTE

In each frame, at any time, exactly one Emacs window is designated as selected within the frame. For the selected frame, that window is called the selected window---the one in which most editing takes place, and in which the cursor for selected windows appears (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cursor-Parameters][Cursor Parameters]]). Keyboard input that inserts or deletes text is also normally directed to this window. The selected window's buffer is usually also the current buffer, except when =set-buffer= has been used (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Current-Buffer][Current Buffer]]). As for non-selected frames, the window selected within the frame becomes the selected window if the frame is ever selected. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Selecting-Windows][Selecting Windows]].

--- Function: *selected-window*

#+BEGIN_QUOTE
  This function returns the selected window (which is always a live window).
#+END_QUOTE

Sometimes several windows collectively and cooperatively display a buffer, for example, under the management of Follow Mode (see [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Follow-Mode][Follow Mode]]), where the windows together display a bigger portion of the buffer than one window could alone. It is often useful to consider such a window group as a single entity. Several functions such as =window-group-start= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Start-and-End][Window Start and End]]) allow you to do this by supplying, as an argument, one of the windows as a stand in for the whole group.

--- Function: *selected-window-group*

#+BEGIN_QUOTE
  When the selected window is a member of a group of windows, this function returns a list of the windows in the group, ordered such that the first window in the list is displaying the earliest part of the buffer, and so on. Otherwise the function returns a list containing just the selected window.

  The selected window is considered part of a group when the buffer local variable =selected-window-group-function= is set to a function. In this case, =selected-window-group= calls it with no arguments and returns its result (which should be the list of windows in the group).
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Sizes][Window Sizes]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Windows][Basic Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.2 Windows and Frames
    :PROPERTIES:
    :CUSTOM_ID: windows-and-frames
    :END:

Each window belongs to exactly one frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frames][Frames]]).

--- Function: *window-frame* &optional window

#+BEGIN_QUOTE
  This function returns the frame that the window window belongs to. If window is =nil=, it defaults to the selected window.
#+END_QUOTE

--- Function: *window-list* &optional frame minibuffer window

#+BEGIN_QUOTE
  This function returns a list of live windows belonging to the frame frame. If frame is omitted or =nil=, it defaults to the selected frame.

  The optional argument minibuffer specifies whether to include the minibuffer window in the returned list. If minibuffer is =t=, the minibuffer window is included. If minibuffer is =nil= or omitted, the minibuffer window is included only if it is active. If minibuffer is neither =nil= nor =t=, the minibuffer window is never included.

  The optional argument window, if non-=nil=, should be a live window on the specified frame; then window will be the first element in the returned list. If window is omitted or =nil=, the window selected within the frame is the first element.
#+END_QUOTE

Windows in the same frame are organized into a window tree, whose leaf nodes are the live windows. The internal nodes of a window tree are not live; they exist for the purpose of organizing the relationships between live windows. The root node of a window tree is called the root window. It can be either a live window (if the frame has just one window), or an internal window.

A minibuffer window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Windows][Minibuffer Windows]]) that is not alone on its frame does not have a parent window, so it strictly speaking is not part of its frame's window tree. Nonetheless, it is a sibling window of the frame's root window, and thus can be reached via =window-next-sibling=. Also, the function =window-tree= described at the end of this section lists the minibuffer window alongside the actual window tree.

--- Function: *frame-root-window* &optional frame-or-window

#+BEGIN_QUOTE
  This function returns the root window for frame-or-window. The argument frame-or-window should be either a window or a frame; if omitted or =nil=, it defaults to the selected frame. If frame-or-window is a window, the return value is the root window of that window's frame.
#+END_QUOTE

When a window is split, there are two live windows where previously there was one. One of these is represented by the same Lisp window object as the original window, and the other is represented by a newly-created Lisp window object. Both of these live windows become leaf nodes of the window tree, as child windows of a single internal window. If necessary, Emacs automatically creates this internal window, which is also called the parent window, and assigns it to the appropriate position in the window tree. A set of windows that share the same parent are called siblings.

--- Function: *window-parent* &optional window

#+BEGIN_QUOTE
  This function returns the parent window of window. If window is omitted or =nil=, it defaults to the selected window. The return value is =nil= if window has no parent (i.e., it is a minibuffer window or the root window of its frame).
#+END_QUOTE

Each internal window always has at least two child windows. If this number falls to one as a result of window deletion, Emacs automatically deletes the internal window, and its sole remaining child window takes its place in the window tree.

Each child window can be either a live window, or an internal window (which in turn would have its own child windows). Therefore, each internal window can be thought of as occupying a certain rectangular screen area---the union of the areas occupied by the live windows that are ultimately descended from it.

For each internal window, the screen areas of the immediate children are arranged either vertically or horizontally (never both). If the child windows are arranged one above the other, they are said to form a vertical combination; if they are arranged side by side, they are said to form a horizontal combination. Consider the following example:

#+BEGIN_EXAMPLE
              ______________________________________
             | ______  ____________________________ |
             ||      || __________________________ ||
             ||      |||                          |||
             ||      |||                          |||
             ||      |||                          |||
             ||      |||____________W4____________|||
             ||      || __________________________ ||
             ||      |||                          |||
             ||      |||                          |||
             ||      |||____________W5____________|||
             ||__W2__||_____________W3_____________ |
             |__________________W1__________________|
#+END_EXAMPLE

The root window of this frame is an internal window, W1. Its child windows form a horizontal combination, consisting of the live window W2 and the internal window W3. The child windows of W3 form a vertical combination, consisting of the live windows W4 and W5. Hence, the live windows in this window tree are W2, W4, and W5.

The following functions can be used to retrieve a child window of an internal window, and the siblings of a child window.

--- Function: *window-top-child* &optional window

#+BEGIN_QUOTE
  This function returns the topmost child window of window, if window is an internal window whose children form a vertical combination. For any other type of window, the return value is =nil=.
#+END_QUOTE

--- Function: *window-left-child* &optional window

#+BEGIN_QUOTE
  This function returns the leftmost child window of window, if window is an internal window whose children form a horizontal combination. For any other type of window, the return value is =nil=.
#+END_QUOTE

--- Function: *window-child* window

#+BEGIN_QUOTE
  This function returns the first child window of the internal window window---the topmost child window for a vertical combination, or the leftmost child window for a horizontal combination. If window is a live window, the return value is =nil=.
#+END_QUOTE

--- Function: *window-combined-p* &optional window horizontal

#+BEGIN_QUOTE
  This function returns a non-=nil= value if and only if window is part of a vertical combination. If window is omitted or =nil=, it defaults to the selected one.

  If the optional argument horizontal is non-=nil=, this means to return non-=nil= if and only if window is part of a horizontal combination.
#+END_QUOTE

--- Function: *window-next-sibling* &optional window

#+BEGIN_QUOTE
  This function returns the next sibling of the window window. If omitted or =nil=, window defaults to the selected window. The return value is =nil= if window is the last child of its parent.
#+END_QUOTE

--- Function: *window-prev-sibling* &optional window

#+BEGIN_QUOTE
  This function returns the previous sibling of the window window. If omitted or =nil=, window defaults to the selected window. The return value is =nil= if window is the first child of its parent.
#+END_QUOTE

The functions =window-next-sibling= and =window-prev-sibling= should not be confused with the functions =next-window= and =previous-window=, which return the next and previous window, respectively, in the cyclic ordering of windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]).

The following functions can be useful to locate a window within its frame.

--- Function: *frame-first-window* &optional frame-or-window

#+BEGIN_QUOTE
  This function returns the live window at the upper left corner of the frame specified by frame-or-window. The argument frame-or-window must denote a window or a live frame and defaults to the selected frame. If frame-or-window specifies a window, this function returns the first window on that window's frame. Under the assumption that the frame from our canonical example is selected =(frame-first-window)= returns W2.
#+END_QUOTE

--- Function: *window-at-side-p* &optional window side

#+BEGIN_QUOTE
  This function returns =t= if window is located at side of its containing frame. The argument window must be a valid window and defaults to the selected one. The argument side can be any of the symbols =left=, =top=, =right= or =bottom=. The default value =nil= is handled like =bottom=.

  Note that this function disregards the minibuffer window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Windows][Minibuffer Windows]]). Hence, with side equal to =bottom= it may return =t= also when the minibuffer window appears right below window.
#+END_QUOTE

--- Function: *window-in-direction* direction &optional window ignore sign wrap mini

#+BEGIN_QUOTE
  This function returns the nearest live window in direction direction as seen from the position of =window-point= in window window. The argument direction must be one of =above=, =below=, =left= or =right=. The optional argument window must denote a live window and defaults to the selected one.

  This function does not return a window whose =no-other-window= parameter is non-=nil= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]]). If the nearest window's =no-other-window= parameter is non-=nil=, this function tries to find another window in the indicated direction whose =no-other-window= parameter is =nil=. If the optional argument ignore is non-=nil=, a window may be returned even if its =no-other-window= parameter is non-=nil=.

  If the optional argument sign is a negative number, it means to use the right or bottom edge of window as reference position instead of =window-point=. If sign is a positive number, it means to use the left or top edge of window as reference position.

  If the optional argument wrap is non-=nil=, this means to wrap direction around frame borders. For example, if window is at the top of the frame and direction is =above=, then this function usually returns the frame's minibuffer window if it's active and a window at the bottom of the frame otherwise.

  If the optional argument mini is =nil=, this means to return the minibuffer window if and only if it is currently active. If mini is non-=nil=, this function may return the minibuffer window even when it's not active. However, if wrap is non-=nil=, it always acts as if mini were =nil=.

  If it doesn't find a suitable window, this function returns =nil=.

  Don't use this function to check whether there is /no/ window in direction. Calling =window-at-side-p= described above is a much more efficient way to do that.
#+END_QUOTE

The following function allows the entire window tree of a frame to be retrieved:

--- Function: *window-tree* &optional frame

#+BEGIN_QUOTE
  This function returns a list representing the window tree for frame frame. If frame is omitted or =nil=, it defaults to the selected frame.

  The return value is a list of the form =(=root mini=)=, where root represents the window tree of the frame's root window, and mini is the frame's minibuffer window.

  If the root window is live, root is that window itself. Otherwise, root is a list =(=dir edges w1 w2=...)= where dir is =nil= for a horizontal combination and =t= for a vertical combination, edges gives the size and position of the combination, and the remaining elements are the child windows. Each child window may again be a window object (for a live window) or a list with the same format as above (for an internal window). The edges element is a list =(=left top right bottom=)=, similar to the value returned by =window-edges= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Coordinates-and-Windows][Coordinates and Windows]]).
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.3 Window Sizes
    :PROPERTIES:
    :CUSTOM_ID: window-sizes
    :END:

The following schematic shows the structure of a live window:

#+BEGIN_EXAMPLE
                 ____________________________________________
                |______________ Header Line ______________|RD| ^
              ^ |LS|LM|LF|                       |RF|RM|RS|  | |
              | |  |  |  |                       |  |  |  |  | |
         Window |  |  |  |       Text Area       |  |  |  |  | Window
         Body | |  |  |  |     (Window Body)     |  |  |  |  | Total
         Height |  |  |  |                       |  |  |  |  | Height
              | |  |  |  |<- Window Body Width ->|  |  |  |  | |
              v |__|__|__|_______________________|__|__|__|  | |
                |_________ Horizontal Scroll Bar _________|  | |
                |_______________ Mode Line _______________|__| |
                |_____________ Bottom Divider _______________| v
                 <---------- Window Total Width ------------>
#+END_EXAMPLE

At the center of the window is the text area, or body, where the buffer text is displayed. The text area can be surrounded by a series of optional areas. On the left and right, from innermost to outermost, these are the left and right fringes, denoted by LF and RF (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Fringes][Fringes]]); the left and right margins, denoted by LM and RM in the schematic (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Display-Margins][Display Margins]]); the left or right vertical scroll bar, only one of which is present at any time, denoted by LS and RS (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Scroll-Bars][Scroll Bars]]); and the right divider, denoted by RD (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Dividers][Window Dividers]]). At the top of the window is the header line (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Header-Lines][Header Lines]]). At the bottom of the window are the horizontal scroll bar (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Scroll-Bars][Scroll Bars]]); the mode line (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mode-Line-Format][Mode Line Format]]); and the bottom divider (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Dividers][Window Dividers]]).

Emacs provides miscellaneous functions for finding the height and width of a window. The return value of many of these functions can be specified either in units of pixels or in units of lines and columns. On a graphical display, the latter actually correspond to the height and width of a default character specified by the frame's default font as returned by =frame-char-height= and =frame-char-width= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Font][Frame Font]]). Thus, if a window is displaying text with a different font or size, the reported line height and column width for that window may differ from the actual number of text lines or columns displayed within it.

The total height of a window is the number of lines comprising the window's body, the header line, the horizontal scroll bar, the mode line and the bottom divider (if any).

--- Function: *window-total-height* &optional window round

#+BEGIN_QUOTE
  This function returns the total height, in lines, of the window window. If window is omitted or =nil=, it defaults to the selected window. If window is an internal window, the return value is the total height occupied by its descendant windows.

  If a window's pixel height is not an integral multiple of its frame's default character height, the number of lines occupied by the window is rounded internally. This is done in a way such that, if the window is a parent window, the sum of the total heights of all its child windows internally equals the total height of their parent. This means that although two windows have the same pixel height, their internal total heights may differ by one line. This means also, that if window is vertically combined and has a next sibling, the topmost row of that sibling can be calculated as the sum of this window's topmost row and total height (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Coordinates-and-Windows][Coordinates and Windows]])

  If the optional argument round is =ceiling=, this function returns the smallest integer larger than window's pixel height divided by the character height of its frame; if it is =floor=, it returns the largest integer smaller than said value; with any other round it returns the internal value of windows's total height.
#+END_QUOTE

The total width of a window is the number of lines comprising the window's body, its margins, fringes, scroll bars and a right divider (if any).

--- Function: *window-total-width* &optional window round

#+BEGIN_QUOTE
  This function returns the total width, in columns, of the window window. If window is omitted or =nil=, it defaults to the selected window. If window is internal, the return value is the total width occupied by its descendant windows.

  If a window's pixel width is not an integral multiple of its frame's character width, the number of lines occupied by the window is rounded internally. This is done in a way such that, if the window is a parent window, the sum of the total widths of all its children internally equals the total width of their parent. This means that although two windows have the same pixel width, their internal total widths may differ by one column. This means also, that if this window is horizontally combined and has a next sibling, the leftmost column of that sibling can be calculated as the sum of this window's leftmost column and total width (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Coordinates-and-Windows][Coordinates and Windows]]). The optional argument round behaves as it does for =window-total-height=.
#+END_QUOTE

--- Function: *window-total-size* &optional window horizontal round

#+BEGIN_QUOTE
  This function returns either the total height in lines or the total width in columns of the window window. If horizontal is omitted or =nil=, this is equivalent to calling =window-total-height= for window; otherwise it is equivalent to calling =window-total-width= for window. The optional argument round behaves as it does for =window-total-height=.
#+END_QUOTE

The following two functions can be used to return the total size of a window in units of pixels.

--- Function: *window-pixel-height* &optional window

#+BEGIN_QUOTE
  This function returns the total height of window window in pixels. window must be a valid window and defaults to the selected one.

  The return value includes mode and header line, a horizontal scroll bar and a bottom divider, if any. If window is an internal window, its pixel height is the pixel height of the screen areas spanned by its children.
#+END_QUOTE

--- Function: *window-pixel-height-before-size-change* &optional Lisp\_Object &optional window

#+BEGIN_QUOTE
  This function returns the height of window window in pixels at the time =window-size-change-functions= was run for the last time on window's frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Hooks][Window Hooks]]).
#+END_QUOTE

--- Function: *window-pixel-width* &optional window

#+BEGIN_QUOTE
  This function returns the width of window window in pixels. window must be a valid window and defaults to the selected one.

  The return value includes the fringes and margins of window as well as any vertical dividers or scroll bars belonging to window. If window is an internal window, its pixel width is the width of the screen areas spanned by its children.
#+END_QUOTE

--- Function: *window-pixel-width-before-size-change* &optional Lisp\_Object &optional window

#+BEGIN_QUOTE
  This function returns the width of window window in pixels at the time =window-size-change-functions= was run for the last time on window's frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Hooks][Window Hooks]]).
#+END_QUOTE

The following functions can be used to determine whether a given window has any adjacent windows.

--- Function: *window-full-height-p* &optional window

#+BEGIN_QUOTE
  This function returns non-=nil= if window has no other window above or below it in its frame. More precisely, this means that the total height of window equals the total height of the root window on that frame. The minibuffer window does not count in this regard. If window is omitted or =nil=, it defaults to the selected window.
#+END_QUOTE

--- Function: *window-full-width-p* &optional window

#+BEGIN_QUOTE
  This function returns non-=nil= if window has no other window to the left or right in its frame, i.e., its total width equals that of the root window on that frame. If window is omitted or =nil=, it defaults to the selected window.
#+END_QUOTE

The body height of a window is the height of its text area, which does not include a mode or header line, a horizontal scroll bar, or a bottom divider.

--- Function: *window-body-height* &optional window pixelwise

#+BEGIN_QUOTE
  This function returns the height, in lines, of the body of window window. If window is omitted or =nil=, it defaults to the selected window; otherwise it must be a live window.

  If the optional argument pixelwise is non-=nil=, this function returns the body height of window counted in pixels.

  If pixelwise is =nil=, the return value is rounded down to the nearest integer, if necessary. This means that if a line at the bottom of the text area is only partially visible, that line is not counted. It also means that the height of a window's body can never exceed its total height as returned by =window-total-height=.
#+END_QUOTE

The body width of a window is the width of its text area, which does not include the scroll bar, fringes, margins or a right divider. Note that when one or both fringes are removed (by setting their width to zero), the display engine reserves two character cells, one on each side of the window, for displaying the continuation and truncation glyphs, which leaves 2 columns less for text display. (The function =window-max-chars-per-line=, described below, takes this peculiarity into account.)

--- Function: *window-body-width* &optional window pixelwise

#+BEGIN_QUOTE
  This function returns the width, in columns, of the body of window window. If window is omitted or =nil=, it defaults to the selected window; otherwise it must be a live window.

  If the optional argument pixelwise is non-=nil=, this function returns the body width of window in units of pixels.

  If pixelwise is =nil=, the return value is rounded down to the nearest integer, if necessary. This means that if a column on the right of the text area is only partially visible, that column is not counted. It also means that the width of a window's body can never exceed its total width as returned by =window-total-width=.
#+END_QUOTE

--- Function: *window-body-size* &optional window horizontal pixelwise

#+BEGIN_QUOTE
  This function returns the body height or body width of window. If horizontal is omitted or =nil=, it is equivalent to calling =window-body-height= for window; otherwise it is equivalent to calling =window-body-width=. In either case, the optional argument pixelwise is passed to the function called.
#+END_QUOTE

For compatibility with previous versions of Emacs, =window-height= is an alias for =window-total-height=, and =window-width= is an alias for =window-body-width=. These aliases are considered obsolete and will be removed in the future.

The pixel heights of a window's mode and header line can be retrieved with the functions given below. Their return value is usually accurate unless the window has not been displayed before: In that case, the return value is based on an estimate of the font used for the window's frame.

--- Function: *window-mode-line-height* &optional window

#+BEGIN_QUOTE
  This function returns the height in pixels of window's mode line. window must be a live window and defaults to the selected one. If window has no mode line, the return value is zero.
#+END_QUOTE

--- Function: *window-header-line-height* &optional window

#+BEGIN_QUOTE
  This function returns the height in pixels of window's header line. window must be a live window and defaults to the selected one. If window has no header line, the return value is zero.
#+END_QUOTE

Functions for retrieving the height and/or width of window dividers (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Dividers][Window Dividers]]), fringes (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Fringes][Fringes]]), scroll bars (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Scroll-Bars][Scroll Bars]]), and display margins (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Display-Margins][Display Margins]]) are described in the corresponding sections.

If your Lisp program needs to make layout decisions, you will find the following function useful:

--- Function: *window-max-chars-per-line* &optional window face

#+BEGIN_QUOTE
  This function returns the number of characters displayed in the specified face face in the specified window window (which must be a live window). If face was remapped (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Face-Remapping][Face Remapping]]), the information is returned for the remapped face. If omitted or =nil=, face defaults to the default face, and window defaults to the selected window.

  Unlike =window-body-width=, this function accounts for the actual size of face's font, instead of working in units of the canonical character width of window's frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Font][Frame Font]]). It also accounts for space used by the continuation glyph, if window lacks one or both of its fringes.
#+END_QUOTE

Commands that change the size of windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]]), or split them (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]]), obey the variables =window-min-height= and =window-min-width=, which specify the smallest allowable window height and width. They also obey the variable =window-size-fixed=, with which a window can be fixed in size (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]]).

--- User Option: *window-min-height*

#+BEGIN_QUOTE
  This option specifies the minimum total height, in lines, of any window. Its value has to accommodate at least one text line as well as a mode and header line, a horizontal scroll bar and a bottom divider, if present.
#+END_QUOTE

--- User Option: *window-min-width*

#+BEGIN_QUOTE
  This option specifies the minimum total width, in columns, of any window. Its value has to accommodate two text columns as well as margins, fringes, a scroll bar and a right divider, if present.
#+END_QUOTE

The following function tells how small a specific window can get taking into account the sizes of its areas and the values of =window-min-height=, =window-min-width= and =window-size-fixed= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]]).

--- Function: *window-min-size* &optional window horizontal ignore pixelwise

#+BEGIN_QUOTE
  This function returns the minimum size of window. window must be a valid window and defaults to the selected one. The optional argument horizontal non-=nil= means to return the minimum number of columns of window; otherwise return the minimum number of window's lines.

  The return value makes sure that all components of window remain fully visible if window's size were actually set to it. With horizontal =nil= it includes the mode and header line, the horizontal scroll bar and the bottom divider, if present. With horizontal non-=nil= it includes the margins and fringes, the vertical scroll bar and the right divider, if present.

  The optional argument ignore, if non-=nil=, means ignore restrictions imposed by fixed size windows, =window-min-height= or =window-min-width= settings. If ignore equals =safe=, live windows may get as small as =window-safe-min-height= lines and =window-safe-min-width= columns. If ignore is a window, ignore restrictions for that window only. Any other non-=nil= value means ignore all of the above restrictions for all windows.

  The optional argument pixelwise non-=nil= means to return the minimum size of window counted in pixels.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Sizes][Window Sizes]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.4 Resizing Windows
    :PROPERTIES:
    :CUSTOM_ID: resizing-windows
    :END:

This section describes functions for resizing a window without changing the size of its frame. Because live windows do not overlap, these functions are meaningful only on frames that contain two or more windows: resizing a window also changes the size of a neighboring window. If there is just one window on a frame, its size cannot be changed except by resizing the frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Size][Frame Size]]).

Except where noted, these functions also accept internal windows as arguments. Resizing an internal window causes its child windows to be resized to fit the same space.

--- Function: *window-resizable* window delta &optional horizontal ignore pixelwise

#+BEGIN_QUOTE
  This function returns delta if the size of window can be changed vertically by delta lines. If the optional argument horizontal is non-=nil=, it instead returns delta if window can be resized horizontally by delta columns. It does not actually change the window size.

  If window is =nil=, it defaults to the selected window.

  A positive value of delta means to check whether the window can be enlarged by that number of lines or columns; a negative value of delta means to check whether the window can be shrunk by that many lines or columns. If delta is non-zero, a return value of 0 means that the window cannot be resized.

  Normally, the variables =window-min-height= and =window-min-width= specify the smallest allowable window size (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Sizes][Window Sizes]]). However, if the optional argument ignore is non-=nil=, this function ignores =window-min-height= and =window-min-width=, as well as =window-size-fixed=. Instead, it considers the minimum-height window to be one consisting of a header and a mode line, a horizontal scrollbar and a bottom divider (if any), plus a text area one line tall; and a minimum-width window as one consisting of fringes, margins, a scroll bar and a right divider (if any), plus a text area two columns wide.

  If the optional argument pixelwise is non-=nil=, delta is interpreted as pixels.
#+END_QUOTE

--- Function: *window-resize* window delta &optional horizontal ignore pixelwise

#+BEGIN_QUOTE
  This function resizes window by delta increments. If horizontal is =nil=, it changes the height by delta lines; otherwise, it changes the width by delta columns. A positive delta means to enlarge the window, and a negative delta means to shrink it.

  If window is =nil=, it defaults to the selected window. If the window cannot be resized as demanded, an error is signaled.

  The optional argument ignore has the same meaning as for the function =window-resizable= above.

  If the optional argument pixelwise is non-=nil=, delta will be interpreted as pixels.

  The choice of which window edges this function alters depends on the values of the option =window-combination-resize= and the combination limits of the involved windows; in some cases, it may alter both edges. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recombining-Windows][Recombining Windows]]. To resize by moving only the bottom or right edge of a window, use the function =adjust-window-trailing-edge=.
#+END_QUOTE

--- Function: *adjust-window-trailing-edge* window delta &optional horizontal pixelwise

#+BEGIN_QUOTE
  This function moves window's bottom edge by delta lines. If optional argument horizontal is non-=nil=, it instead moves the right edge by delta columns. If window is =nil=, it defaults to the selected window.

  If the optional argument pixelwise is non-=nil=, delta is interpreted as pixels.

  A positive delta moves the edge downwards or to the right; a negative delta moves it upwards or to the left. If the edge cannot be moved as far as specified by delta, this function moves it as far as possible but does not signal an error.

  This function tries to resize windows adjacent to the edge that is moved. If this is not possible for some reason (e.g., if that adjacent window is fixed-size), it may resize other windows.
#+END_QUOTE

--- User Option: *window-resize-pixelwise*

#+BEGIN_QUOTE
  If the value of this option is non-=nil=, Emacs resizes windows in units of pixels. This currently affects functions like =split-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]]), =maximize-window=, =minimize-window=, =fit-window-to-buffer=, =fit-frame-to-buffer= and =shrink-window-if-larger-than-buffer= (all listed below).

  Note that when a frame's pixel size is not a multiple of its character size, at least one window may get resized pixelwise even if this option is =nil=. The default value is =nil=.
#+END_QUOTE

The following commands resize windows in more specific ways. When called interactively, they act on the selected window.

--- Command: *fit-window-to-buffer* &optional window max-height min-height max-width min-width preserve-size

#+BEGIN_QUOTE
  This command adjusts the height or width of window to fit the text in it. It returns non-=nil= if it was able to resize window, and =nil= otherwise. If window is omitted or =nil=, it defaults to the selected window. Otherwise, it should be a live window.

  If window is part of a vertical combination, this function adjusts window's height. The new height is calculated from the actual height of the accessible portion of its buffer. The optional argument max-height, if non-=nil=, specifies the maximum total height that this function can give window. The optional argument min-height, if non-=nil=, specifies the minimum total height that it can give, which overrides the variable =window-min-height=. Both max-height and min-height are specified in lines and include mode and header line and a bottom divider, if any.

  If window is part of a horizontal combination and the value of the option =fit-window-to-buffer-horizontally= (see below) is non-=nil=, this function adjusts window's width. The new width of window is calculated from the maximum length of its buffer's lines that follow the current start position of window. The optional argument max-width specifies a maximum width and defaults to the width of window's frame. The optional argument min-width specifies a minimum width and defaults to =window-min-width=. Both max-width and min-width are specified in columns and include fringes, margins and scrollbars, if any.

  The optional argument preserve-size, if non-=nil=, will install a parameter to preserve the size of window during future resize operations (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]]).

  If the option =fit-frame-to-buffer= (see below) is non-=nil=, this function will try to resize the frame of window to fit its contents by calling =fit-frame-to-buffer= (see below).
#+END_QUOTE

--- User Option: *fit-window-to-buffer-horizontally*

#+BEGIN_QUOTE
  If this is non-=nil=, =fit-window-to-buffer= can resize windows horizontally. If this is =nil= (the default) =fit-window-to-buffer= never resizes windows horizontally. If this is =only=, it can resize windows horizontally only. Any other value means =fit-window-to-buffer= can resize windows in both dimensions.
#+END_QUOTE

--- User Option: *fit-frame-to-buffer*

#+BEGIN_QUOTE
  If this option is non-=nil=, =fit-window-to-buffer= can fit a frame to its buffer. A frame is fit if and only if its root window is a live window and this option is non-=nil=. If this is =horizontally=, frames are fit horizontally only. If this is =vertically=, frames are fit vertically only. Any other non-=nil= value means frames can be resized in both dimensions.
#+END_QUOTE

If you have a frame that displays only one window, you can fit that frame to its buffer using the command =fit-frame-to-buffer=.

--- Command: *fit-frame-to-buffer* &optional frame max-height min-height max-width min-width only

#+BEGIN_QUOTE
  This command adjusts the size of frame to display the contents of its buffer exactly. frame can be any live frame and defaults to the selected one. Fitting is done only if frame's root window is live. The arguments max-height, min-height, max-width and min-width specify bounds on the new total size of frame's root window. min-height and min-width default to the values of =window-min-height= and =window-min-width= respectively.

  If the optional argument only is =vertically=, this function may resize the frame vertically only. If only is =horizontally=, it may resize the frame horizontally only.
#+END_QUOTE

The behavior of =fit-frame-to-buffer= can be controlled with the help of the two options listed next.

--- User Option: *fit-frame-to-buffer-margins*

#+BEGIN_QUOTE
  This option can be used to specify margins around frames to be fit by =fit-frame-to-buffer=. Such margins can be useful to avoid, for example, that the resized frame overlaps the taskbar or parts of its parent frame.

  It specifies the numbers of pixels to be left free on the left, above, the right, and below a frame that shall be fit. The default specifies =nil= for each which means to use no margins. The value specified here can be overridden for a specific frame by that frame's =fit-frame-to-buffer-margins= parameter, if present.
#+END_QUOTE

--- User Option: *fit-frame-to-buffer-sizes*

#+BEGIN_QUOTE
  This option specifies size boundaries for =fit-frame-to-buffer=. It specifies the total maximum and minimum lines and maximum and minimum columns of the root window of any frame that shall be fit to its buffer. If any of these values is non-=nil=, it overrides the corresponding argument of =fit-frame-to-buffer=.
#+END_QUOTE

--- Command: *shrink-window-if-larger-than-buffer* &optional window

#+BEGIN_QUOTE
  This command attempts to reduce window's height as much as possible while still showing its full buffer, but no less than =window-min-height= lines. The return value is non-=nil= if the window was resized, and =nil= otherwise. If window is omitted or =nil=, it defaults to the selected window. Otherwise, it should be a live window.

  This command does nothing if the window is already too short to display all of its buffer, or if any of the buffer is scrolled off-screen, or if the window is the only live window in its frame.

  This command calls =fit-window-to-buffer= (see above) to do its work.
#+END_QUOTE

--- Command: *balance-windows* &optional window-or-frame

#+BEGIN_QUOTE
  This function balances windows in a way that gives more space to full-width and/or full-height windows. If window-or-frame specifies a frame, it balances all windows on that frame. If window-or-frame specifies a window, it balances only that window and its siblings (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]).
#+END_QUOTE

--- Command: *balance-windows-area*

#+BEGIN_QUOTE
  This function attempts to give all windows on the selected frame approximately the same share of the screen area. Full-width or full-height windows are not given more space than other windows.
#+END_QUOTE

--- Command: *maximize-window* &optional window

#+BEGIN_QUOTE
  This function attempts to make window as large as possible, in both dimensions, without resizing its frame or deleting other windows. If window is omitted or =nil=, it defaults to the selected window.
#+END_QUOTE

--- Command: *minimize-window* &optional window

#+BEGIN_QUOTE
  This function attempts to make window as small as possible, in both dimensions, without deleting it or resizing its frame. If window is omitted or =nil=, it defaults to the selected window.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.5 Preserving Window Sizes
    :PROPERTIES:
    :CUSTOM_ID: preserving-window-sizes
    :END:

A window can get resized explicitly by using one of the functions from the preceding section or implicitly, for example, when resizing an adjacent window, when splitting or deleting a window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]], see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]) or when resizing the window's frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Size][Frame Size]]).

It is possible to avoid implicit resizing of a specific window when there are one or more other resizable windows on the same frame. For this purpose, Emacs must be advised to preserve the size of that window. There are two basic ways to do that.

--- Variable: *window-size-fixed*

#+BEGIN_QUOTE
  If this buffer-local variable is non-=nil=, the size of any window displaying the buffer cannot normally be changed. Deleting a window or changing the frame's size may still change the window's size, if there is no choice.

  If the value is =height=, then only the window's height is fixed; if the value is =width=, then only the window's width is fixed. Any other non-=nil= value fixes both the width and the height.

  If this variable is =nil=, this does not necessarily mean that any window showing the buffer can be resized in the desired direction. To determine that, use the function =window-resizable=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]].
#+END_QUOTE

Often =window-size-fixed= is overly aggressive because it inhibits any attempt to explicitly resize or split an affected window as well. This may even happen after the window has been resized implicitly, for example, when deleting an adjacent window or resizing the window's frame. The following function tries hard to never disallow resizing such a window explicitly:

--- Function: *window-preserve-size* &optional window horizontal preserve

#+BEGIN_QUOTE
  This function (un-)marks the height of window window as preserved for future resize operations. window must be a live window and defaults to the selected one. If the optional argument horizontal is non-=nil=, it (un-)marks the width of window as preserved.

  If the optional argument preserve is =t=, this means to preserve the current height/width of window's body. The height/width of window will change only if Emacs has no better choice. Resizing a window whose height/width is preserved by this function never throws an error.

  If preserve is =nil=, this means to stop preserving the height/width of window, lifting any respective restraint induced by a previous call of this function for window. Calling =enlarge-window=, =shrink-window= or =fit-window-to-buffer= with window as argument may also remove the respective restraint.
#+END_QUOTE

=window-preserve-size= is currently invoked by the following functions:

- =fit-window-to-buffer=

  If the optional argument preserve-size of that function (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]]) is non-=nil=, the size established by that function is preserved.

- =display-buffer=

  If the alist argument of that function (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]) contains a =preserve-size= entry, the size of the window produced by that function is preserved.

=window-preserve-size= installs a window parameter (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]]) called =window-preserved-size= which is consulted by the window resizing functions. This parameter will not prevent resizing the window when the window shows another buffer than the one when =window-preserve-size= was invoked or if its size has changed since then.

The following function can be used to check whether the height of a particular window is preserved:

--- Function: *window-preserved-size* &optional window horizontal

#+BEGIN_QUOTE
  This function returns the preserved height of window window in pixels. window must be a live window and defaults to the selected one. If the optional argument horizontal is non-=nil=, it returns the preserved width of window. It returns =nil= if the size of window is not preserved.
#+END_QUOTE

* 28.6 Splitting Windows
    :PROPERTIES:
    :CUSTOM_ID: splitting-windows
    :END:

This section describes functions for creating a new window by splitting an existing one. Note that some windows are special in the sense that these functions may fail to split them as described here. Examples of such windows are side windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]) and atomic windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]]).

--- Function: *split-window* &optional window size side pixelwise

#+BEGIN_QUOTE
  This function creates a new live window next to the window window. If window is omitted or =nil=, it defaults to the selected window. That window is split, and reduced in size. The space is taken up by the new window, which is returned.

  The optional second argument size determines the sizes of window and/or the new window. If it is omitted or =nil=, both windows are given equal sizes; if there is an odd line, it is allocated to the new window. If size is a positive number, window is given size lines (or columns, depending on the value of side). If size is a negative number, the new window is given size lines (or columns).

  If size is =nil=, this function obeys the variables =window-min-height= and =window-min-width= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Sizes][Window Sizes]]). Thus, it signals an error if splitting would result in making a window smaller than those variables specify. However, a non-=nil= value for size causes those variables to be ignored; in that case, the smallest allowable window is considered to be one that has space for a text area one line tall and/or two columns wide.

  Hence, if size is specified, it's the caller's responsibility to check whether the emanating windows are large enough to encompass all areas like a mode line or a scroll bar. The function =window-min-size= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Sizes][Window Sizes]]) can be used to determine the minimum requirements of window in this regard. Since the new window usually inherits areas like the mode line or the scroll bar from window, that function is also a good guess for the minimum size of the new window. The caller should specify a smaller size only if it correspondingly removes an inherited area before the next redisplay.

  The optional third argument side determines the position of the new window relative to window. If it is =nil= or =below=, the new window is placed below window. If it is =above=, the new window is placed above window. In both these cases, size specifies a total window height, in lines.

  If side is =t= or =right=, the new window is placed on the right of window. If side is =left=, the new window is placed on the left of window. In both these cases, size specifies a total window width, in columns.

  The optional fourth argument pixelwise, if non-=nil=, means to interpret size in units of pixels, instead of lines and columns.

  If window is a live window, the new window inherits various properties from it, including margins and scroll bars. If window is an internal window, the new window inherits the properties of the window selected within window's frame.

  The behavior of this function may be altered by the window parameters of window, so long as the variable =ignore-window-parameters= is =nil=. If the value of the =split-window= window parameter is =t=, this function ignores all other window parameters. Otherwise, if the value of the =split-window= window parameter is a function, that function is called with the arguments window, size, and side, in lieu of the usual action of =split-window=. Otherwise, this function obeys the =window-atom= or =window-side= window parameter, if any. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]].
#+END_QUOTE

As an example, here is a sequence of =split-window= calls that yields the window configuration discussed in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]. This example demonstrates splitting a live window as well as splitting an internal window. We begin with a frame containing a single window (a live root window), which we denote by W4. Calling =(split-window W4)= yields this window configuration:

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||_________________W4_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||_________________W5_________________||
             |__________________W3__________________|
#+END_EXAMPLE

The =split-window= call has created a new live window, denoted by W5. It has also created a new internal window, denoted by W3, which becomes the root window and the parent of both W4 and W5.

Next, we call =(split-window W3 nil 'left)=, passing the internal window W3 as the argument. The result:

#+BEGIN_EXAMPLE
              ______________________________________
             | ______  ____________________________ |
             ||      || __________________________ ||
             ||      |||                          |||
             ||      |||                          |||
             ||      |||                          |||
             ||      |||____________W4____________|||
             ||      || __________________________ ||
             ||      |||                          |||
             ||      |||                          |||
             ||      |||____________W5____________|||
             ||__W2__||_____________W3_____________ |
             |__________________W1__________________|
#+END_EXAMPLE

A new live window W2 is created, to the left of the internal window W3. A new internal window W1 is created, becoming the new root window.

For interactive use, Emacs provides two commands which always split the selected window. These call =split-window= internally.

--- Command: *split-window-right* &optional size

#+BEGIN_QUOTE
  This function splits the selected window into two side-by-side windows, putting the selected window on the left. If size is positive, the left window gets size columns; if size is negative, the right window gets size columns.
#+END_QUOTE

--- Command: *split-window-below* &optional size

#+BEGIN_QUOTE
  This function splits the selected window into two windows, one above the other, leaving the upper window selected. If size is positive, the upper window gets size lines; if size is negative, the lower window gets size lines.
#+END_QUOTE

--- User Option: *split-window-keep-point*

#+BEGIN_QUOTE
  If the value of this variable is non-=nil= (the default), =split-window-below= behaves as described above.

  If it is =nil=, =split-window-below= adjusts point in each of the two windows to minimize redisplay. (This is useful on slow terminals.) It selects whichever window contains the screen line that point was previously on. Note that this only affects =split-window-below=, not the lower-level =split-window= function.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recombining-Windows][Recombining Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.7 Deleting Windows
    :PROPERTIES:
    :CUSTOM_ID: deleting-windows
    :END:

Deleting a window removes it from the frame's window tree. If the window is a live window, it disappears from the screen. If the window is an internal window, its child windows are deleted too.

Even after a window is deleted, it continues to exist as a Lisp object, until there are no more references to it. Window deletion can be reversed, by restoring a saved window configuration (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]]).

--- Command: *delete-window* &optional window

#+BEGIN_QUOTE
  This function removes window from display and returns =nil=. If window is omitted or =nil=, it defaults to the selected window.

  If deleting the window would leave no more windows in the window tree (e.g., if it is the only live window in the frame) or all remaining windows on window's frame are side windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]), an error is signaled. If window is part of an atomic window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]]), this function tries to delete the root of that atomic window instead.

  By default, the space taken up by window is given to one of its adjacent sibling windows, if any. However, if the variable =window-combination-resize= is non-=nil=, the space is proportionally distributed among any remaining windows in the same window combination. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recombining-Windows][Recombining Windows]].

  The behavior of this function may be altered by the window parameters of window, so long as the variable =ignore-window-parameters= is =nil=. If the value of the =delete-window= window parameter is =t=, this function ignores all other window parameters. Otherwise, if the value of the =delete-window= window parameter is a function, that function is called with the argument window, in lieu of the usual action of =delete-window=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]].
#+END_QUOTE

--- Command: *delete-other-windows* &optional window

#+BEGIN_QUOTE
  This function makes window fill its frame, deleting other windows as necessary. If window is omitted or =nil=, it defaults to the selected window. An error is signaled if window is a side window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]). If window is part of an atomic window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]]), this function tries to make the root of that atomic window fill its frame. The return value is =nil=.

  The behavior of this function may be altered by the window parameters of window, so long as the variable =ignore-window-parameters= is =nil=. If the value of the =delete-other-windows= window parameter is =t=, this function ignores all other window parameters. Otherwise, if the value of the =delete-other-windows= window parameter is a function, that function is called with the argument window, in lieu of the usual action of =delete-other-windows=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]].

  Also, if =ignore-window-parameters= is =nil=, this function does not delete any window whose =no-delete-other-windows= parameter is non-=nil=.
#+END_QUOTE

--- Command: *delete-windows-on* &optional buffer-or-name frame

#+BEGIN_QUOTE
  This function deletes all windows showing buffer-or-name, by calling =delete-window= on those windows. buffer-or-name should be a buffer, or the name of a buffer; if omitted or =nil=, it defaults to the current buffer. If there are no windows showing the specified buffer, this function does nothing. If the specified buffer is a minibuffer, an error is signaled.

  If there is a dedicated window showing the buffer, and that window is the only one on its frame, this function also deletes that frame if it is not the only frame on the terminal.

  The optional argument frame specifies which frames to operate on:

  - =nil= means operate on all frames.
  - =t= means operate on the selected frame.
  - =visible= means operate on all visible frames.
  - =0= means operate on all visible or iconified frames.
  - A frame means operate on that frame.

  Note that this argument does not have the same meaning as in other functions which scan all live windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]). Specifically, the meanings of =t= and =nil= here are the opposite of what they are in those other functions.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Selecting-Windows][Selecting Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.8 Recombining Windows
    :PROPERTIES:
    :CUSTOM_ID: recombining-windows
    :END:

When deleting the last sibling of a window W, its parent window is deleted too, with W replacing it in the window tree. This means that W must be recombined with its parent's siblings to form a new window combination (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]). In some occasions, deleting a live window may even entail the deletion of two internal windows.

#+BEGIN_EXAMPLE
              ______________________________________
             | ______  ____________________________ |
             ||      || __________________________ ||
             ||      ||| ___________  ___________ |||
             ||      ||||           ||           ||||
             ||      ||||____W6_____||_____W7____||||
             ||      |||____________W4____________|||
             ||      || __________________________ ||
             ||      |||                          |||
             ||      |||                          |||
             ||      |||____________W5____________|||
             ||__W2__||_____________W3_____________ |
             |__________________W1__________________|
#+END_EXAMPLE

Deleting W5 in this configuration normally causes the deletion of W3 and W4. The remaining live windows W2, W6 and W7 are recombined to form a new horizontal combination with parent W1.

Sometimes, however, it makes sense to not delete a parent window like W4. In particular, a parent window should not be removed when it was used to preserve a combination embedded in a combination of the same type. Such embeddings make sense to assure that when you split a window and subsequently delete the new window, Emacs reestablishes the layout of the associated frame as it existed before the splitting.

Consider a scenario starting with two live windows W2 and W3 and their parent W1.

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||_________________W2_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W3_________________||
             |__________________W1__________________|
#+END_EXAMPLE

Split W2 to make a new window W4 as follows.

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W2_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W4_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W3_________________||
             |__________________W1__________________|
#+END_EXAMPLE

Now, when enlarging a window vertically, Emacs tries to obtain the corresponding space from its lower sibling, provided such a window exists. In our scenario, enlarging W4 will steal space from W3.

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W2_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||_________________W4_________________||
             | ____________________________________ |
             ||_________________W3_________________||
             |__________________W1__________________|
#+END_EXAMPLE

Deleting W4 will now give its entire space to W2, including the space earlier stolen from W3.

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||_________________W2_________________||
             | ____________________________________ |
             ||_________________W3_________________||
             |__________________W1__________________|
#+END_EXAMPLE

This can be counterintuitive, in particular if W4 were used for displaying a buffer only temporarily (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Temporary-Displays][Temporary Displays]]), and you want to continue working with the initial layout.

The behavior can be fixed by making a new parent window when splitting W2. The variable described next allows that to be done.

--- User Option: *window-combination-limit*

#+BEGIN_QUOTE
  This variable controls whether splitting a window shall make a new parent window. The following values are recognized:

  - =nil=

    This means that the new live window is allowed to share the existing parent window, if one exists, provided the split occurs in the same direction as the existing window combination (otherwise, a new internal window is created anyway).

  - =window-size=

    This means that =display-buffer= makes a new parent window when it splits a window and is passed a =window-height= or =window-width= entry in the alist argument (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]). Otherwise, window splitting behaves as for a value of =nil=.

  - =temp-buffer-resize=

    In this case =with-temp-buffer-window= makes a new parent window when it splits a window and =temp-buffer-resize-mode= is enabled (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Temporary-Displays][Temporary Displays]]). Otherwise, window splitting behaves as for =nil=.

  - =temp-buffer=

    In this case =with-temp-buffer-window= always makes a new parent window when it splits an existing window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Temporary-Displays][Temporary Displays]]). Otherwise, window splitting behaves as for =nil=.

  - =display-buffer=

    This means that when =display-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]) splits a window it always makes a new parent window. Otherwise, window splitting behaves as for =nil=.

  - =t=

    This means that splitting a window always creates a new parent window. Thus, if the value of this variable is at all times =t=, then at all times every window tree is a binary tree (a tree where each window except the root window has exactly one sibling).

  The default is =window-size=. Other values are reserved for future use.

  If, as a consequence of this variable's setting, =split-window= makes a new parent window, it also calls =set-window-combination-limit= (see below) on the newly-created internal window. This affects how the window tree is rearranged when the child windows are deleted (see below).
#+END_QUOTE

If =window-combination-limit= is =t=, splitting W2 in the initial configuration of our scenario would have produced this:

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             || __________________________________ ||
             |||                                  |||
             |||________________W2________________|||
             || __________________________________ ||
             |||                                  |||
             |||________________W4________________|||
             ||_________________W5_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W3_________________||
             |__________________W1__________________|
#+END_EXAMPLE

A new internal window W5 has been created; its children are W2 and the new live window W4. Now, W2 is the only sibling of W4, so enlarging W4 will try to shrink W2, leaving W3 unaffected. Observe that W5 represents a vertical combination of two windows embedded in the vertical combination W1.

--- Function: *set-window-combination-limit* window limit

#+BEGIN_QUOTE
  This function sets the combination limit of the window window to limit. This value can be retrieved via the function =window-combination-limit=. See below for its effects; note that it is only meaningful for internal windows. The =split-window= function automatically calls this function, passing it =t= as limit, provided the value of the variable =window-combination-limit= is =t= when it is called.
#+END_QUOTE

--- Function: *window-combination-limit* window

#+BEGIN_QUOTE
  This function returns the combination limit for window.

  The combination limit is meaningful only for an internal window. If it is =nil=, then Emacs is allowed to automatically delete window, in response to a window deletion, in order to group the child windows of window with its sibling windows to form a new window combination. If the combination limit is =t=, the child windows of window are never automatically recombined with its siblings.

  If, in the configuration shown at the beginning of this section, the combination limit of W4 (the parent window of W6 and W7) is =t=, deleting W5 will not implicitly delete W4 too.
#+END_QUOTE

Alternatively, the problems sketched above can be avoided by always resizing all windows in the same combination whenever one of its windows is split or deleted. This also permits splitting windows that would be otherwise too small for such an operation.

--- User Option: *window-combination-resize*

#+BEGIN_QUOTE
  If this variable is =nil=, =split-window= can only split a window (denoted by window) if window's screen area is large enough to accommodate both itself and the new window.

  If this variable is =t=, =split-window= tries to resize all windows that are part of the same combination as window, in order to accommodate the new window. In particular, this may allow =split-window= to succeed even if window is a fixed-size window or too small to ordinarily split. Furthermore, subsequently resizing or deleting window may resize all other windows in its combination.

  The default is =nil=. Other values are reserved for future use. A specific split operation may ignore the value of this variable if it is affected by a non-=nil= value of =window-combination-limit=.
#+END_QUOTE

To illustrate the effect of =window-combination-resize=, consider the following frame layout.

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||_________________W2_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||_________________W3_________________||
             |__________________W1__________________|
#+END_EXAMPLE

If =window-combination-resize= is =nil=, splitting window W3 leaves the size of W2 unchanged:

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||                                    ||
             ||_________________W2_________________||
             | ____________________________________ |
             ||                                    ||
             ||_________________W3_________________||
             | ____________________________________ |
             ||                                    ||
             ||_________________W4_________________||
             |__________________W1__________________|
#+END_EXAMPLE

If =window-combination-resize= is =t=, splitting W3 instead leaves all three live windows with approximately the same height:

#+BEGIN_EXAMPLE
              ______________________________________
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W2_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W3_________________||
             | ____________________________________ |
             ||                                    ||
             ||                                    ||
             ||_________________W4_________________||
             |__________________W1__________________|
#+END_EXAMPLE

Deleting any of the live windows W2, W3 or W4 will distribute its space proportionally among the two remaining live windows.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Recombining-Windows][Recombining Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.9 Selecting Windows
    :PROPERTIES:
    :CUSTOM_ID: selecting-windows
    :END:

--- Function: *select-window* window &optional norecord

#+BEGIN_QUOTE
  This function makes window the selected window and the window selected within its frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Windows][Basic Windows]]), and selects that frame. It also makes window's buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]]) current and sets that buffer's value of =point= to the value of =window-point= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Point][Window Point]]) in window. window must be a live window. The return value is window.

  By default, this function also moves window's buffer to the front of the buffer list (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]) and makes window the most recently selected window. If the optional argument norecord is non-=nil=, these additional actions are omitted.

  In addition, this function by default also tells the display engine to update the display of window when its frame gets redisplayed the next time. If norecord is non-=nil=, such updates are usually not performed. If, however, norecord equals the special symbol =mark-for-redisplay=, the additional actions mentioned above are omitted but window will be nevertheless updated.

  Note that sometimes selecting a window is not enough to show it, or make its frame the top-most frame on display: you may also need to raise the frame or make sure input focus is directed to that frame. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Focus][Input Focus]].
#+END_QUOTE

For historical reasons, Emacs does not run a separate hook whenever a window gets selected. Applications and internal routines often temporarily select a window to perform a few actions on it. They do that either to simplify coding---because many functions by default operate on the selected window when no window argument is specified---or because some functions did not (and still do not) take a window as argument and always operate(d) on the selected window instead. Running a hook every time a window gets selected for a short time and once more when the previously selected window gets restored is not useful.

However, when its norecord argument is =nil=, =select-window= updates the buffer list and thus indirectly runs the normal hook =buffer-list-update-hook= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]). Consequently, that hook provides a reasonable way to run a function whenever a window gets selected more "permanently".

Since =buffer-list-update-hook= is also run by functions that are not related to window management, it will usually make sense to save the value of the selected window somewhere and compare it with the value of =selected-window= while running that hook. Also, to avoid false positives when using =buffer-list-update-hook=, it is good practice that every =select-window= call supposed to select a window only temporarily passes a non-=nil= norecord argument. If possible, the macro =with-selected-window= (see below) should be used in such cases.

The sequence of calls to =select-window= with a non-=nil= norecord argument determines an ordering of windows by their selection time. The function =get-lru-window= can be used to retrieve the least recently selected live window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]).

--- Macro: *save-selected-window* forms...

#+BEGIN_QUOTE
  This macro records the selected frame, as well as the selected window of each frame, executes forms in sequence, then restores the earlier selected frame and windows. It also saves and restores the current buffer. It returns the value of the last form in forms.

  This macro does not save or restore anything about the sizes, arrangement or contents of windows; therefore, if forms change them, the change persists. If the previously selected window of some frame is no longer live at the time of exit from forms, that frame's selected window is left alone. If the previously selected window is no longer live, then whatever window is selected at the end of forms remains selected. The current buffer is restored if and only if it is still live when exiting forms.

  This macro changes neither the ordering of recently selected windows nor the buffer list.
#+END_QUOTE

--- Macro: *with-selected-window* window forms...

#+BEGIN_QUOTE
  This macro selects window, executes forms in sequence, then restores the previously selected window and current buffer. The ordering of recently selected windows and the buffer list remain unchanged unless you deliberately change them within forms; for example, by calling =select-window= with argument norecord =nil=. Hence, this macro is the preferred way to temporarily work with window as the selected window without needlessly running =buffer-list-update-hook=.
#+END_QUOTE

--- Function: *frame-selected-window* &optional frame

#+BEGIN_QUOTE
  This function returns the window on frame that is selected within that frame. frame should be a live frame; if omitted or =nil=, it defaults to the selected frame.
#+END_QUOTE

--- Function: *set-frame-selected-window* frame window &optional norecord

#+BEGIN_QUOTE
  This function makes window the window selected within the frame frame. frame should be a live frame; if =nil=, it defaults to the selected frame. window should be a live window; if =nil=, it defaults to the selected window.

  If frame is the selected frame, this makes window the selected window.

  If the optional argument norecord is non-=nil=, this function does not alter the list of most recently selected windows, nor the buffer list.
#+END_QUOTE

--- Function: *window-use-time* &optional window

#+BEGIN_QUOTE
  This functions returns the use time of window window. window must be a live window and defaults to the selected one.

  The use time of a window is not really a time value, but an integer that does increase monotonically with each call of =select-window= with a =nil= norecord argument. The window with the lowest use time is usually called the least recently used window while the window with the highest use time is called the most recently used one (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]).
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Selecting-Windows][Selecting Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.10 Cyclic Ordering of Windows
    :PROPERTIES:
    :CUSTOM_ID: cyclic-ordering-of-windows
    :END:

When you use the command C-x o (=other-window=) to select some other window, it moves through live windows in a specific order. For any given configuration of windows, this order never varies. It is called the cyclic ordering of windows.

The ordering is determined by a depth-first traversal of each frame's window tree, retrieving the live windows which are the leaf nodes of the tree (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]). If the minibuffer is active, the minibuffer window is included too. The ordering is cyclic, so the last window in the sequence is followed by the first one.

--- Function: *next-window* &optional window minibuf all-frames

#+BEGIN_QUOTE
  This function returns a live window, the one following window in the cyclic ordering of windows. window should be a live window; if omitted or =nil=, it defaults to the selected window.

  The optional argument minibuf specifies whether minibuffer windows should be included in the cyclic ordering. Normally, when minibuf is =nil=, a minibuffer window is included only if it is currently active; this matches the behavior of C-x o. (Note that a minibuffer window is active as long as its minibuffer is in use; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]).

  If minibuf is =t=, the cyclic ordering includes all minibuffer windows. If minibuf is neither =t= nor =nil=, minibuffer windows are not included even if they are active.

  The optional argument all-frames specifies which frames to consider:

  - =nil= means to consider windows on window's frame. If the minibuffer window is considered (as specified by the minibuf argument), then frames that share the minibuffer window are considered too.\\
  - =t= means to consider windows on all existing frames.\\
  - =visible= means to consider windows on all visible frames.\\
  - 0 means to consider windows on all visible or iconified frames.\\
  - A frame means to consider windows on that specific frame.\\
  - Anything else means to consider windows on window's frame, and no others.

  If more than one frame is considered, the cyclic ordering is obtained by appending the orderings for those frames, in the same order as the list of all live frames (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Finding-All-Frames][Finding All Frames]]).
#+END_QUOTE

--- Function: *previous-window* &optional window minibuf all-frames

#+BEGIN_QUOTE
  This function returns a live window, the one preceding window in the cyclic ordering of windows. The other arguments are handled like in =next-window=.
#+END_QUOTE

--- Command: *other-window* count &optional all-frames

#+BEGIN_QUOTE
  This function selects a live window, one count places from the selected window in the cyclic ordering of windows. If count is a positive number, it skips count windows forwards; if count is negative, it skips count windows backwards; if count is zero, that simply re-selects the selected window. When called interactively, count is the numeric prefix argument.

  The optional argument all-frames has the same meaning as in =next-window=, like a =nil= minibuf argument to =next-window=.

  This function does not select a window that has a non-=nil= =no-other-window= window parameter (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]]), provided that =ignore-window-parameters= is =nil=.

  If the =other-window= parameter of the selected window is a function, and =ignore-window-parameters= is =nil=, that function will be called with the arguments count and all-frames instead of the normal operation of this function.
#+END_QUOTE

--- Function: *walk-windows* fun &optional minibuf all-frames

#+BEGIN_QUOTE
  This function calls the function fun once for each live window, with the window as the argument.

  It follows the cyclic ordering of windows. The optional arguments minibuf and all-frames specify the set of windows included; these have the same arguments as in =next-window=. If all-frames specifies a frame, the first window walked is the first window on that frame (the one returned by =frame-first-window=), not necessarily the selected window.

  If fun changes the window configuration by splitting or deleting windows, that does not alter the set of windows walked, which is determined prior to calling fun for the first time.
#+END_QUOTE

--- Function: *one-window-p* &optional no-mini all-frames

#+BEGIN_QUOTE
  This function returns =t= if the selected window is the only live window, and =nil= otherwise.

  If the minibuffer window is active, it is normally considered (so that this function returns =nil=). However, if the optional argument no-mini is non-=nil=, the minibuffer window is ignored even if active. The optional argument all-frames has the same meaning as for =next-window=.
#+END_QUOTE

The following functions return a window which satisfies some criterion, without selecting it:

--- Function: *get-lru-window* &optional all-frames dedicated not-selected

#+BEGIN_QUOTE
  This function returns a live window which is heuristically the least recently used. The optional argument all-frames has the same meaning as in =next-window=.

  If any full-width windows are present, only those windows are considered. A minibuffer window is never a candidate. A dedicated window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]) is never a candidate unless the optional argument dedicated is non-=nil=. The selected window is never returned, unless it is the only candidate. However, if the optional argument not-selected is non-=nil=, this function returns =nil= in that case.
#+END_QUOTE

--- Function: *get-mru-window* &optional all-frames dedicated not-selected

#+BEGIN_QUOTE
  This function is like =get-lru-window=, but it returns the most recently used window instead. The meaning of the arguments is the same as described for =get-lru-window=.
#+END_QUOTE

--- Function: *get-largest-window* &optional all-frames dedicated not-selected

#+BEGIN_QUOTE
  This function returns the window with the largest area (height times width). The optional argument all-frames specifies the windows to search, and has the same meaning as in =next-window=.

  A minibuffer window is never a candidate. A dedicated window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]) is never a candidate unless the optional argument dedicated is non-=nil=. The selected window is not a candidate if the optional argument not-selected is non-=nil=. If the optional argument not-selected is non-=nil= and the selected window is the only candidate, this function returns =nil=.

  If there are two candidate windows of the same size, this function prefers the one that comes first in the cyclic ordering of windows, starting from the selected window.
#+END_QUOTE

--- Function: *get-window-with-predicate* predicate &optional minibuf all-frames default

#+BEGIN_QUOTE
  This function calls the function predicate for each of the windows in the cyclic order of windows in turn, passing it the window as an argument. If the predicate returns non-=nil= for any window, this function stops and returns that window. If no such window is found, the return value is default (which defaults to =nil=).

  The optional arguments minibuf and all-frames specify the windows to search, and have the same meanings as in =next-window=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.11 Buffers and Windows
    :PROPERTIES:
    :CUSTOM_ID: buffers-and-windows
    :END:

This section describes low-level functions for examining and setting the contents of windows. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]], for higher-level functions for displaying a specific buffer in a window.

--- Function: *window-buffer* &optional window

#+BEGIN_QUOTE
  This function returns the buffer that window is displaying. If window is omitted or =nil= it defaults to the selected window. If window is an internal window, this function returns =nil=.
#+END_QUOTE

--- Function: *set-window-buffer* window buffer-or-name &optional keep-margins

#+BEGIN_QUOTE
  This function makes window display buffer-or-name. window should be a live window; if =nil=, it defaults to the selected window. buffer-or-name should be a buffer, or the name of an existing buffer. This function does not change which window is selected, nor does it directly change which buffer is current (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Current-Buffer][Current Buffer]]). Its return value is =nil=.

  If window is strongly dedicated to a buffer and buffer-or-name does not specify that buffer, this function signals an error. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]].

  By default, this function resets window's position, display margins, fringe widths, and scroll bar settings, based on the local variables in the specified buffer. However, if the optional argument keep-margins is non-=nil=, it leaves window's display margins, fringes and scroll bar settings alone.

  When writing an application, you should normally use =display-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]) or the higher-level functions described in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]], instead of calling =set-window-buffer= directly.

  This runs =window-scroll-functions=, followed by =window-configuration-change-hook=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Hooks][Window Hooks]].
#+END_QUOTE

--- Variable: *buffer-display-count*

#+BEGIN_QUOTE
  This buffer-local variable records the number of times a buffer has been displayed in a window. It is incremented each time =set-window-buffer= is called for the buffer.
#+END_QUOTE

--- Variable: *buffer-display-time*

#+BEGIN_QUOTE
  This buffer-local variable records the time at which a buffer was last displayed in a window. The value is =nil= if the buffer has never been displayed. It is updated each time =set-window-buffer= is called for the buffer, with the value returned by =current-time= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Time-of-Day][Time of Day]]).
#+END_QUOTE

--- Function: *get-buffer-window* &optional buffer-or-name all-frames

#+BEGIN_QUOTE
  This function returns the first window displaying buffer-or-name in the cyclic ordering of windows, starting from the selected window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]). If no such window exists, the return value is =nil=.

  buffer-or-name should be a buffer or the name of a buffer; if omitted or =nil=, it defaults to the current buffer. The optional argument all-frames specifies which windows to consider:

  - =t= means consider windows on all existing frames.
  - =visible= means consider windows on all visible frames.
  - 0 means consider windows on all visible or iconified frames.
  - A frame means consider windows on that frame only.
  - Any other value means consider windows on the selected frame.

  Note that these meanings differ slightly from those of the all-frames argument to =next-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]). This function may be changed in a future version of Emacs to eliminate this discrepancy.
#+END_QUOTE

--- Function: *get-buffer-window-list* &optional buffer-or-name minibuf all-frames

#+BEGIN_QUOTE
  This function returns a list of all windows currently displaying buffer-or-name. buffer-or-name should be a buffer or the name of an existing buffer. If omitted or =nil=, it defaults to the current buffer. If the currently selected window displays buffer-or-name, it will be the first in the list returned by this function.

  The arguments minibuf and all-frames have the same meanings as in the function =next-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]). Note that the all-frames argument does /not/ behave exactly like in =get-buffer-window=.
#+END_QUOTE

--- Command: *replace-buffer-in-windows* &optional buffer-or-name

#+BEGIN_QUOTE
  This command replaces buffer-or-name with some other buffer, in all windows displaying it. buffer-or-name should be a buffer, or the name of an existing buffer; if omitted or =nil=, it defaults to the current buffer.

  The replacement buffer in each window is chosen via =switch-to-prev-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]]). Any dedicated window displaying buffer-or-name is deleted if possible (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]). If such a window is the only window on its frame and there are other frames on the same terminal, the frame is deleted as well. If the dedicated window is the only window on the only frame on its terminal, the buffer is replaced anyway.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.12 Switching to a Buffer in a Window
    :PROPERTIES:
    :CUSTOM_ID: switching-to-a-buffer-in-a-window
    :END:

This section describes high-level functions for switching to a specified buffer in some window. In general, "switching to a buffer" means to (1) show the buffer in some window, (2) make that window the selected window (and its frame the selected frame), and (3) make the buffer the current buffer.

Do /not/ use these functions to make a buffer temporarily current just so a Lisp program can access or modify it. They have side-effects, such as changing window histories (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]]), which will surprise the user if used that way. If you want to make a buffer current to modify it in Lisp, use =with-current-buffer=, =save-current-buffer=, or =set-buffer=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Current-Buffer][Current Buffer]].

--- Command: *switch-to-buffer* buffer-or-name &optional norecord force-same-window

#+BEGIN_QUOTE
  This command attempts to display buffer-or-name in the selected window and make it the current buffer. It is often used interactively (as the binding of C-x b), as well as in Lisp programs. The return value is the buffer switched to.

  If buffer-or-name is =nil=, it defaults to the buffer returned by =other-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]). If buffer-or-name is a string that is not the name of any existing buffer, this function creates a new buffer with that name; the new buffer's major mode is determined by the variable =major-mode= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Major-Modes][Major Modes]]).

  Normally, the specified buffer is put at the front of the buffer list---both the global buffer list and the selected frame's buffer list (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]). However, this is not done if the optional argument norecord is non-=nil=.

  Sometimes, the selected window may not be suitable for displaying the buffer. This happens if the selected window is a minibuffer window, or if the selected window is strongly dedicated to its buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]). In such cases, the command normally tries to display the buffer in some other window, by invoking =pop-to-buffer= (see below).

  If the optional argument force-same-window is non-=nil= and the selected window is not suitable for displaying the buffer, this function always signals an error when called non-interactively. In interactive use, if the selected window is a minibuffer window, this function will try to use some other window instead. If the selected window is strongly dedicated to its buffer, the option =switch-to-buffer-in-dedicated-window= described next can be used to proceed.
#+END_QUOTE

--- User Option: *switch-to-buffer-in-dedicated-window*

#+BEGIN_QUOTE
  This option, if non-=nil=, allows =switch-to-buffer= to proceed when called interactively and the selected window is strongly dedicated to its buffer.

  The following values are respected:

  - =nil=

    Disallows switching and signals an error as in non-interactive use.

  - =prompt=

    Prompts the user whether to allow switching.

  - =pop=

    Invokes =pop-to-buffer= to proceed.

  - =t=

    Marks the selected window as non-dedicated and proceeds.

  This option does not affect non-interactive calls of =switch-to-buffer=.
#+END_QUOTE

By default, =switch-to-buffer= tries to preserve =window-point=. This behavior can be tuned using the following option.

--- User Option: *switch-to-buffer-preserve-window-point*

#+BEGIN_QUOTE
  If this variable is =nil=, =switch-to-buffer= displays the buffer specified by buffer-or-name at the position of that buffer's =point=. If this variable is =already-displayed=, it tries to display the buffer at its previous position in the selected window, provided the buffer is currently displayed in some other window on any visible or iconified frame. If this variable is =t=, =switch-to-buffer= unconditionally tries to display the buffer at its previous position in the selected window.

  This variable is ignored if the buffer is already displayed in the selected window or never appeared in it before, or if =switch-to-buffer= calls =pop-to-buffer= to display the buffer.
#+END_QUOTE

The next two commands are similar to =switch-to-buffer=, except for the described features.

--- Command: *switch-to-buffer-other-window* buffer-or-name &optional norecord

#+BEGIN_QUOTE
  This function displays the buffer specified by buffer-or-name in some window other than the selected window. It uses the function =pop-to-buffer= internally (see below).

  If the selected window already displays the specified buffer, it continues to do so, but another window is nonetheless found to display it as well.

  The buffer-or-name and norecord arguments have the same meanings as in =switch-to-buffer=.
#+END_QUOTE

--- Command: *switch-to-buffer-other-frame* buffer-or-name &optional norecord

#+BEGIN_QUOTE
  This function displays the buffer specified by buffer-or-name in a new frame. It uses the function =pop-to-buffer= internally (see below).

  If the specified buffer is already displayed in another window, in any frame on the current terminal, this switches to that window instead of creating a new frame. However, the selected window is never used for this.

  The buffer-or-name and norecord arguments have the same meanings as in =switch-to-buffer=.
#+END_QUOTE

The above commands use the function =pop-to-buffer=, which flexibly displays a buffer in some window and selects that window for editing. In turn, =pop-to-buffer= uses =display-buffer= for displaying the buffer. Hence, all the variables affecting =display-buffer= will affect it as well. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]], for the documentation of =display-buffer=.

--- Command: *pop-to-buffer* buffer-or-name &optional action norecord

#+BEGIN_QUOTE
  This function makes buffer-or-name the current buffer and displays it in some window, preferably not the window currently selected. It then selects the displaying window. If that window is on a different graphical frame, that frame is given input focus if possible (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Focus][Input Focus]]).

  If buffer-or-name is =nil=, it defaults to the buffer returned by =other-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]). If buffer-or-name is a string that is not the name of any existing buffer, this function creates a new buffer with that name; the new buffer's major mode is determined by the variable =major-mode= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Major-Modes][Major Modes]]). In any case, that buffer is made current and returned, even when no suitable window was found to display it.

  If action is non-=nil=, it should be a display action to pass to =display-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]). Alternatively, a non-=nil=, non-list value means to pop to a window other than the selected one---even if the buffer is already displayed in the selected window.

  Like =switch-to-buffer=, this function updates the buffer list unless norecord is non-=nil=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.13 Displaying a Buffer in a Suitable Window
    :PROPERTIES:
    :CUSTOM_ID: displaying-a-buffer-in-a-suitable-window
    :END:

This section describes lower-level functions Emacs uses to find or create a window for displaying a specified buffer. The common workhorse of these functions is =display-buffer= which eventually handles all incoming requests for buffer display (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]).

=display-buffer= delegates the task of finding a suitable window to so-called action functions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]). First, =display-buffer= compiles a so-called action alist---a special association list that action functions can use to fine-tune their behavior. Then it passes that alist on to each action function it calls (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Alists][Buffer Display Action Alists]]).

The behavior of =display-buffer= is highly customizable. To understand how customizations are used in practice, you may wish to study examples illustrating the order of precedence which =display-buffer= uses to call action functions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Precedence-of-Action-Functions][Precedence of Action Functions]]). To avoid conflicts between Lisp programs calling =display-buffer= and user customizations of its behavior, it may make sense to follow a number of guidelines which are sketched in the final part of this section (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Zen-of-Buffer-Display][The Zen of Buffer Display]]).

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]: How to choose a window for displaying a buffer.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]: Support functions for buffer display.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Alists][Buffer Display Action Alists]]: Alists for fine-tuning buffer display.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window-Options][Choosing Window Options]]: Extra options affecting how buffers are displayed.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Precedence-of-Action-Functions][Precedence of Action Functions]]: Examples to explain the precedence of action functions.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Zen-of-Buffer-Display][The Zen of Buffer Display]]: How to avoid that buffers get lost in between windows.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]]

** 28.13.1 Choosing a Window for Displaying a Buffer
     :PROPERTIES:
     :CUSTOM_ID: choosing-a-window-for-displaying-a-buffer
     :END:

The command =display-buffer= flexibly chooses a window for display, and displays a specified buffer in that window. It can be called interactively, via the key binding C-x 4 C-o. It is also used as a subroutine by many functions and commands, including =switch-to-buffer= and =pop-to-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]]).

This command performs several complex steps to find a window to display in. These steps are described by means of display actions, which have the form =(=functions=.=alist=)=. Here, functions is either a single function or a list of functions, referred to as "action functions" (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]); and alist is an association list, referred to as "action alist" (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Alists][Buffer Display Action Alists]]). See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Zen-of-Buffer-Display][The Zen of Buffer Display]], for samples of display actions.

An action function accepts two arguments: the buffer to display and an action alist. It attempts to display the buffer in some window, picking or creating a window according to its own criteria. If successful, it returns the window; otherwise, it returns =nil=.

=display-buffer= works by combining display actions from several sources, and calling the action functions in turn, until one of them manages to display the buffer and returns a non-=nil= value.

--- Command: *display-buffer* buffer-or-name &optional action frame

#+BEGIN_QUOTE
  This command makes buffer-or-name appear in some window, without selecting the window or making the buffer current. The argument buffer-or-name must be a buffer or the name of an existing buffer. The return value is the window chosen to display the buffer, or =nil= if no suitable window was found.

  The optional argument action, if non-=nil=, should normally be a display action (described above). =display-buffer= builds a list of action functions and an action alist, by consolidating display actions from the following sources (in order of their precedence, from highest to lowest):

  - The variable =display-buffer-overriding-action=.\\
  - The user option =display-buffer-alist=.\\
  - The action argument.\\
  - The user option =display-buffer-base-action=.\\
  - The constant =display-buffer-fallback-action=.

  In practice this means that =display-buffer= builds a list of all action functions specified by these display actions. The first element of this list is the first action function specified by =display-buffer-overriding-action=, if any. Its last element is =display-buffer-pop-up-frame=---the last action function specified by =display-buffer-fallback-action=. Duplicates are not removed from this list---hence one and the same action function may be called multiple times during one call of =display-buffer=.

  =display-buffer= calls the action functions specified by this list in turn, passing the buffer as the first argument and the combined action alist as the second argument, until one of the functions returns non-=nil=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Precedence-of-Action-Functions][Precedence of Action Functions]], for examples how display actions specified by different sources are processed by =display-buffer=.

  Note that the second argument is always the list of /all/ action alist entries specified by the sources named above. Hence, the first element of that list is the first action alist entry specified by =display-buffer-overriding-action=, if any. Its last element is the last alist entry of =display-buffer-base-action=, if any (the action alist of =display-buffer-fallback-action= is empty).

  Note also, that the combined action alist may contain duplicate entries and entries for the same key with different values. As a rule, action functions always use the first association of a key they find. Hence, the association an action function uses is not necessarily the association provided by the display action that specified that action function,

  The argument action can also have a non-=nil=, non-list value. This has the special meaning that the buffer should be displayed in a window other than the selected one, even if the selected window is already displaying it. If called interactively with a prefix argument, action is =t=. Lisp programs should always supply a list value.

  The optional argument frame, if non-=nil=, specifies which frames to check when deciding whether the buffer is already displayed. It is equivalent to adding an element =(reusable-frames .=frame=)= to the action alist of action (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Alists][Buffer Display Action Alists]]). The frame argument is provided for compatibility reasons, Lisp programs should not use it.
#+END_QUOTE

--- Variable: *display-buffer-overriding-action*

#+BEGIN_QUOTE
  The value of this variable should be a display action, which is treated with the highest priority by =display-buffer=. The default value is an empty display action, i.e., =(nil . nil)=.
#+END_QUOTE

--- User Option: *display-buffer-alist*

#+BEGIN_QUOTE
  The value of this option is an alist mapping conditions to display actions. Each condition may be either a regular expression matching a buffer name or a function that takes two arguments: a buffer name and the action argument passed to =display-buffer=. If either the name of the buffer passed to =display-buffer= matches a regular expression in this alist, or the function specified by a condition returns non-=nil=, then =display-buffer= uses the corresponding display action to display the buffer.
#+END_QUOTE

--- User Option: *display-buffer-base-action*

#+BEGIN_QUOTE
  The value of this option should be a display action. This option can be used to define a standard display action for calls to =display-buffer=.
#+END_QUOTE

--- Constant: *display-buffer-fallback-action*

#+BEGIN_QUOTE
  This display action specifies the fallback behavior for =display-buffer= if no other display actions are given.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Alists][Buffer Display Action Alists]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]]

** 28.13.2 Action Functions for Buffer Display
     :PROPERTIES:
     :CUSTOM_ID: action-functions-for-buffer-display
     :END:

An action function is a function =display-buffer= calls for choosing a window to display a buffer. Action functions take two arguments: buffer, the buffer to display, and alist, an action alist (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Alists][Buffer Display Action Alists]]). They are supposed to return a window displaying buffer if they succeed and =nil= if they fail.

The following basic action functions are defined in Emacs.

--- Function: *display-buffer-same-window* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer in the selected window. It fails if the selected window is a minibuffer window or is dedicated to another buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]). It also fails if alist has a non-=nil= =inhibit-same-window= entry.
#+END_QUOTE

--- Function: *display-buffer-reuse-window* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer by finding a window that is already displaying it.

  If alist has a non-=nil= =inhibit-same-window= entry, the selected window is not eligible for reuse. The set of frames to search for a window already displaying buffer can be specified with the help of the =reusable-frames= action alist entry. If alist contains no =reusable-frames= entry, this function searches just the selected frame.

  If this function chooses a window on another frame, it makes that frame visible and, unless alist contains an =inhibit-switch-frame= entry, raises that frame if necessary.
#+END_QUOTE

--- Function: *display-buffer-reuse-mode-window* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer by finding a window that is displaying a buffer in a given mode.

  If alist contains a =mode= entry, its value specifes a major mode (a symbol) or a list of major modes. If alist contains no =mode= entry, the current major mode of buffer is used instead. A window is a candidate if it displays a buffer whose mode derives from one of the modes specified thusly.

  The behavior is also controlled by alist entries for =inhibit-same-window=, =reusable-frames= and =inhibit-switch-frame=, like =display-buffer-reuse-window= does.
#+END_QUOTE

--- Function: *display-buffer-pop-up-window* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer by splitting the largest or least recently-used window (usually located on the selected frame). It actually performs the split by calling the function specified by =split-window-preferred-function= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window-Options][Choosing Window Options]]).

  The size of the new window can be adjusted by supplying =window-height= and =window-width= entries in alist. If alist contains a =preserve-size= entry, Emacs will also try to preserve the size of the new window during future resize operations (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]]).

  This function fails if no window can be split. More often than not, this happens because no window is large enough to allow splitting. Setting =split-height-threshold= or =split-width-threshold= to lower values may help in this regard. Splitting also fails when the selected frame has an =unsplittable= frame parameter; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Parameters][Buffer Parameters]].
#+END_QUOTE

--- Function: *display-buffer-in-previous-window* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer in a window where it was displayed previously.

  If alist contains a non-=nil= =inhibit-same-window= entry, the selected window is not eligible for use. A dedicated window is usable only if it already shows buffer. If alist contains a =previous-window= entry, the window specified by that entry is usable even if it never showed buffer before.

  If alist contains a =reusable-frames= entry (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Alists][Buffer Display Action Alists]]), its value determines which frames to search for a suitable window. If alist contains no =reusable-frames= entry, this function searches just the selected frame if =display-buffer-reuse-frames= and =pop-up-frames= are both =nil=; it searches all frames on the current terminal if either of those variables is non-=nil=.

  If more than one window qualifies as usable according to these rules, this function makes a choice in the following order of preference:

  - The window specified by any =previous-window= alist entry, provided it is not the selected window.\\
  - A window that showed buffer before, provided it is not the selected window.\\
  - The selected window if it is either specified by a =previous-window= alist entry or showed buffer before.
#+END_QUOTE

--- Function: *display-buffer-use-some-window* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer by choosing an existing window and displaying the buffer in that window. It can fail if all windows are dedicated to other buffers (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]).
#+END_QUOTE

--- Function: *display-buffer-below-selected* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer in a window below the selected window. If there is a window below the selected one and that window already displays buffer, it reuses that window.

  If there is no such window, this function tries to create a new window by splitting the selected one, and displays buffer there. It will also try to adjust that window's size provided alist contains a suitable =window-height= or =window-width= entry, see above.

  If splitting the selected window fails and there is a non-dedicated window below the selected one showing some other buffer, this function tries to use that window for showing buffer.
#+END_QUOTE

--- Function: *display-buffer-at-bottom* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer in a window at the bottom of the selected frame.

  This either tries to split the window at the bottom of the frame or the frame's root window, or to reuse an existing window at the bottom of the selected frame.
#+END_QUOTE

--- Function: *display-buffer-pop-up-frame* buffer alist

#+BEGIN_QUOTE
  This function creates a new frame, and displays the buffer in that frame's window. It actually performs the frame creation by calling the function specified in =pop-up-frame-function= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window-Options][Choosing Window Options]]). If alist contains a =pop-up-frame-parameters= entry, the associated value is added to the newly created frame's parameters.
#+END_QUOTE

--- Function: *display-buffer-in-child-frame* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer in a child frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Child-Frames][Child Frames]]) of the selected frame, either reusing an existing child frame or by making a new one. If alist has a non-=nil= =child-frame-parameters= entry, the corresponding value is an alist of frame parameters to give the new frame. A =parent-frame= parameter specifying the selected frame is provided by default. If the child frame should become the child of another frame, a corresponding entry must be added to alist.

  The appearance of child frames is largely dependent on the parameters provided via alist. It is advisable to use at least ratios to specify the size (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Size-Parameters][Size Parameters]]) and the position (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Position-Parameters][Position Parameters]]) of the child frame, and to add a =keep-ratio= parameter (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Interaction-Parameters][Frame Interaction Parameters]]), in order to make sure that the child frame remains visible. For other parameters that should be considered see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Child-Frames][Child Frames]].
#+END_QUOTE

--- Function: *display-buffer-use-some-frame* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer by finding a frame that meets a predicate (by default any frame other than the selected frame).

  If this function chooses a window on another frame, it makes that frame visible and, unless alist contains an =inhibit-switch-frame= entry, raises that frame if necessary.

  If alist has a non-=nil= =frame-predicate= entry, its value is a function taking one argument (a frame), returning non-=nil= if the frame is a candidate; this function replaces the default predicate.

  If alist has a non-=nil= =inhibit-same-window= entry, the selected window is not used; thus if the selected frame has a single window, it is not used.
#+END_QUOTE

--- Function: *display-buffer-no-window* buffer alist

#+BEGIN_QUOTE
  If alist has a non-=nil= =allow-no-window= entry, then this function does not display buffer and returns the symbol =fail=. This constitutes the only exception to the convention that an action function returns either =nil= or a window showing buffer. If alist has no such =allow-no-window= entry, this function returns =nil=.

  If this function returns =fail=, =display-buffer= will skip the execution of any further display actions and return =nil= immediately. If this function returns =nil=, =display-buffer= will continue with the next display action, if any.

  It is assumed that when a caller of =display-buffer= specifies a non-=nil= =allow-no-window= entry, it is also able to handle a =nil= return value.
#+END_QUOTE

Two other action functions are described in their proper sections---=display-buffer-in-side-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers-in-Side-Windows][Displaying Buffers in Side Windows]]) and =display-buffer-in-atom-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]]).

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window-Options][Choosing Window Options]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]]

** 28.13.3 Action Alists for Buffer Display
     :PROPERTIES:
     :CUSTOM_ID: action-alists-for-buffer-display
     :END:

An action alist is an association list mapping predefined symbols recognized by action functions to values these functions are supposed to interpret accordingly. In each call, =display-buffer= constructs a new, possibly empty action alist and passes that entire list on to any action function it calls.

By design, action functions are free in their interpretation of action alist entries. In fact, some entries like =allow-no-window= or =previous-window= have a meaning only for one or a few action functions, and are ignored by the rest. Other entries, like =inhibit-same-window= or =window-parameters=, are supposed to be respected by most action functions, including those provided by application programs and external packages.

In the previous subsection we have described in detail how individual action functions interpret the action alist entries they care about. Here we give a reference list of all known action alist entries according to their symbols, together with their values and action functions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]) that recognize them. Throughout this list, the terms "buffer" will refer to the buffer =display-buffer= is supposed to display, and "value" refers to the entry's value.

- =inhibit-same-window=

  If the value is non-=nil=, this signals that the selected window must not be used for displaying the buffer. All action functions that (re-)use an existing window should respect this entry.

- =previous-window=

  The value must specify a window that may have displayed the buffer previously. =display-buffer-in-previous-window= will give preference to such a window provided it is still live and not dedicated to another buffer.

- =mode=

  The value is either a major mode or a list of major modes. =display-buffer-reuse-mode-window= may reuse a window whenever the value specified by this entry matches the major mode of that window's buffer. Other action functions ignore such entries.

- =frame-predicate=

  The value must be a function taking one argument (a frame), supposed to return non-=nil= if that frame is a candidate for displaying the buffer. This entry is used by =display-buffer-use-some-frame=.

- =reusable-frames=

  The value specifies the set of frames to search for a window that can be reused because it already displays the buffer. It can be set as follows: =nil= means consider only windows on the selected frame. (Actually, the last frame used that is not a minibuffer-only frame.) =t= means consider windows on all frames. =visible= means consider windows on all visible frames. 0 means consider windows on all visible or iconified frames. A frame means consider windows on that frame only. Note that the meaning of =nil= differs slightly from that of the all-frames argument to =next-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]). A major client of this is =display-buffer-reuse-window=, but all other action functions that try to reuse a window are affected as well. =display-buffer-in-previous-window= consults it when searching for a window that previosuly displayed the buffer on another frame.

- =inhibit-switch-frame=

  A non-=nil= value prevents another frame from being raised or selected, if the window chosen by =display-buffer= is displayed there. Primarily affected by this are =display-buffer-use-some-frame= and =display-buffer-reuse-window=. =display-buffer-pop-up-frame= should be affected as well, but there is no guarantee that the window manager will comply.

- =window-parameters=

  The value specifies an alist of window parameters to give the chosen window. All action functions that choose a window should process this entry.

- =window-height=

  The value specifies whether and how to adjust the height of the chosen window and can be one of the following: =nil= means to leave the height of the chosen window alone. An integer number specifies the desired total height of the chosen window in lines. A floating-point number specifies the fraction of the chosen window's desired total height with respect to the total height of its frame's root window. If the value specifies a function, that function is called with one argument---the chosen window. The function is supposed to adjust the height of the window; its return value is ignored. Suitable functions are =shrink-window-if-larger-than-buffer= and =fit-window-to-buffer=, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]]. By convention, the height of the chosen window is adjusted only if the window is part of a vertical combination (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]) to avoid changing the height of other, unrelated windows. Also, this entry should be processed only under certain conditions which are specified right below this list.

- =window-width=

  This entry is similar to the =window-height= entry described before, but used to adjust the chosen window's width instead. The value can be one of the following: =nil= means to leave the width of the chosen window alone. An integer specifies the desired total width of the chosen window in columns. A floating-point number specifies the fraction of the chosen window's desired total width with respect to the total width of the frame's root window. If the value specifies a function, that function is called with one argument---the chosen window. The function is supposed to adjust the width of the window; its return value is ignored. By convention, the width of the chosen window is adjusted only if the window is part of a horizontal combination (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]) to avoid changing the width of other, unrelated windows. Also, this entry should be processed under only certain conditions which are specified right below this list.

- =preserve-size=

  If non-=nil= such an entry tells Emacs to preserve the size of the window chosen (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]]). The value should be either =(t . nil)= to preserve the width of the window, =(nil . t)= to preserve its height or =(t . t)= to preserve both, its width and its height. This entry should be processed only under certain conditions which are specified right after this list.

- =pop-up-frame-parameters=

  The value specifies an alist of frame parameters to give a new frame, if one is created. =display-buffer-pop-up-frame= is its one and only addressee.

- =parent-frame=

  The value specifies the parent frame to be used when the buffer is displayed on a child frame. This entry is used only by =display-buffer-in-child-frame=.

- =child-frame-parameters=

  The value specifies an alist of frame parameters to use when the buffer is displayed on a child frame. This entry is used only by =display-buffer-in-child-frame=.

- =side=

  The value denotes the side of the frame or window where a new window displaying the buffer shall be created. This entry is used by =display-buffer-in-side-window= to indicate the side of the frame where a new side window shall be placed (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers-in-Side-Windows][Displaying Buffers in Side Windows]]). It is also used by =display-buffer-in-atom-window= to indicate the side of an existing window where the new window shall be located (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]]).

- =slot=

  If non-=nil=, the value specifies the slot of the side window supposed to display the buffer. This entry is used only by =display-buffer-in-side-window=.

- =window=

  The value specifies a window that is in some way related to the window chosen by =display-buffer=. This entry is currently used by =display-buffer-in-atom-window= to indicate the window on whose side the new window shall be created.

- =allow-no-window=

  If the value is non-=nil=, =display-buffer= does not necessarily have to display the buffer and the caller is prepared to accept that. This entry is not intended for user customizations, since there is no guarantee that an arbitrary caller of =display-buffer= will be able to handle the case that no window will display the buffer. =display-buffer-no-window= is the only action function that cares about this entry.

By convention, the entries =window-height=, =window-width= and =preserve-size= are applied after the chosen window's buffer has been set up and if and only if that window never showed another buffer before. More precisely, the latter means that the window must have been either created by the current =display-buffer= call or the window was created earlier by =display-buffer= to show the buffer and never was used to show another buffer until it was reused by the current invocation of =display-buffer=.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Precedence-of-Action-Functions][Precedence of Action Functions]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Alists][Buffer Display Action Alists]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]]

** 28.13.4 Additional Options for Displaying Buffers
     :PROPERTIES:
     :CUSTOM_ID: additional-options-for-displaying-buffers
     :END:

The behavior of buffer display actions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]) can be further modified by the following user options.

--- User Option: *pop-up-windows*

#+BEGIN_QUOTE
  If the value of this variable is non-=nil=, =display-buffer= is allowed to split an existing window to make a new window for displaying in. This is the default.

  This variable is provided for backward compatibility only. It is obeyed by =display-buffer= via a special mechanism in =display-buffer-fallback-action=, which calls the action function =display-buffer-pop-up-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]) when the value of this option is non-=nil=. It is not consulted by =display-buffer-pop-up-window= itself, which the user may specify directly in =display-buffer-alist= etc.
#+END_QUOTE

--- User Option: *split-window-preferred-function*

#+BEGIN_QUOTE
  This variable specifies a function for splitting a window, in order to make a new window for displaying a buffer. It is used by the =display-buffer-pop-up-window= action function to actually split the window.

  The value must be a function that takes one argument, a window, and returns either a new window (which will be used to display the desired buffer) or =nil= (which means the splitting failed). The default value is =split-window-sensibly=, which is documented next.
#+END_QUOTE

--- Function: *split-window-sensibly* &optional window

#+BEGIN_QUOTE
  This function tries to split window and return the newly created window. If window cannot be split, it returns =nil=. If window is omitted or =nil=, it defaults to the selected window.

  This function obeys the usual rules that determine when a window may be split (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]]). It first tries to split by placing the new window below, subject to the restriction imposed by =split-height-threshold= (see below), in addition to any other restrictions. If that fails, it tries to split by placing the new window to the right, subject to =split-width-threshold= (see below). If that also fails, and the window is the only window on its frame, this function again tries to split and place the new window below, disregarding =split-height-threshold=. If this fails as well, this function gives up and returns =nil=.
#+END_QUOTE

--- User Option: *split-height-threshold*

#+BEGIN_QUOTE
  This variable specifies whether =split-window-sensibly= is allowed to split the window placing the new window below. If it is an integer, that means to split only if the original window has at least that many lines. If it is =nil=, that means not to split this way.
#+END_QUOTE

--- User Option: *split-width-threshold*

#+BEGIN_QUOTE
  This variable specifies whether =split-window-sensibly= is allowed to split the window placing the new window to the right. If the value is an integer, that means to split only if the original window has at least that many columns. If the value is =nil=, that means not to split this way.
#+END_QUOTE

--- User Option: *even-window-sizes*

#+BEGIN_QUOTE
  This variable, if non-=nil=, causes =display-buffer= to even window sizes whenever it reuses an existing window, and that window is adjacent to the selected one.

  If its value is =width-only=, sizes are evened only if the reused window is on the left or right of the selected one and the selected window is wider than the reused one. If its value is =height-only= sizes are evened only if the reused window is above or beneath the selected window and the selected window is higher than the reused one. Any other non-=nil= value means to even sizes in any of these cases provided the selected window is larger than the reused one in the sense of their combination.
#+END_QUOTE

--- User Option: *pop-up-frames*

#+BEGIN_QUOTE
  If the value of this variable is non-=nil=, that means =display-buffer= may display buffers by making new frames. The default is =nil=.

  A non-=nil= value also means that when =display-buffer= is looking for a window already displaying buffer-or-name, it can search any visible or iconified frame, not just the selected frame.

  This variable is provided mainly for backward compatibility. It is obeyed by =display-buffer= via a special mechanism in =display-buffer-fallback-action=, which calls the action function =display-buffer-pop-up-frame= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]) if the value is non-=nil=. (This is done before attempting to split a window.) This variable is not consulted by =display-buffer-pop-up-frame= itself, which the user may specify directly in =display-buffer-alist= etc.
#+END_QUOTE

--- User Option: *pop-up-frame-function*

#+BEGIN_QUOTE
  This variable specifies a function for creating a new frame, in order to make a new window for displaying a buffer. It is used by the =display-buffer-pop-up-frame= action function.

  The value should be a function that takes no arguments and returns a frame, or =nil= if no frame could be created. The default value is a function that creates a frame using the parameters specified by =pop-up-frame-alist= (see below).
#+END_QUOTE

--- User Option: *pop-up-frame-alist*

#+BEGIN_QUOTE
  This variable holds an alist of frame parameters (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Parameters][Frame Parameters]]), which is used by the function specified by =pop-up-frame-function= to make a new frame. The default is =nil=.

  This option is provided for backward compatibility only. Note, that when =display-buffer-pop-up-frame= calls the function specified by =pop-up-frame-function=, it prepends the value of all =pop-up-frame-parameters= action alist entries to =pop-up-frame-alist= so that the values specified by the action alist entry effectively override any corresponding values of =pop-up-frame-alist=.

  Hence, users should set up a =pop-up-frame-parameters= action alist entry in =display-buffer-alist= instead of customizing =pop-up-frame-alist=. Only this will guarantee that the value of a parameter specified by the user overrides the value of that parameter specified by the caller of =display-buffer=.
#+END_QUOTE

Many efforts in the design of =display-buffer= have been given to maintain compatibility with code that uses older options like =pop-up-windows=, =pop-up-frames=, =pop-up-frame-alist=, =same-window-buffer-names= and =same-window-regexps=. Lisp Programs and users should refrain from using these options. Above we already warned against customizing =pop-up-frame-alist=. Here we describe how to convert the remaining options to use display actions instead.

- =pop-up-windows=

  This variable is =t= by default. Instead of customizing it to =nil= and thus telling =display-buffer= what not to do, it's much better to list in =display-buffer-base-action= the action functions it should try instead as, for example: =(customize-set-variable           'display-buffer-base-action           '((display-buffer-reuse-window display-buffer-same-window              display-buffer-in-previous-window              display-buffer-use-some-window)))=

- =pop-up-frames=

  Instead of customizing this variable to =t=, customize =display-buffer-base-action=, for example, as follows: =(customize-set-variable           'display-buffer-base-action           '((display-buffer-reuse-window display-buffer-pop-up-frame)             (reusable-frames . 0)))=

- =same-window-buffer-names=

- =same-window-regexps=

  Instead of adding a buffer name or a regular expression to one of these options use a =display-buffer-alist= entry for that buffer specifying the action function =display-buffer-same-window=. =(customize-set-variable           'display-buffer-alist           (cons '("\\*foo\\*" (display-buffer-same-window))                  display-buffer-alist))=

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Zen-of-Buffer-Display][The Zen of Buffer Display]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window-Options][Choosing Window Options]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]]

** 28.13.5 Precedence of Action Functions
     :PROPERTIES:
     :CUSTOM_ID: precedence-of-action-functions
     :END:

From the past subsections we already know that =display-buffer= must be supplied with a number of display actions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]) in order to display a buffer. In a completely uncustomized Emacs, these actions are specified by =display-buffer-fallback-action= in the following order of precedence: Reuse a window, pop up a new window on the same frame, use a window previously showing the buffer, use some window and pop up a new frame. (Note that the remaining actions named by =display-buffer-fallback-action= are void in an uncustomized Emacs).

Consider the following form:

#+BEGIN_EXAMPLE
         (display-buffer (get-buffer-create "*foo*"))
#+END_EXAMPLE

Evaluating this form in the buffer /scratch/ of an uncustomized Emacs session will usually fail to reuse a window that shows /foo/ already, but succeed in popping up a new window. Evaluating the same form again will now not cause any visible changes---=display-buffer= reused the window already showing /foo/ because that action was applicable and had the highest precedence among all applicable actions.

Popping up a new window will fail if there is not enough space on the selected frame. In an uncustomized Emacs it typically fails when there are already two windows on a frame. For example, if you now type C-x 1 followed by C-x 2 and evaluate the form once more, /foo/ should show up in the lower window---=display-buffer= just used "some" window. If, before typing C-x 2 you had typed C-x o, /foo/ would have been shown in the upper window because "some" window stands for the "least recently used" window and the selected window has been least recently used if and only if it is alone on its frame.

Let's assume you did not type C-x o and /foo/ is shown in the lower window. Type C-x o to get there followed by C-x left and evaluate the form again. This should display /foo/ in the same, lower window because that window had already shown /foo/ previously and was therefore chosen instead of some other window.

So far we have only observed the default behavior in an uncustomized Emacs session. To see how this behavior can be customized, let's consider the option =display-buffer-base-action=. It provides a very coarse customization which conceptually affects the display of /any/ buffer. It can be used to supplement the actions supplied by =display-buffer-fallback-action= by reordering them or by adding actions that are not present there but fit more closely the user's editing practice. However, it can also be used to change the default behavior in a more profound way.

Let's consider a user who, as a rule, prefers to display buffers on another frame. Such a user might provide the following customization:

#+BEGIN_EXAMPLE
         (customize-set-variable
          'display-buffer-base-action
          '((display-buffer-reuse-window display-buffer-pop-up-frame)
            (reusable-frames . 0)))
#+END_EXAMPLE

This setting will cause =display-buffer= to first try to find a window showing the buffer on a visible or iconified frame and, if no such frame exists, pop up a new frame. You can observe this behavior on a graphical system by typing C-x 1 in the window showing /scratch/ and evaluating our canonical =display-buffer= form. This will usually create (and give focus to) a new frame whose root window shows /foo/. Iconify that frame and evaluate the canonical form again: =display-buffer= will reuse the window on the new frame (usually raising the frame and giving it focus too).

Only if creating a new frame fails, =display-buffer= will apply the actions supplied by =display-buffer-fallback-action= which means to again try reusing a window, popping up a new window and so on. A trivial way to make frame creation fail is supplied by the following form:

#+BEGIN_EXAMPLE
         (let ((pop-up-frame-function 'ignore))
           (display-buffer (get-buffer-create "*foo*")))
#+END_EXAMPLE

We will forget about that form immediately after observing that it fails to create a new frame and uses a fallback action instead.

Note that =display-buffer-reuse-window= appears redundant in the customization of =display-buffer-base-action= because it is already part of =display-buffer-fallback-action= and should be tried there anyway. However, that would fail because due to the precedence of =display-buffer-base-action= over =display-buffer-fallback-action=, at that time =display-buffer-pop-up-frame= would have already won the race. In fact, this:

#+BEGIN_EXAMPLE
         (customize-set-variable
          'display-buffer-base-action
          '(display-buffer-pop-up-frame (reusable-frames . 0)))
#+END_EXAMPLE

would cause =display-buffer= to /always/ pop up a new frame which is probably not what our user wants.

So far, we have only shown how /users/ can customize the default behavior of =display-buffer=. Let us now see how /applications/ can change the course of =display-buffer=. The canonical way to do that is to use the action argument of =display-buffer= or a function that calls it, like, for example, =pop-to-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]]).

Suppose an application wants to display /foo/ preferably below the selected window (to immediately attract the attention of the user to the new window) or, if that fails, in a window at the bottom of the frame. It could do that with a call like this:

#+BEGIN_EXAMPLE
         (display-buffer
          (get-buffer-create "*foo*")
          '((display-buffer-below-selected display-buffer-at-bottom)))
#+END_EXAMPLE

In order to see how this new, modified form works, delete any frame showing /foo/, type C-x 1 followed by C-x 2 in the window showing /scratch/, and subsequently evaluate that form. =display-buffer= should split the upper window, and show /foo/ in the new window. Alternatively, if after C-x 2 you had typed C-x o, =display-buffer= would have split the window at the bottom instead.

Suppose now that, before evaluating the new form, you have made the selected window as small as possible, for example, by evaluating the form =(fit-window-to-buffer)= in that window. In that case, =display-buffer= would have failed to split the selected window and would have split the frame's root window instead, effectively displaying /foo/ at the bottom of the frame.

In either case, evaluating the new form a second time should reuse the window already showing /foo/ since both functions supplied by the action argument try to reuse such a window first.

By setting the action argument, an application effectively overrules any customization of =display-buffer-base-action=. Our user can now either accept the choice of the application, or redouble by customizing the option =display-buffer-alist= as follows:

#+BEGIN_EXAMPLE
         (customize-set-variable
          'display-buffer-alist
          '(("\\*foo\\*"
             (display-buffer-reuse-window display-buffer-pop-up-frame))))
#+END_EXAMPLE

Trying this with the new, modified form above in a configuration that does not show /foo/ anywhere, will display /foo/ on a separate frame, completely ignoring the action argument of =display-buffer=.

Note that we didn't care to specify a =reusable-frames= action alist entry in our specification of =display-buffer-alist=. =display-buffer= always takes the first one it finds---in our case the one specified by =display-buffer-base-action=. If we wanted to use a different specification, for example, to exclude iconified frames showing /foo/ from the list of reusable ones, we would have to specify that separately, however:

#+BEGIN_EXAMPLE
         (customize-set-variable
          'display-buffer-alist
          '(("\\*foo\\*"
             (display-buffer-reuse-window display-buffer-pop-up-frame)
             (reusable-frames . visible))))
#+END_EXAMPLE

If you try this, you will notice that repeated attempts to display /foo/ will succeed to reuse a frame only if that frame is visible.

The above example would allow the conclusion that users customize =display-buffer-alist= for the sole purpose to overrule the action argument chosen by applications. Such a conclusion would be incorrect. =display-buffer-alist= is the standard option for users to direct the course of display of specific buffers in a preferred way regardless of whether the display is also guided by an action argument.

We can, however, reasonably conclude that customizing =display-buffer-alist= differs from customizing =display-buffer-base-action= in two major aspects: it is stronger because it overrides the action argument of =display-buffer=, and it allows to explicitly specify the affected buffers. In fact, displaying other buffers is not affected in any way by a customization for /foo/. For example,

#+BEGIN_EXAMPLE
         (display-buffer (get-buffer-create "*bar*"))
#+END_EXAMPLE

continues being governed by the settings of =display-buffer-base-action= and =display-buffer-fallback-action= only.

We could stop with our examples here but Lisp programs still have an ace up their sleeves which they can use to overrule any customization of =display-buffer-alist=. It's the variable =display-buffer-overriding-action= which they can bind around =display-buffer= calls as follows:

#+BEGIN_EXAMPLE
         (let ((display-buffer-overriding-action
                '((display-buffer-same-window))))
           (display-buffer
            (get-buffer-create "*foo*")
            '((display-buffer-below-selected display-buffer-at-bottom))))
#+END_EXAMPLE

Evaluating this form will usually display /foo/ in the selected window regardless of the action argument and any user customizations. (Usually, an application will not bother to also provide an action argument. Here it just serves to illustrate the fact that it gets overridden.)

It might be illustrative to look at the list of action functions =display-buffer= would have tried to display /foo/ with the customizations we provided here. The list (including comments explaining who added this and the subsequent elements) is:

#+BEGIN_EXAMPLE
         (display-buffer-same-window  ;; `display-buffer-overriding-action'
          display-buffer-reuse-window ;; `display-buffer-alist'
          display-buffer-pop-up-frame
          display-buffer-below-selected ;; ACTION argument
          display-buffer-at-bottom

          display-buffer-reuse-window ;; `display-buffer-base-action'
          display-buffer-pop-up-frame
          display-buffer--maybe-same-window ;; `display-buffer-fallback-action'
          display-buffer-reuse-window
          display-buffer--maybe-pop-up-frame-or-window
          display-buffer-in-previous-window
          display-buffer-use-some-window
          display-buffer-pop-up-frame)
#+END_EXAMPLE

Note that among the internal functions listed here, =display-buffer--maybe-same-window= is effectively ignored while =display-buffer--maybe-pop-up-frame-or-window= actually runs =display-buffer-pop-up-window=.

The action alist passed in each function call is:

#+BEGIN_EXAMPLE
         ((reusable-frames . visible)
          (reusable-frames . 0))
#+END_EXAMPLE

which shows that we have used the second specification of =display-buffer-alist= above, overriding the specification supplied by =display-buffer-base-action=. Suppose our user had written that as

#+BEGIN_EXAMPLE
         (customize-set-variable
          'display-buffer-alist
          '(("\\*foo\\*"
             (display-buffer-reuse-window display-buffer-pop-up-frame)
             (inhibit-same-window . t)
             (reusable-frames . visible))))
#+END_EXAMPLE

In this case the =inhibit-same-window= alist entry will successfully invalidate the =display-buffer-same-window= specification from =display-buffer-overriding-action= and =display-buffer= will show /foo/ on another frame. To make =display-buffer-overriding-action= more robust in this regard, the application would have to specify an appropriate =inhibit-same-window= entry too, for example, as follows:

#+BEGIN_EXAMPLE
         (let ((display-buffer-overriding-action
                '(display-buffer-same-window (inhibit-same-window . nil))))
           (display-buffer (get-buffer-create "*foo*")))
#+END_EXAMPLE

This last example shows that while the precedence order of action functions is fixed, as described in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]], an action alist entry specified by a display action ranked lower in that order can affect the execution of a higher ranked display action.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Precedence-of-Action-Functions][Precedence of Action Functions]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]]

** 28.13.6 The Zen of Buffer Display
     :PROPERTIES:
     :CUSTOM_ID: the-zen-of-buffer-display
     :END:

In its most simplistic form, a frame accommodates always one single window that can be used for displaying a buffer. As a consequence, it is always the latest call of =display-buffer= that will have succeeded in placing its buffer there.

Since working with such a frame is not very practical, Emacs by default allows for more complex frame layouts controlled by the default values of the frame size and the =split-height-threshold= and =split-width-threshold= options. Displaying a buffer not yet shown on a frame then either splits the single window on that frame or (re-)uses one of its two windows.

The default behavior is abandoned as soon as the user customizes one of these thresholds or manually changes the frame's layout. The default behavior is also abandoned when calling =display-buffer= with a non-=nil= action argument or the user customizes one of the options mentioned in the previous subsections. Mastering =display-buffer= soon may become a frustrating experience due to the plethora of applicable display actions and the resulting frame layouts.

However, refraining from using buffer display functions and falling back on a split & delete windows metaphor is not a good idea either. Buffer display functions give Lisp programs and users a framework to reconcile their different needs; no comparable framework exists for splitting and deleting windows. Buffer display functions also allow to at least partially restore the layout of a frame when removing a buffer from it later (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]]).

Below we will give a number of guidelines to redeem the frustration mentioned above and thus to avoid literally losing buffers in-between the windows of a frame.

- Write display actions without stress

  Writing display actions can be a pain because one has to lump together action functions and action alists in one huge list. (Historical reasons prevented us from having =display-buffer= support separate arguments for these.) It might help to memorize some basic forms like the ones listed below: ='(nil (inhibit-same-window . t))= specifies an action alist entry only and no action function. Its sole purpose is to inhibit a =display-buffer-same-window= function specified elsewhere from showing the buffer in the same window, see also the last example of the preceding subsection. ='(display-buffer-below-selected)= on the other hand, specifies one action function and an empty action alist. To combine the effects of the above two specifications one would write the form ='(display-buffer-below-selected (inhibit-same-window . t))= to add another action function one would write ='((display-buffer-below-selected display-buffer-at-bottom)            (inhibit-same-window . t))= and to add another alist entry one would write ='((display-buffer-below-selected display-buffer-at-bottom)            (inhibit-same-window . t)            (window-height . fit-window-to-buffer))= That last form can be used as action argument of =display-buffer= in the following way: =(display-buffer           (get-buffer-create "*foo*")           '((display-buffer-below-selected display-buffer-at-bottom)             (inhibit-same-window . t)             (window-height . fit-window-to-buffer)))= In a customization of =display-buffer-alist= it would be used as follows: =(customize-set-variable           'display-buffer-alist           '(("\\*foo\\*"              (display-buffer-below-selected display-buffer-at-bottom)              (inhibit-same-window . t)              (window-height . fit-window-to-buffer))))= To add a customization for a second buffer one would then write: =(customize-set-variable           'display-buffer-alist           '(("\\*foo\\*"              (display-buffer-below-selected display-buffer-at-bottom)              (inhibit-same-window . t)              (window-height . fit-window-to-buffer))             ("\\*bar\\*"              (display-buffer-reuse-window display-buffer-pop-up-frame)              (reusable-frames . visible))))=

- Treat each other with respect

  =display-buffer-alist= and =display-buffer-base-action= are user options---Lisp programs must never set or rebind them. =display-buffer-overriding-action=, on the other hand, is reserved for applications---who seldom use that option and if they use it, then with utmost care. Older implementations of =display-buffer= frequently caused users and applications to fight over the settings of user options like =pop-up-frames= and =pop-up-windows= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window-Options][Choosing Window Options]]). This was one major reason for redesigning =display-buffer=---to provide a clear framework specifying what users and applications should be allowed to do. Lisp programs must be prepared that user customizations may cause buffers to get displayed in an unexpected way. They should never assume in their subsequent behavior, that the buffer has been shown precisely the way they asked for in the action argument of =display-buffer=. Users should not pose too many and too severe restrictions on how arbitrary buffers get displayed. Otherwise, they will risk to lose the characteristics of showing a buffer for a certain purpose. Suppose a Lisp program has been written to compare different versions of a buffer in two windows side-by-side. If the customization of =display-buffer-alist= prescribes that any such buffer should be always shown in or below the selected window, the program will have a hard time to set up the desired window configuration via =display-buffer=. To specify a preference for showing an arbitrary buffer, users should customize =display-buffer-base-action=. An example of how users who prefer working with multiple frames would do that was given in the previous subsection. =display-buffer-alist= should be reserved for displaying specific buffers in a specific way.

- Consider reusing a window that already shows the buffer

  Generally, it's always a good idea for users and Lisp programmers to be prepared for the case that a window already shows the buffer in question and to reuse that window. In the preceding subsection we have shown that failing to do so properly may cause =display-buffer= to continuously pop up a new frame although a frame showing that buffer existed already. In a few cases only, it might be undesirable to reuse a window, for example, when a different portion of the buffer should be shown in that window. Hence, =display-buffer-reuse-window= is one action function that should be used as often as possible, both in action arguments and customizations. An =inhibit-same-window= entry in the action argument usually takes care of the most common case where reusing a window showing the buffer should be avoided---that where the window in question is the selected one.

- Attract focus to the window chosen

  This is a no-brainer for people working with multiple frames---the frame showing the buffer will automatically raise and get focus unless an =inhibit-switch-frame= entry forbids it. For single frame users this task can be considerably more difficult. In particular, =display-buffer-pop-up-window= and =display-buffer-use-some-window= can become obtrusive in this regard. They split or use a seemingly arbitrary (often the largest or least recently used) window, distracting the user's attention. Some Lisp programs therefore try to choose a window at the bottom of the frame, for example, in order to display the buffer in vicinity of the minibuffer window where the user is expected to answer a question related to the new window. For non-input related actions =display-buffer-below-selected= might be preferable because the selected window usually already has the user's attention.

- Handle subsequent invocations of =display-buffer=

  =display-buffer= is not overly well suited for displaying several buffers in sequence and making sure that all these buffers are shown orderly in the resulting window configuration. Again, the standard action functions =display-buffer-pop-up-window= and =display-buffer-use-some-window= are not very suited for this purpose due to their somewhat chaotic nature in more complex configurations. To produce a window configuration displaying multiple buffers (or different views of one and the same buffer) in one and the same display cycle, Lisp programmers will unavoidably have to write their own action functions. A few tricks listed below might help in this regard. Making windows atomic (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]]) avoids breaking an existing window composition when popping up a new window. The new window will pop up outside the composition instead. Temporarily dedicating windows to their buffers (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]) avoids using a window for displaying a different buffer. A non-dedicated window will be used instead. Calling =window-preserve-size= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]]) will try to keep the size of the argument window unchanged when popping up a new window. You have to make sure that another window in the same combination can be shrunk instead, though. Side windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]) can be used for displaying specific buffers always in a window at the same position of a frame. This permits grouping buffers that do not compete for being shown at the same time on a frame and showing any such buffer in the same window without disrupting the display of other buffers. Child frames (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Child-Frames][Child Frames]]) can be used to display a buffer within the screen estate of the selected frame without disrupting that frame's window configuration and without the overhead associated with full-fledged frames as inflicted by =display-buffer-pop-up-frame=.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers][Displaying Buffers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.14 Window History
    :PROPERTIES:
    :CUSTOM_ID: window-history
    :END:

Each window remembers in a list the buffers it has previously displayed, and the order in which these buffers were removed from it. This history is used, for example, by =replace-buffer-in-windows= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]]), and when quitting windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]]). The list is automatically maintained by Emacs, but you can use the following functions to explicitly inspect or alter it:

--- Function: *window-prev-buffers* &optional window

#+BEGIN_QUOTE
  This function returns a list specifying the previous contents of window. The optional argument window should be a live window and defaults to the selected one.

  Each list element has the form =(=buffer window-start window-pos=)=, where buffer is a buffer previously shown in the window, window-start is the window start position (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Start-and-End][Window Start and End]]) when that buffer was last shown, and window-pos is the point position (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Point][Window Point]]) when that buffer was last shown in window.

  The list is ordered so that earlier elements correspond to more recently-shown buffers, and the first element usually corresponds to the buffer most recently removed from the window.
#+END_QUOTE

--- Function: *set-window-prev-buffers* window prev-buffers

#+BEGIN_QUOTE
  This function sets window's previous buffers to the value of prev-buffers. The argument window must be a live window and defaults to the selected one. The argument prev-buffers should be a list of the same form as that returned by =window-prev-buffers=.
#+END_QUOTE

In addition, each window maintains a list of next buffers, which is a list of buffers re-shown by =switch-to-prev-buffer= (see below). This list is mainly used by =switch-to-prev-buffer= and =switch-to-next-buffer= for choosing buffers to switch to.

--- Function: *window-next-buffers* &optional window

#+BEGIN_QUOTE
  This function returns the list of buffers recently re-shown in window via =switch-to-prev-buffer=. The window argument must denote a live window or =nil= (meaning the selected window).
#+END_QUOTE

--- Function: *set-window-next-buffers* window next-buffers

#+BEGIN_QUOTE
  This function sets the next buffer list of window to next-buffers. The window argument should be a live window or =nil= (meaning the selected window). The argument next-buffers should be a list of buffers.
#+END_QUOTE

The following commands can be used to cycle through the global buffer list, much like =bury-buffer= and =unbury-buffer=. However, they cycle according to the specified window's history list, rather than the global buffer list. In addition, they restore window-specific window start and point positions, and may show a buffer even if it is already shown in another window. The =switch-to-prev-buffer= command, in particular, is used by =replace-buffer-in-windows=, =bury-buffer= and =quit-window= to find a replacement buffer for a window.

--- Command: *switch-to-prev-buffer* &optional window bury-or-kill

#+BEGIN_QUOTE
  This command displays the previous buffer in window. The argument window should be a live window or =nil= (meaning the selected window). If the optional argument bury-or-kill is non-=nil=, this means that the buffer currently shown in window is about to be buried or killed and consequently should not be switched to in future invocations of this command.

  The previous buffer is usually the buffer shown before the buffer currently shown in window. However, a buffer that has been buried or killed, or has been already shown by a recent invocation of =switch-to-prev-buffer=, does not qualify as previous buffer.

  If repeated invocations of this command have already shown all buffers previously shown in window, further invocations will show buffers from the buffer list of the frame window appears on (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]), trying to skip buffers that are already shown in another window on that frame.
#+END_QUOTE

--- Command: *switch-to-next-buffer* &optional window

#+BEGIN_QUOTE
  This command switches to the next buffer in window, thus undoing the effect of the last =switch-to-prev-buffer= command in window. The argument window must be a live window and defaults to the selected one.

  If there is no recent invocation of =switch-to-prev-buffer= that can be undone, this function tries to show a buffer from the buffer list of the frame window appears on (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]).
#+END_QUOTE

By default =switch-to-prev-buffer= and =switch-to-next-buffer= can switch to a buffer that is already shown in another window on the same frame. The following option can be used to override this behavior.

--- User Option: *switch-to-visible-buffer*

#+BEGIN_QUOTE
  If this variable is non-=nil=, =switch-to-prev-buffer= and =switch-to-next-buffer= may switch to a buffer that is already visible on the same frame, provided the buffer was shown in the relevant window before. If it is =nil=, =switch-to-prev-buffer= and =switch-to-next-buffer= always try to avoid switching to a buffer that is already visible in another window on the same frame. The default is =t=.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.15 Dedicated Windows
    :PROPERTIES:
    :CUSTOM_ID: dedicated-windows
    :END:

Functions for displaying a buffer can be told to not use specific windows by marking these windows as dedicated to their buffers. =display-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]) never uses a dedicated window for displaying another buffer in it. =get-lru-window= and =get-largest-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]) do not consider dedicated windows as candidates when their dedicated argument is non-=nil=. The behavior of =set-window-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]]) with respect to dedicated windows is slightly different, see below.

Functions supposed to remove a buffer from a window or a window from a frame can behave specially when a window they operate on is dedicated. We will distinguish three basic cases, namely where (1) the window is not the only window on its frame, (2) the window is the only window on its frame but there are other frames on the same terminal left, and (3) the window is the only window on the only frame on the same terminal.

In particular, =delete-windows-on= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]) handles case (2) by deleting the associated frame and case (3) by showing another buffer in that frame's only window. The function =replace-buffer-in-windows= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]]) which is called when a buffer gets killed, deletes the window in case (1) and behaves like =delete-windows-on= otherwise.

When =bury-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]) operates on the selected window (which shows the buffer that shall be buried), it handles case (2) by calling =frame-auto-hide-function= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]]) to deal with the selected frame. The other two cases are handled as with =replace-buffer-in-windows=.

--- Function: *window-dedicated-p* &optional window

#+BEGIN_QUOTE
  This function returns non-=nil= if window is dedicated to its buffer and =nil= otherwise. More precisely, the return value is the value assigned by the last call of =set-window-dedicated-p= for window, or =nil= if that function was never called with window as its argument. The default for window is the selected window.
#+END_QUOTE

--- Function: *set-window-dedicated-p* window flag

#+BEGIN_QUOTE
  This function marks window as dedicated to its buffer if flag is non-=nil=, and non-dedicated otherwise.

  As a special case, if flag is =t=, window becomes strongly dedicated to its buffer. =set-window-buffer= signals an error when the window it acts upon is strongly dedicated to its buffer and does not already display the buffer it is asked to display. Other functions do not treat =t= differently from any non-=nil= value.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.16 Quitting Windows
    :PROPERTIES:
    :CUSTOM_ID: quitting-windows
    :END:

When you want to get rid of a window used for displaying a buffer, you can call =delete-window= or =delete-windows-on= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]) to remove that window from its frame. If the buffer is shown on a separate frame, you might want to call =delete-frame= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Frames][Deleting Frames]]) instead. If, on the other hand, a window has been reused for displaying the buffer, you might prefer showing the buffer previously shown in that window, by calling the function =switch-to-prev-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]]). Finally, you might want to either bury (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]) or kill (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Killing-Buffers][Killing Buffers]]) the window's buffer.

The following command uses information on how the window for displaying the buffer was obtained in the first place, thus attempting to automate the above decisions for you.

--- Command: *quit-window* &optional kill window

#+BEGIN_QUOTE
  This command quits window and buries its buffer. The argument window must be a live window and defaults to the selected one. With prefix argument kill non-=nil=, it kills the buffer instead of burying it. It calls the function =quit-restore-window= described next to deal with the window and its buffer.
#+END_QUOTE

--- Function: *quit-restore-window* &optional window bury-or-kill

#+BEGIN_QUOTE
  This function handles window and its buffer after quitting. The optional argument window must be a live window and defaults to the selected one. The function's behavior is determined by the four elements of the list specified by window's =quit-restore= parameter (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]]).

  The first element of the =quit-restore= parameter is one of the symbols =window=, meaning that the window has been specially created by =display-buffer=; =frame=, a separate frame has been created; =same=, the window has only ever displayed this buffer; or =other=, the window showed another buffer before. =frame= and =window= affect how the window is quit, while =same= and =other= affect the redisplay of buffers previously shown in window.

  The parameter's second element is either one of the symbols =window= or =frame=, or a list whose elements are the buffer shown in window before, that buffer's window start and window point positions, and window's height at that time. If that buffer is still live when window is quit, then this function may reuse window to display it.

  The third element is the window selected at the time the parameter was created. If this function deletes window, it subsequently tries to reselect the window named by that element.

  The fourth element is the buffer whose display caused the creation of this parameter. This function may delete window if and only if it still shows that buffer.

  This function will try to delete window if and only if (1) the first element of its =quit-restore= parameter is either =window= or =frame=, (2) the window has no history of previously-displayed buffers and (3) the fourth element of the =quit-restore= parameter specifies the buffer currently displayed in window. If window is part of an atomic window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]]), it will try to delete the root of that atomic window instead. In either case, it tries to avoid signaling an error when window cannot be deleted.

  If window shall be deleted, is the only window on its frame and there are other frames on that frame's terminal, the value of the optional argument bury-or-kill determines how to proceed with the window. If bury-or-kill equals =kill=, the frame is deleted unconditionally. Otherwise, the fate of the frame is determined by calling =frame-auto-hide-function= (see below) with that frame as sole argument.

  If the third element of the =quit-restore= parameter is a list of buffer, window start (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Start-and-End][Window Start and End]]), and point (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Point][Window Point]]), and that buffer is still live, the buffer will be displayed, and start and point set accordingly. If, in addition, window's buffer was temporarily resized, this function will also try to restore the original height of window.

  Otherwise, if window was previously used for displaying other buffers (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]]), the most recent buffer in that history will be displayed. In either case, if window is not deleted, its =quit-restore= parameter is reset to =nil=.

  The optional argument bury-or-kill specifies how to deal with window's buffer. The following values are handled:

  - =nil=

    This means to not deal with the buffer in any particular way. As a consequence, if window is not deleted, invoking =switch-to-prev-buffer= will usually show the buffer again.

  - =append=

    This means that if window is not deleted, its buffer is moved to the end of window's list of previous buffers, so it's less likely that a future invocation of =switch-to-prev-buffer= will switch to it. Also, it moves the buffer to the end of the frame's buffer list.

  - =bury=

    This means that if window is not deleted, its buffer is removed from window's list of previous buffers. Also, it moves the buffer to the end of the frame's buffer list. This value provides the most reliable remedy to not have =switch-to-prev-buffer= switch to this buffer again without killing the buffer.

  - =kill=

    This means to kill window's buffer.

  Typically, the display routines run by =display-buffer= will set the =quit-restore= window parameter correctly. It's also possible to set it manually, using the following code for displaying buffer in window:

  #+BEGIN_EXAMPLE
                (display-buffer-record-window type window buffer)

                (set-window-buffer window buffer)

                (set-window-prev-buffers window nil)
  #+END_EXAMPLE

  Setting the window history to =nil= ensures that a future call to =quit-window= can delete the window altogether.
#+END_QUOTE

The following option specifies how to deal with a frame containing just one window that should be either quit, or whose buffer should be buried.

--- User Option: *frame-auto-hide-function*

#+BEGIN_QUOTE
  The function specified by this option is called to automatically hide frames. This function is called with one argument---a frame.

  The function specified here is called by =bury-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]) when the selected window is dedicated and shows the buffer to bury. It is also called by =quit-restore-window= (see above) when the frame of the window to quit has been specially created for displaying that window's buffer and the buffer is not killed.

  The default is to call =iconify-frame= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Visibility-of-Frames][Visibility of Frames]]). Alternatively, you may specify either =delete-frame= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Frames][Deleting Frames]]) to remove the frame from its display, =make-frame-invisible= to make the frame invisible, =ignore= to leave the frame unchanged, or any other function that can take a frame as its sole argument.

  Note that the function specified by this option is called only if the specified frame contains just one live window and there is at least one other frame on the same terminal.

  For a particular frame, the value specified here may be overridden by that frame's =auto-hide-function= frame parameter (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Interaction-Parameters][Frame Interaction Parameters]]).
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.17 Side Windows
    :PROPERTIES:
    :CUSTOM_ID: side-windows
    :END:

Side windows are special windows positioned at any of the four sides of a frame's root window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]). In practice, this means that the area of the frame's root window is subdivided into a main window and a number of side windows surrounding that main window. The main window is either a "normal" live window or specifies the area containing all the normal windows.

In their most simple form of use, side windows allow to display specific buffers always in the same area of a frame. Hence they can be regarded as a generalization of the concept provided by =display-buffer-at-bottom= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]) to the remaining sides of a frame. With suitable customizations, however, side windows can be also used to provide frame layouts similar to those found in so-called integrated development environments (IDEs).

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers-in-Side-Windows][Displaying Buffers in Side Windows]]: An action function for displaying buffers in side windows.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Window-Options-and-Functions][Side Window Options and Functions]]: Further tuning of side windows.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Layouts-with-Side-Windows][Frame Layouts with Side Windows]]: Setting up frame layouts with side windows.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Window-Options-and-Functions][Side Window Options and Functions]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]

** 28.17.1 Displaying Buffers in Side Windows
     :PROPERTIES:
     :CUSTOM_ID: displaying-buffers-in-side-windows
     :END:

The following action function for =display-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]) creates or reuses a side window for displaying the specified buffer.

--- Function: *display-buffer-in-side-window* buffer alist

#+BEGIN_QUOTE
  This function displays buffer in a side window of the selected frame. It returns the window used for displaying buffer, =nil= if no such window can be found or created.

  alist is an association list of symbols and values as for =display-buffer=. The following symbols in alist are special for this function:

  - =side=

    Denotes the side of the frame where the window shall be located. Valid values are =left=, =top=, =right= and =bottom=. If unspecified, the window is located at the bottom of the frame.

  - =slot=

    Denotes a slot at the specified side where to locate the window. A value of zero means to preferably position the window in the middle of the specified side. A negative value means to use a slot preceding (that is, above or on the left of) the middle slot. A positive value means to use a slot following (that is, below or on the right of) the middle slot. Hence, all windows on a specific side are ordered by their =slot= value. If unspecified, the window is located in the middle of the specified side.

  If you specify the same slot on the same side for two or more different buffers, the buffer displayed last is shown in the corresponding window. Hence, slots can be used for sharing the same side window between buffers.

  This function installs the =window-side= and =window-slot= parameters (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]]) and makes them persistent. It does not install any other window parameters unless they have been explicitly provided via a =window-parameters= entry in alist.
#+END_QUOTE

By default, side windows cannot be split via =split-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]]). Also, a side window is not reused or split by any buffer display action (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]) unless it is explicitly specified as target of that action. Note also that =delete-other-windows= cannot make a side window the only window on its frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]).

Once set up, side windows also change the behavior of the commands =switch-to-prev-buffer= and =switch-to-next-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]]). In particular, these commands will refrain from showing, in a side window, buffers that have not been displayed in that window before. They will also refrain from having a normal, non-side window show a buffer that has been already displayed in a side window. A notable exception to the latter rule occurs when an application, after displaying a buffer, resets that buffer's local variables.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Layouts-with-Side-Windows][Frame Layouts with Side Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers-in-Side-Windows][Displaying Buffers in Side Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]

** 28.17.2 Side Window Options and Functions
     :PROPERTIES:
     :CUSTOM_ID: side-window-options-and-functions
     :END:

The following options provide additional control over the placement of side windows.

--- User Option: *window-sides-vertical*

#+BEGIN_QUOTE
  If non-=nil=, the side windows on the left and right of a frame occupy the frame's full height. Otherwise, the side windows on the top and bottom of the frame occupy the frame's full width.
#+END_QUOTE

--- User Option: *window-sides-slots*

#+BEGIN_QUOTE
  This option specifies the maximum number of side windows on each side of a frame. The value is a list of four elements specifying the number of side window slots on (in this order) the left, top, right and bottom of each frame. If an element is a number, it means to display at most that many windows on the corresponding side. If an element is =nil=, it means there's no bound on the number of slots on that side.

  If any of the specified values is zero, no window can be created on the corresponding side. =display-buffer-in-side-window= will not signal an error in that case, but will return =nil=. If a specified value just forbids the creation of an additional side window, the most suitable window on that side is reused and may have its =window-slot= parameter changed accordingly.
#+END_QUOTE

--- User Option: *window-sides-reversed*

#+BEGIN_QUOTE
  This option specifies whether top/bottom side windows should appear in reverse order. When this is =nil=, side windows on the top and bottom of a frame are always drawn from left to right with increasing slot values. When this is =t=, the drawing order is reversed and side windows on the top and bottom of a frame are drawn from right to left with increasing slot values.

  When this is =bidi=, the drawing order is reversed if and only if the value of =bidi-paragraph-direction= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Bidirectional-Display][Bidirectional Display]]) is =right-to-left= in the buffer displayed in the window most recently selected within the main window area of this frame. Sometimes that window may be hard to find, so heuristics are used to avoid that the drawing order changes inadvertently when another window gets selected.

  The layout of side windows on the left or right of a frame is not affected by the value of this variable.
#+END_QUOTE

When a frame has side windows, the following function returns the main window of that frame.

--- Function: *window-main-window* &optional frame

#+BEGIN_QUOTE
  This function returns the main window of the specified frame. The optional argument frame must be a live frame and defaults to the selected one.

  If frame has no side windows, it returns frame's root window. Otherwise, it returns either an internal non-side window such that all other non-side windows on frame descend from it, or the single live non-side window of frame. Note that the main window of a frame cannot be deleted via =delete-window=.
#+END_QUOTE

The following command is handy to toggle the appearance of all side windows on a specified frame.

--- Command: *window-toggle-side-windows* &optional frame

#+BEGIN_QUOTE
  This command toggles side windows on the specified frame. The optional argument frame must be a live frame and defaults to the selected one.

  If frame has at least one side window, this command saves the state of frame's root window in the frame's =window-state= frame parameter and deletes all side windows on frame afterwards.

  If frame has no side windows, but does have a =window-state= parameter, this command uses that parameter's value to restore the side windows on frame leaving frame's main window alone.

  An error is signaled if frame has no side windows and no saved state is found for it.
#+END_QUOTE

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Window-Options-and-Functions][Side Window Options and Functions]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]

** 28.17.3 Frame Layouts with Side Windows
     :PROPERTIES:
     :CUSTOM_ID: frame-layouts-with-side-windows
     :END:

Side windows can be used to create more complex frame layouts like those provided by integrated development environments (IDEs). In such layouts, the area of the main window is where the normal editing activities take place. Side windows are not conceived for editing in the usual sense. Rather, they are supposed to display information complementary to the current editing activity, like lists of files, tags or buffers, help information, search or grep results or shell output.

The layout of such a frame might appear as follows:

#+BEGIN_EXAMPLE
              ___________________________________
             |          *Buffer List*            |
             |___________________________________|
             |     |                       |     |
             |  *  |                       |  *  |
             |  d  |                       |  T  |
             |  i  |                       |  a  |
             |  r  |   Main Window Area    |  g  |
             |  e  |                       |  s  |
             |  d  |                       |  *  |
             |  *  |                       |     |
             |_____|_______________________|_____|
             | *help*/*grep*/  |  *shell*/       |
             | *Completions*   |  *compilation*  |
             |_________________|_________________|
             |             Echo Area             |
             |___________________________________|
#+END_EXAMPLE

The following example illustrates how window parameters (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]]) can be used with =display-buffer-in-side-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Displaying-Buffers-in-Side-Windows][Displaying Buffers in Side Windows]]) to set up code for producing the frame layout sketched above.

#+BEGIN_EXAMPLE
         (defvar parameters
           '(window-parameters . ((no-other-window . t)
                                  (no-delete-other-windows . t))))

         (setq fit-window-to-buffer-horizontally t)
         (setq window-resize-pixelwise t)

         (setq
          display-buffer-alist
          `(("\\*Buffer List\\*" display-buffer-in-side-window
             (side . top) (slot . 0) (window-height . fit-window-to-buffer)
             (preserve-size . (nil . t)) ,parameters)
            ("\\*Tags List\\*" display-buffer-in-side-window
             (side . right) (slot . 0) (window-width . fit-window-to-buffer)
             (preserve-size . (t . nil)) ,parameters)
            ("\\*\\(?:help\\|grep\\|Completions\\)\\*"
             display-buffer-in-side-window
             (side . bottom) (slot . -1) (preserve-size . (nil . t))
             ,parameters)
            ("\\*\\(?:shell\\|compilation\\)\\*" display-buffer-in-side-window
             (side . bottom) (slot . 1) (preserve-size . (nil . t))
             ,parameters)))
#+END_EXAMPLE

This specifies =display-buffer-alist= entries (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]) for buffers with fixed names. In particular, it asks for showing /Buffer List/ with adjustable height at the top of the frame and /Tags List/ with adjustable width on the frame's right. It also asks for having the /help/, /grep/ and /Completions/ buffers share a window on the bottom left side of the frame and the /shell/ and /compilation/ buffers appear in a window on the bottom right side of the frame.

Note that the option =fit-window-to-buffer-horizontally= must have a non-=nil= value in order to allow horizontal adjustment of windows. Entries are also added that ask for preserving the height of side windows at the top and bottom of the frame and the width of side windows at the left or right of the frame. To assure that side windows retain their respective sizes when maximizing the frame, the variable =window-resize-pixelwise= is set to a non-=nil= value. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Resizing-Windows][Resizing Windows]].

The last form also makes sure that none of the created side windows are accessible via C-x o by installing the =no-other-window= parameter for each of these windows. In addition, it makes sure that side windows are not deleted via C-x 1 by installing the =no-delete-other-windows= parameter for each of these windows.

Since =dired= buffers have no fixed names, we use a special function =dired-default-directory-on-left= in order to display a lean directory buffer on the left side of the frame.

#+BEGIN_EXAMPLE
         (defun dired-default-directory-on-left ()
           "Display `default-directory' in side window on left, hiding details."
           (interactive)
           (let ((buffer (dired-noselect default-directory)))
             (with-current-buffer buffer (dired-hide-details-mode t))
             (display-buffer-in-side-window
              buffer `((side . left) (slot . 0)
                       (window-width . fit-window-to-buffer)
                       (preserve-size . (t . nil)) ,parameters))))
#+END_EXAMPLE

Evaluating the preceding forms and typing, in any order, M-x list-buffers, C-h f, M-x shell, M-x list-tags, and M-x dired-default-directory-on-left should now reproduce the frame layout sketched above.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Point][Window Point]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.18 Atomic Windows
    :PROPERTIES:
    :CUSTOM_ID: atomic-windows
    :END:

Atomic windows are rectangular compositions of at least two live windows. They have the following distinctive characteristics:

- The function =split-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]]), when applied to a constituent of an atomic window, will try to create the new window outside of the atomic window.\\
- The function =delete-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]), when applied to a constituent of an atomic window, will try to delete the entire atomic window instead.\\
- The function =delete-other-windows= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]), when applied to a constituent of an atomic window, will try to make the atomic window fill its frame or main window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]).

This means that the basic groups of functions that alter the window structure treat an atomic window like a live one, thus preserving the internal structure of the atomic window.

Atomic windows are useful to construct and preserve window layouts that are meaningful only when all involved buffers are shown simultaneously in a specific manner, such as when showing differences between file revisions, or the same text in different languages or markups. They can also be used to permanently display information pertinent to a specific window in bars on that window's sides.

Atomic windows are implemented with the help of the reserved =window-atom= window parameter (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]]) and an internal window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Windows][Basic Windows]]) called the root window of the atomic window. All windows that are part of the same atomic window have this root window as their common ancestor and are assigned a non-=nil= =window-atom= parameter.

The following function returns the root of the atomic window a specified window is part of:

--- Function: *window-atom-root* &optional window

#+BEGIN_QUOTE
  This functions returns the root of the atomic window window is a part of. The specified window must be a valid window and defaults to the selected one. It returns =nil= if window is not part of an atomic window.
#+END_QUOTE

The most simple approach to make a new atomic window is to take an existing internal window and apply the following function:

--- Function: *window-make-atom* window

#+BEGIN_QUOTE
  This function converts window into an atomic window. The specified window must be an internal window. All this function does is to set the =window-atom= parameter of each descendant of window to =t=.
#+END_QUOTE

To create a new atomic window from an existing live window or to add a new window to an existing atomic window, the following buffer display action function (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Display-Action-Functions][Buffer Display Action Functions]]) can be used:

--- Function: *display-buffer-in-atom-window* buffer alist

#+BEGIN_QUOTE
  This function tries to display buffer in a new window that will be combined with an existing window to form an atomic window. If the existing window is already part of an atomic window, it adds the new window to that atomic window.

  The specified alist is an association list of symbols and values. The following symbols have a special meaning:

  - =window=

    The value of such an element specifies an existing window the new window shall be combined with. If it specifies an internal window, all children of that window become part of the atomic window too. If no window is specified, the new window becomes a sibling of the selected window. The =window-atom= parameter of the existing window is set to =main= provided that window is live and its =window-atom= parameter was not already set.

  - =side=

    The value of such an element denotes the side of the existing window where the new window shall be located. Valid values are =below=, =right=, =above= and =left=. The default is =below=. The =window-atom= parameter of the new window is set to this value.

  The return value is the new window, =nil= when creating that window failed.
#+END_QUOTE

Note that the value of the =window-atom= parameter does not really matter as long as it is non-=nil=. The values assigned by =display-buffer-in-atom-window= just allow for easy retrieval of the original and the new window after that function has been applied. Note also that the =window-atom= parameter is the only window parameter assigned by =display-buffer-in-atom-window=. Further parameters have to be set by the application explicitly via a =window-parameters= entry in alist.

Atomic windows automatically cease to exist when one of their constituents gets deleted. To dissolve an atomic window manually, reset the =window-atom= parameter of its constituents---the root of the atomic window and all its descendants.

The following code snippet, when applied to a single-window frame, first splits the selected window and makes the selected and the new window constituents of an atomic window with their parent as root. It then displays the buffer /Messages/ in a new window at the frame's bottom and makes that new window part of the atomic window just created.

#+BEGIN_EXAMPLE
         (let ((window (split-window-right)))
           (window-make-atom (window-parent window))
           (display-buffer-in-atom-window
            (get-buffer-create "*Messages*")
            `((window . ,(window-parent window)) (window-height . 5))))
#+END_EXAMPLE

At this moment typing C-x 2 in any window of that frame produces a new window at the bottom of the frame. Typing C-x 3 instead will put the new window at the frame's right. In either case, typing now C-x 1 in any window of the atomic window will remove the new window only. Typing C-x 0 in any window of the atomic window will make that new window fill the frame.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Start-and-End][Window Start and End]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.19 Windows and Point
    :PROPERTIES:
    :CUSTOM_ID: windows-and-point
    :END:

Each window has its own value of point (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Point][Point]]), independent of the value of point in other windows displaying the same buffer. This makes it useful to have multiple windows showing one buffer.

- The window point is established when a window is first created; it is initialized from the buffer's point, or from the window point of another window opened on the buffer if such a window exists.\\
- Selecting a window sets the value of point in its buffer from the window's value of point. Conversely, deselecting a window sets the window's value of point from that of the buffer. Thus, when you switch between windows that display a given buffer, the point value for the selected window is in effect in the buffer, while the point values for the other windows are stored in those windows.\\
- As long as the selected window displays the current buffer, the window's point and the buffer's point always move together; they remain equal.

  Emacs displays the cursor, by default as a rectangular block, in each window at the position of that window's point. When the user switches to another buffer in a window, Emacs moves that window's cursor to where point is in that buffer. If the exact position of point is hidden behind some display element, such as a display string or an image, Emacs displays the cursor immediately before or after that display element.

--- Function: *window-point* &optional window

#+BEGIN_QUOTE
  This function returns the current position of point in window. For a nonselected window, this is the value point would have (in that window's buffer) if that window were selected. The default for window is the selected window.

  When window is the selected window, the value returned is the value of point in that window's buffer. Strictly speaking, it would be more correct to return the top-level value of point, outside of any =save-excursion= forms. But that value is hard to find.
#+END_QUOTE

--- Function: *set-window-point* window position

#+BEGIN_QUOTE
  This function positions point in window at position position in window's buffer. It returns position.

  If window is selected, this simply does =goto-char= in window's buffer.
#+END_QUOTE

--- Variable: *window-point-insertion-type*

#+BEGIN_QUOTE
  This variable specifies the marker insertion type (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Marker-Insertion-Types][Marker Insertion Types]]) of =window-point=. The default is =nil=, so =window-point= will stay behind text inserted there.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Textual-Scrolling][Textual Scrolling]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Point][Window Point]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.20 The Window Start and End Positions
    :PROPERTIES:
    :CUSTOM_ID: the-window-start-and-end-positions
    :END:

Each window maintains a marker used to keep track of a buffer position that specifies where in the buffer display should start. This position is called the display-start position of the window (or just the start). The character after this position is the one that appears at the upper left corner of the window. It is usually, but not inevitably, at the beginning of a text line.

After switching windows or buffers, and in some other cases, if the window start is in the middle of a line, Emacs adjusts the window start to the start of a line. This prevents certain operations from leaving the window start at a meaningless point within a line. This feature may interfere with testing some Lisp code by executing it using the commands of Lisp mode, because they trigger this readjustment. To test such code, put it into a command and bind the command to a key.

--- Function: *window-start* &optional window

#+BEGIN_QUOTE
  This function returns the display-start position of window window. If window is =nil=, the selected window is used.

  When you create a window, or display a different buffer in it, the display-start position is set to a display-start position recently used for the same buffer, or to =point-min= if the buffer doesn't have any.

  Redisplay updates the window-start position (if you have not specified it explicitly since the previous redisplay)---to make sure point appears on the screen. Nothing except redisplay automatically changes the window-start position; if you move point, do not expect the window-start position to change in response until after the next redisplay.
#+END_QUOTE

--- Function: *window-group-start* &optional window

#+BEGIN_QUOTE
  This function is like =window-start=, except that when window is a part of a group of windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Group][Window Group]]), =window-group-start= returns the start position of the entire group. This condition holds when the buffer local variable =window-group-start-function= is set to a function. In this case, =window-group-start= calls the function with the single argument window, then returns its result.
#+END_QUOTE

--- Function: *window-end* &optional window update

#+BEGIN_QUOTE
  This function returns the position where display of its buffer ends in window. The default for window is the selected window.

  Simply changing the buffer text or moving point does not update the value that =window-end= returns. The value is updated only when Emacs redisplays and redisplay completes without being preempted.

  If the last redisplay of window was preempted, and did not finish, Emacs does not know the position of the end of display in that window. In that case, this function returns =nil=.

  If update is non-=nil=, =window-end= always returns an up-to-date value for where display ends, based on the current =window-start= value. If a previously saved value of that position is still valid, =window-end= returns that value; otherwise it computes the correct value by scanning the buffer text.

  Even if update is non-=nil=, =window-end= does not attempt to scroll the display if point has moved off the screen, the way real redisplay would do. It does not alter the =window-start= value. In effect, it reports where the displayed text will end if scrolling is not required. Note that the position it returns might be only partially visible.
#+END_QUOTE

--- Function: *window-group-end* &optional window update

#+BEGIN_QUOTE
  This function is like =window-end=, except that when window is a part of a group of windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Group][Window Group]]), =window-group-end= returns the end position of the entire group. This condition holds when the buffer local variable =window-group-end-function= is set to a function. In this case, =window-group-end= calls the function with the two arguments window and update, then returns its result. The argument update has the same meaning as in =window-end=.
#+END_QUOTE

--- Function: *set-window-start* window position &optional noforce

#+BEGIN_QUOTE
  This function sets the display-start position of window to position in window's buffer. It returns position.

  The display routines insist that the position of point be visible when a buffer is displayed. Normally, they select the display-start position according to their internal logic (and scroll the window if necessary) to make point visible. However, if you specify the start position with this function using =nil= for noforce, it means you want display to start at position even if that would put the location of point off the screen. If this does place point off screen, the display routines attempt to move point to the left margin on the middle line in the window.

  For example, if point is 1 and you set the start of the window to 37, the start of the next line, point will be above the top of the window. The display routines will automatically move point if it is still 1 when redisplay occurs. Here is an example:

  #+BEGIN_EXAMPLE
                ;; Here is what foo looks like before executing
                ;;   the set-window-start expression.

                ---------- Buffer: foo ----------
                -!-This is the contents of buffer foo.
                2
                3
                4
                5
                6
                ---------- Buffer: foo ----------

                (set-window-start
                 (selected-window)
                 (save-excursion
                   (goto-char 1)
                   (forward-line 1)
                   (point)))
                 37

                ;; Here is what foo looks like after executing
                ;;   the set-window-start expression.
                ---------- Buffer: foo ----------
                2
                3
                -!-4
                5
                6
                ---------- Buffer: foo ----------
  #+END_EXAMPLE

  If the attempt to make point visible (i.e., in a fully-visible screen line) fails, the display routines will disregard the requested window-start position and compute a new one anyway. Thus, for reliable results Lisp programs that call this function should always move point to be inside the window whose display starts at position.

  If noforce is non-=nil=, and position would place point off screen at the next redisplay, then redisplay computes a new window-start position that works well with point, and thus position is not used.
#+END_QUOTE

--- Function: *set-window-group-start* window position &optional noforce

#+BEGIN_QUOTE
  This function is like =set-window-start=, except that when window is a part of a group of windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Group][Window Group]]), =set-window-group-start= sets the start position of the entire group. This condition holds when the buffer local variable =set-window-group-start-function= is set to a function. In this case, =set-window-group-start= calls the function with the three arguments window, position, and noforce, then returns its result. The arguments position and noforce in this function have the same meaning as in =set-window-start=.
#+END_QUOTE

--- Function: *pos-visible-in-window-p* &optional position window partially

#+BEGIN_QUOTE
  This function returns non-=nil= if position is within the range of text currently visible on the screen in window. It returns =nil= if position is scrolled vertically out of view. Locations that are partially obscured are not considered visible unless partially is non-=nil=. The argument position defaults to the current position of point in window; window defaults to the selected window. If position is =t=, that means to check either the first visible position of the last screen line in window, or the end-of-buffer position, whichever comes first.

  This function considers only vertical scrolling. If position is out of view only because window has been scrolled horizontally, =pos-visible-in-window-p= returns non-=nil= anyway. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Horizontal-Scrolling][Horizontal Scrolling]].

  If position is visible, =pos-visible-in-window-p= returns =t= if partially is =nil=; if partially is non-=nil=, and the character following position is fully visible, it returns a list of the form =(=x y=)=, where x and y are the pixel coordinates relative to the top left corner of the window; otherwise it returns an extended list of the form =(=x y rtop rbot rowh vpos=)=, where rtop and rbot specify the number of off-window pixels at the top and bottom of the row at position, rowh specifies the visible height of that row, and vpos specifies the vertical position (zero-based row number) of that row.

  Here is an example:

  #+BEGIN_EXAMPLE
                ;; If point is off the screen now, recenter it now.
                (or (pos-visible-in-window-p
                     (point) (selected-window))
                    (recenter 0))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *pos-visible-in-window-group-p* &optional position window partially

#+BEGIN_QUOTE
  This function is like =pos-visible-in-window-p=, except that when window is a part of a group of windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Group][Window Group]]), =pos-visible-in-window-group-p= tests the visibility of pos in the entire group, not just in the single window. This condition holds when the buffer local variable =pos-visible-in-window-group-p-function= is set to a function. In this case =pos-visible-in-window-group-p= calls the function with the three arguments position, window, and partially, then returns its result. The arguments position and partially have the same meaning as in =pos-visible-in-window-p=.
#+END_QUOTE

--- Function: *window-line-height* &optional line window

#+BEGIN_QUOTE
  This function returns the height of text line line in window. If line is one of =header-line= or =mode-line=, =window-line-height= returns information about the corresponding line of the window. Otherwise, line is a text line number starting from 0. A negative number counts from the end of the window. The default for line is the current line in window; the default for window is the selected window.

  If the display is not up to date, =window-line-height= returns =nil=. In that case, =pos-visible-in-window-p= may be used to obtain related information.

  If there is no line corresponding to the specified line, =window-line-height= returns =nil=. Otherwise, it returns a list =(=height vpos ypos offbot=)=, where height is the height in pixels of the visible part of the line, vpos and ypos are the vertical position in lines and pixels of the line relative to the top of the first text line, and offbot is the number of off-window pixels at the bottom of the text line. If there are off-window pixels at the top of the (first) text line, ypos is negative.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vertical-Scrolling][Vertical Scrolling]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Start-and-End][Window Start and End]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.21 Textual Scrolling
    :PROPERTIES:
    :CUSTOM_ID: textual-scrolling
    :END:

Textual scrolling means moving the text up or down through a window. It works by changing the window's display-start location. It may also change the value of =window-point= to keep point on the screen (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Point][Window Point]]).

The basic textual scrolling functions are =scroll-up= (which scrolls forward) and =scroll-down= (which scrolls backward). In these function names, "up" and "down" refer to the direction of motion of the buffer text relative to the window. Imagine that the text is written on a long roll of paper and that the scrolling commands move the paper up and down. Thus, if you are looking at the middle of a buffer and repeatedly call =scroll-down=, you will eventually see the beginning of the buffer.

Unfortunately, this sometimes causes confusion, because some people tend to think in terms of the opposite convention: they imagine the window moving over text that remains in place, so that "down" commands take you to the end of the buffer. This convention is consistent with fact that such a command is bound to a key named on modern keyboards.

Textual scrolling functions (aside from =scroll-other-window=) have unpredictable results if the current buffer is not the one displayed in the selected window. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Current-Buffer][Current Buffer]].

If the window contains a row taller than the height of the window (for example in the presence of a large image), the scroll functions will adjust the window's vertical scroll position to scroll the partially visible row. Lisp callers can disable this feature by binding the variable =auto-window-vscroll= to =nil= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vertical-Scrolling][Vertical Scrolling]]).

--- Command: *scroll-up* &optional count

#+BEGIN_QUOTE
  This function scrolls forward by count lines in the selected window.

  If count is negative, it scrolls backward instead. If count is =nil= (or omitted), the distance scrolled is =next-screen-context-lines= lines less than the height of the window's text area.

  If the selected window cannot be scrolled any further, this function signals an error. Otherwise, it returns =nil=.
#+END_QUOTE

--- Command: *scroll-down* &optional count

#+BEGIN_QUOTE
  This function scrolls backward by count lines in the selected window.

  If count is negative, it scrolls forward instead. In other respects, it behaves the same way as =scroll-up= does.
#+END_QUOTE

--- Command: *scroll-up-command* &optional count

#+BEGIN_QUOTE
  This behaves like =scroll-up=, except that if the selected window cannot be scrolled any further and the value of the variable =scroll-error-top-bottom= is =t=, it tries to move to the end of the buffer instead. If point is already there, it signals an error.
#+END_QUOTE

--- Command: *scroll-down-command* &optional count

#+BEGIN_QUOTE
  This behaves like =scroll-down=, except that if the selected window cannot be scrolled any further and the value of the variable =scroll-error-top-bottom= is =t=, it tries to move to the beginning of the buffer instead. If point is already there, it signals an error.
#+END_QUOTE

--- Command: *scroll-other-window* &optional count

#+BEGIN_QUOTE
  This function scrolls the text in another window upward count lines. Negative values of count, or =nil=, are handled as in =scroll-up=.

  You can specify which buffer to scroll by setting the variable =other-window-scroll-buffer= to a buffer. If that buffer isn't already displayed, =scroll-other-window= displays it in some window.

  When the selected window is the minibuffer, the next window is normally the leftmost one immediately above it. You can specify a different window to scroll, when the minibuffer is selected, by setting the variable =minibuffer-scroll-window=. This variable has no effect when any other window is selected. When it is non-=nil= and the minibuffer is selected, it takes precedence over =other-window-scroll-buffer=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Definition-of-minibuffer_002dscroll_002dwindow][Definition of minibuffer-scroll-window]].

  When the minibuffer is active, it is the next window if the selected window is the one at the bottom right corner. In this case, =scroll-other-window= attempts to scroll the minibuffer. If the minibuffer contains just one line, it has nowhere to scroll to, so the line reappears after the echo area momentarily displays the message 'End of buffer'.
#+END_QUOTE

--- Variable: *other-window-scroll-buffer*

#+BEGIN_QUOTE
  If this variable is non-=nil=, it tells =scroll-other-window= which buffer's window to scroll.
#+END_QUOTE

--- User Option: *scroll-margin*

#+BEGIN_QUOTE
  This option specifies the size of the scroll margin---a minimum number of lines between point and the top or bottom of a window. Whenever point gets within this many lines of the top or bottom of the window, redisplay scrolls the text automatically (if possible) to move point out of the margin, closer to the center of the window.
#+END_QUOTE

--- User Option: *maximum-scroll-margin*

#+BEGIN_QUOTE
  This variable limits the effective value of =scroll-margin= to a fraction of the current window line height. For example, if the current window has 20 lines and =maximum-scroll-margin= is 0.1, then the scroll margins will never be larger than 2 lines, no matter how big =scroll-margin= is.

  =maximum-scroll-margin= itself has a maximum value of 0.5, which allows setting margins large to keep the cursor at the middle line of the window (or two middle lines if the window has an even number of lines). If it's set to a larger value (or any value other than a float between 0.0 and 0.5) then the default value of 0.25 will be used instead.
#+END_QUOTE

--- User Option: *scroll-conservatively*

#+BEGIN_QUOTE
  This variable controls how scrolling is done automatically when point moves off the screen (or into the scroll margin). If the value is a positive integer n, then redisplay scrolls the text up to n lines in either direction, if that will bring point back into proper view. This behavior is called conservative scrolling. Otherwise, scrolling happens in the usual way, under the control of other variables such as =scroll-up-aggressively= and =scroll-down-aggressively=.

  The default value is zero, which means that conservative scrolling never happens.
#+END_QUOTE

--- User Option: *scroll-down-aggressively*

#+BEGIN_QUOTE
  The value of this variable should be either =nil= or a fraction f between 0 and 1. If it is a fraction, that specifies where on the screen to put point when scrolling down. More precisely, when a window scrolls down because point is above the window start, the new start position is chosen to put point f part of the window height from the top. The larger f, the more aggressive the scrolling.

  A value of =nil= is equivalent to .5, since its effect is to center point. This variable automatically becomes buffer-local when set in any fashion.
#+END_QUOTE

--- User Option: *scroll-up-aggressively*

#+BEGIN_QUOTE
  Likewise, for scrolling up. The value, f, specifies how far point should be placed from the bottom of the window; thus, as with =scroll-down-aggressively=, a larger value scrolls more aggressively.
#+END_QUOTE

--- User Option: *scroll-step*

#+BEGIN_QUOTE
  This variable is an older variant of =scroll-conservatively=. The difference is that if its value is n, that permits scrolling only by precisely n lines, not a smaller number. This feature does not work with =scroll-margin=. The default value is zero.
#+END_QUOTE

--- User Option: *scroll-preserve-screen-position*

#+BEGIN_QUOTE
  If this option is =t=, whenever a scrolling command moves point off-window, Emacs tries to adjust point to keep the cursor at its old vertical position in the window, rather than the window edge.

  If the value is non-=nil= and not =t=, Emacs adjusts point to keep the cursor at the same vertical position, even if the scrolling command didn't move point off-window.

  This option affects all scroll commands that have a non-=nil= =scroll-command= symbol property.
#+END_QUOTE

--- User Option: *next-screen-context-lines*

#+BEGIN_QUOTE
  The value of this variable is the number of lines of continuity to retain when scrolling by full screens. For example, =scroll-up= with an argument of =nil= scrolls so that this many lines at the bottom of the window appear instead at the top. The default value is =2=.
#+END_QUOTE

--- User Option: *scroll-error-top-bottom*

#+BEGIN_QUOTE
  If this option is =nil= (the default), =scroll-up-command= and =scroll-down-command= simply signal an error when no more scrolling is possible.

  If the value is =t=, these commands instead move point to the beginning or end of the buffer (depending on scrolling direction); only if point is already on that position do they signal an error.
#+END_QUOTE

--- Command: *recenter* &optional count

#+BEGIN_QUOTE
  This function scrolls the text in the selected window so that point is displayed at a specified vertical position within the window. It does not move point with respect to the text.

  If count is a non-negative number, that puts the line containing point count lines down from the top of the window. If count is a negative number, then it counts upward from the bottom of the window, so that 1 stands for the last usable line in the window.

  If count is =nil= (or a non-=nil= list), =recenter= puts the line containing point in the middle of the window. If count is =nil=, this function may redraw the frame, according to the value of =recenter-redisplay=.

  When =recenter= is called interactively, count is the raw prefix argument. Thus, typing C-u as the prefix sets the count to a non-=nil= list, while typing C-u 4 sets count to 4, which positions the current line four lines from the top.

  With an argument of zero, =recenter= positions the current line at the top of the window. The command =recenter-top-bottom= offers a more convenient way to achieve this.
#+END_QUOTE

--- Function: *recenter-window-group* &optional count

#+BEGIN_QUOTE
  This function is like =recenter=, except that when the selected window is part of a group of windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Group][Window Group]]), =recenter-window-group= scrolls the entire group. This condition holds when the buffer local variable =recenter-window-group-function= is set to a function. In this case, =recenter-window-group= calls the function with the argument count, then returns its result. The argument count has the same meaning as in =recenter=, but with respect to the entire window group.
#+END_QUOTE

--- User Option: *recenter-redisplay*

#+BEGIN_QUOTE
  If this variable is non-=nil=, calling =recenter= with a =nil= argument redraws the frame. The default value is =tty=, which means only redraw the frame if it is a tty frame.
#+END_QUOTE

--- Command: *recenter-top-bottom* &optional count

#+BEGIN_QUOTE
  This command, which is the default binding for C-l, acts like =recenter=, except if called with no argument. In that case, successive calls place point according to the cycling order defined by the variable =recenter-positions=.
#+END_QUOTE

--- User Option: *recenter-positions*

#+BEGIN_QUOTE
  This variable controls how =recenter-top-bottom= behaves when called with no argument. The default value is =(middle top bottom)=, which means that successive calls of =recenter-top-bottom= with no argument cycle between placing point at the middle, top, and bottom of the window.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Horizontal-Scrolling][Horizontal Scrolling]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Textual-Scrolling][Textual Scrolling]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.22 Vertical Fractional Scrolling
    :PROPERTIES:
    :CUSTOM_ID: vertical-fractional-scrolling
    :END:

Vertical fractional scrolling means shifting text in a window up or down by a specified multiple or fraction of a line. Emacs uses it, for example, on images and screen lines which are taller than the window. Each window has a vertical scroll position, which is a number, never less than zero. It specifies how far to raise the contents of the window when displaying them. Raising the window contents generally makes all or part of some lines disappear off the top, and all or part of some other lines appear at the bottom. The usual value is zero.

The vertical scroll position is measured in units of the normal line height, which is the height of the default font. Thus, if the value is .5, that means the window contents will be scrolled up half the normal line height. If it is 3.3, that means the window contents are scrolled up somewhat over three times the normal line height.

What fraction of a line the vertical scrolling covers, or how many lines, depends on what the lines contain. A value of .5 could scroll a line whose height is very short off the screen, while a value of 3.3 could scroll just part of the way through a tall line or an image.

--- Function: *window-vscroll* &optional window pixels-p

#+BEGIN_QUOTE
  This function returns the current vertical scroll position of window. The default for window is the selected window. If pixels-p is non-=nil=, the return value is measured in pixels, rather than in units of the normal line height.

  #+BEGIN_EXAMPLE
                (window-vscroll)
                      0
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *set-window-vscroll* window lines &optional pixels-p

#+BEGIN_QUOTE
  This function sets window's vertical scroll position to lines. If window is =nil=, the selected window is used. The argument lines should be zero or positive; if not, it is taken as zero.

  The actual vertical scroll position must always correspond to an integral number of pixels, so the value you specify is rounded accordingly.

  The return value is the result of this rounding.

  #+BEGIN_EXAMPLE
                (set-window-vscroll (selected-window) 1.2)
                      1.13
  #+END_EXAMPLE

  If pixels-p is non-=nil=, lines specifies a number of pixels. In this case, the return value is lines.
#+END_QUOTE

--- Variable: *auto-window-vscroll*

#+BEGIN_QUOTE
  If this variable is non-=nil=, the =line-move=, =scroll-up=, and =scroll-down= functions will automatically modify the vertical scroll position to scroll through display rows that are taller than the height of the window, for example in the presence of large images.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Coordinates-and-Windows][Coordinates and Windows]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vertical-Scrolling][Vertical Scrolling]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.23 Horizontal Scrolling
    :PROPERTIES:
    :CUSTOM_ID: horizontal-scrolling
    :END:

Horizontal scrolling means shifting the image in the window left or right by a specified multiple of the normal character width. Each window has a horizontal scroll position, which is a number, never less than zero. It specifies how far to shift the contents left. Shifting the window contents left generally makes all or part of some characters disappear off the left, and all or part of some other characters appear at the right. The usual value is zero.

The horizontal scroll position is measured in units of the normal character width, which is the width of space in the default font. Thus, if the value is 5, that means the window contents are scrolled left by 5 times the normal character width. How many characters actually disappear off to the left depends on their width, and could vary from line to line.

Because we read from side to side in the inner loop, and from top to bottom in the outer loop, the effect of horizontal scrolling is not like that of textual or vertical scrolling. Textual scrolling involves selection of a portion of text to display, and vertical scrolling moves the window contents contiguously; but horizontal scrolling causes part of /each line/ to go off screen.

Usually, no horizontal scrolling is in effect; then the leftmost column is at the left edge of the window. In this state, scrolling to the right is meaningless, since there is no data to the left of the edge to be revealed by it; so this is not allowed. Scrolling to the left is allowed; it scrolls the first columns of text off the edge of the window and can reveal additional columns on the right that were truncated before. Once a window has a nonzero amount of leftward horizontal scrolling, you can scroll it back to the right, but only so far as to reduce the net horizontal scroll to zero. There is no limit to how far left you can scroll, but eventually all the text will disappear off the left edge.

If =auto-hscroll-mode= is set, redisplay automatically alters the horizontal scrolling of a window as necessary to ensure that point is always visible. However, you can still set the horizontal scrolling value explicitly. The value you specify serves as a lower bound for automatic scrolling, i.e., automatic scrolling will not scroll a window to a column less than the specified one.

The default value of =auto-hscroll-mode= is =t=; setting it to =current-line= activates a variant of automatic horizontal scrolling whereby only the line showing the cursor is horizontally scrolled to make point visible, the rest of the window is left either unscrolled, or at the minimum scroll amount set by =scroll-left= and =scroll-right=, see below.

--- Command: *scroll-left* &optional count set-minimum

#+BEGIN_QUOTE
  This function scrolls the selected window count columns to the left (or to the right if count is negative). The default for count is the window width, minus 2.

  The return value is the total amount of leftward horizontal scrolling in effect after the change---just like the value returned by =window-hscroll= (below).

  Note that text in paragraphs whose base direction is right-to-left (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Bidirectional-Display][Bidirectional Display]]) moves in the opposite direction: e.g., it moves to the right when =scroll-left= is invoked with a positive value of count.

  Once you scroll a window as far right as it can go, back to its normal position where the total leftward scrolling is zero, attempts to scroll any farther right have no effect.

  If set-minimum is non-=nil=, the new scroll amount becomes the lower bound for automatic scrolling; that is, automatic scrolling will not scroll a window to a column less than the value returned by this function. Interactive calls pass non-=nil= for set-minimum.
#+END_QUOTE

--- Command: *scroll-right* &optional count set-minimum

#+BEGIN_QUOTE
  This function scrolls the selected window count columns to the right (or to the left if count is negative). The default for count is the window width, minus 2. Aside from the direction of scrolling, this works just like =scroll-left=.
#+END_QUOTE

--- Function: *window-hscroll* &optional window

#+BEGIN_QUOTE
  This function returns the total leftward horizontal scrolling of window---the number of columns by which the text in window is scrolled left past the left margin. (In right-to-left paragraphs, the value is the total amount of the rightward scrolling instead.) The default for window is the selected window.

  The return value is never negative. It is zero when no horizontal scrolling has been done in window (which is usually the case).

  #+BEGIN_EXAMPLE
                (window-hscroll)
                      0
                (scroll-left 5)
                      5
                (window-hscroll)
                      5
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *set-window-hscroll* window columns

#+BEGIN_QUOTE
  This function sets horizontal scrolling of window. The value of columns specifies the amount of scrolling, in terms of columns from the left margin (right margin in right-to-left paragraphs). The argument columns should be zero or positive; if not, it is taken as zero. Fractional values of columns are not supported at present.

  Note that =set-window-hscroll= may appear not to work if you test it by evaluating a call with M-: in a simple way. What happens is that the function sets the horizontal scroll value and returns, but then redisplay adjusts the horizontal scrolling to make point visible, and this overrides what the function did. You can observe the function's effect if you call it while point is sufficiently far from the left margin that it will remain visible.

  The value returned is columns.

  #+BEGIN_EXAMPLE
                (set-window-hscroll (selected-window) 10)
                      10
  #+END_EXAMPLE
#+END_QUOTE

Here is how you can determine whether a given position position is off the screen due to horizontal scrolling:

#+BEGIN_EXAMPLE
         (defun hscroll-on-screen (window position)
           (save-excursion
             (goto-char position)
             (and
              (>= (- (current-column) (window-hscroll window)) 0)
              (< (- (current-column) (window-hscroll window))
                 (window-width window)))))
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mouse-Window-Auto_002dselection][Mouse Window Auto-selection]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Horizontal-Scrolling][Horizontal Scrolling]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]

* 28.24 Coordinates and Windows
    :PROPERTIES:
    :CUSTOM_ID: coordinates-and-windows
    :END:

This section describes functions that report positions of and within a window. Most of these functions report positions relative to an origin at the native position of the window's frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Geometry][Frame Geometry]]). Some functions report positions relative to the origin of the display of the window's frame. In any case, the origin has the coordinates (0, 0) and X and Y coordinates increase rightward and downward respectively.

For the following functions, X and Y coordinates are reported in integer character units, i.e., numbers of lines and columns respectively. On a graphical display, each "line" and "column" corresponds to the height and width of the default character specified by the frame's default font (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Font][Frame Font]]).

--- Function: *window-edges* &optional window body absolute pixelwise

#+BEGIN_QUOTE
  This function returns a list of the edge coordinates of window. If window is omitted or =nil=, it defaults to the selected window.

  The return value has the form =(=left top right bottom=)=. These list elements are, respectively, the X coordinate of the leftmost column occupied by the window, the Y coordinate of the topmost row, the X coordinate one column to the right of the rightmost column, and the Y coordinate one row down from the bottommost row.

  Note that these are the actual outer edges of the window, including any header line, mode line, scroll bar, fringes, window divider and display margins. On a text terminal, if the window has a neighbor on its right, its right edge includes the separator line between the window and its neighbor.

  If the optional argument body is =nil=, this means to return the edges corresponding to the total size of window. body non-=nil= means to return the edges of window's body (aka text area). If body is non-=nil=, window must specify a live window.

  If the optional argument absolute is =nil=, this means to return edges relative to the native position of window's frame. absolute non-=nil= means to return coordinates relative to the origin (0, 0) of window's display. On non-graphical systems this argument has no effect.

  If the optional argument pixelwise is =nil=, this means to return the coordinates in terms of the default character width and height of window's frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Font][Frame Font]]), rounded if necessary. pixelwise non-=nil= means to return the coordinates in pixels. Note that the pixel specified by right and bottom is immediately outside of these edges. If absolute is non-=nil=, pixelwise is implicitly non-=nil= too.
#+END_QUOTE

--- Function: *window-body-edges* &optional window

#+BEGIN_QUOTE
  This function returns the edges of window's body (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Sizes][Window Sizes]]). Calling =(window-body-edges window)= is equivalent to calling =(window-edges window t)=, see above.
#+END_QUOTE

The following functions can be used to relate a set of frame-relative coordinates to a window:

--- Function: *window-at* x y &optional frame

#+BEGIN_QUOTE
  This function returns the live window at the coordinates x and y given in default character sizes (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Font][Frame Font]]) relative to the native position of frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Geometry][Frame Geometry]]).

  If there is no window at that position, the return value is =nil=. If frame is omitted or =nil=, it defaults to the selected frame.
#+END_QUOTE

--- Function: *coordinates-in-window-p* coordinates window

#+BEGIN_QUOTE
  This function checks whether a window window occupies the frame relative coordinates coordinates, and if so, which part of the window that is. window should be a live window.

  coordinates should be a cons cell of the form =(=x=.=y=)=, where x and y are given in default character sizes (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Font][Frame Font]]) relative to the native position of window's frame (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Geometry][Frame Geometry]]).

  If there is no window at the specified position, the return value is =nil= . Otherwise, the return value is one of the following:

  - =(=relx=.=rely=)=

    The coordinates are inside window. The numbers relx and rely are the equivalent window-relative coordinates for the specified position, counting from 0 at the top left corner of the window.

  - =mode-line=

    The coordinates are in the mode line of window.

  - =header-line=

    The coordinates are in the header line of window.

  - =right-divider=

    The coordinates are in the divider separating window from a window on the right.

  - =bottom-divider=

    The coordinates are in the divider separating window from a window beneath.

  - =vertical-line=

    The coordinates are in the vertical line between window and its neighbor to the right. This value occurs only if the window doesn't have a scroll bar; positions in a scroll bar are considered outside the window for these purposes.

  - =left-fringe=

  - =right-fringe=

    The coordinates are in the left or right fringe of the window.

  - =left-margin=

  - =right-margin=

    The coordinates are in the left or right margin of the window.

  - =nil=

    The coordinates are not in any part of window.

  The function =coordinates-in-window-p= does not require a frame as argument because it always uses the frame that window is on.
#+END_QUOTE

The following functions return window positions in pixels, rather than character units. Though mostly useful on graphical displays, they can also be called on text terminals, where the screen area of each text character is taken to be one pixel.

--- Function: *window-pixel-edges* &optional window

#+BEGIN_QUOTE
  This function returns a list of pixel coordinates for the edges of window. Calling =(window-pixel-edges window)= is equivalent to calling =(window-edges window nil nil t)=, see above.
#+END_QUOTE

--- Function: *window-body-pixel-edges* &optional window

#+BEGIN_QUOTE
  This function returns the pixel edges of window's body. Calling =(window-body-pixel-edges window)= is equivalent to calling =(window-edges window t nil t)=, see above.
#+END_QUOTE

The following functions return window positions in pixels, relative to the origin of the display screen rather than that of the frame:

--- Function: *window-absolute-pixel-edges* &optional window

#+BEGIN_QUOTE
  This function returns the pixel coordinates of window relative to an origin at (0, 0) of the display of window's frame. Calling =(window-absolute-pixel-edges)= is equivalent to calling =(window-edges window nil t t)=, see above.
#+END_QUOTE

--- Function: *window-absolute-body-pixel-edges* &optional window

#+BEGIN_QUOTE
  This function returns the pixel coordinates of window's body relative to an origin at (0, 0) of the display of window's frame. Calling =(window-absolute-body-pixel-edges window)= is equivalent to calling =(window-edges window t t t)=, see above.

  Combined with =set-mouse-absolute-pixel-position=, this function can be used to move the mouse pointer to an arbitrary buffer position visible in some window:

  #+BEGIN_EXAMPLE
                (let ((edges (window-absolute-body-pixel-edges))
                      (position (pos-visible-in-window-p nil nil t)))
                  (set-mouse-absolute-pixel-position
                   (+ (nth 0 edges) (nth 0 position))
                   (+ (nth 1 edges) (nth 1 position))))
  #+END_EXAMPLE

  On a graphical terminal this form "warps" the mouse cursor to the upper left corner of the glyph at the selected window's point. A position calculated this way can be also used to show a tooltip window there.
#+END_QUOTE

The following function returns the screen coordinates of a buffer position visible in a window:

--- Function: *window-absolute-pixel-position* &optional position window

#+BEGIN_QUOTE
  If the buffer position position is visible in window window, this function returns the display coordinates of the upper/left corner of the glyph at position. The return value is a cons of the X- and Y-coordinates of that corner, relative to an origin at (0, 0) of window's display. It returns =nil= if position is not visible in window.

  window must be a live window and defaults to the selected window. position defaults to the value of =window-point= of window.

  This means that in order to move the mouse pointer to the position of point in the selected window, it's sufficient to write:

  #+BEGIN_EXAMPLE
                (let ((position (window-absolute-pixel-position)))
                  (set-mouse-absolute-pixel-position
                   (car position) (cdr position)))
  #+END_EXAMPLE
#+END_QUOTE

The following function returns the largest rectangle that can be inscribed in a window without covering text displayed in that window.

--- Function: *window-largest-empty-rectangle* &optional window count min-width min-height positions left

#+BEGIN_QUOTE
  This function calculates the dimensions of the largest empty rectangle that can be inscribed in the specified window's text area. window must be a live window and defaults to the selected one.

  The return value is a triple of the width and the start and end y-coordinates of the largest rectangle that can be inscribed into the empty space (space not displaying any text) of the text area of window. No x-coordinates are returned by this function---any such rectangle is assumed to end at the right edge of window's text area. If no empty space can be found, the return value is =nil=.

  The optional argument count, if non-=nil=, specifies a maximum number of rectangles to return. This means that the return value is a list of triples specifying rectangles with the largest rectangle first. count can be also a cons cell whose car specifies the number of rectangles to return and whose cdr, if non-=nil=, states that all rectangles returned must be disjoint.

  The optional arguments min-width and min-height, if non-=nil=, specify the minimum width and height of any rectangle returned.

  The optional argument positions, if non-=nil=, is a cons cell whose car specifies the uppermost and whose cdr specifies the lowermost pixel position that must be covered by any rectangle returned. These positions measure from the start of the text area of window.

  The optional argument left, if non-=nil=, means to return values suitable for buffers displaying right to left text. In that case, any rectangle returned is assumed to start at the left edge of window's text area.

  Note that this function has to retrieve the dimensions of each line of window's glyph matrix via =window-lines-pixel-dimensions= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Size-of-Displayed-Text][Size of Displayed Text]]). Hence, this function may also return =nil= when the current glyph matrix of window is not up-to-date.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Coordinates-and-Windows][Coordinates and Windows]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.25 Mouse Window Auto-selection
    :PROPERTIES:
    :CUSTOM_ID: mouse-window-auto-selection
    :END:

The following option allows to automatically select the window under the mouse pointer. This accomplishes a policy similar to that of window managers that give focus to a frame (and thus trigger its subsequent selection) whenever the mouse pointer enters its window-system window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Focus][Input Focus]]).

--- User Option: *mouse-autoselect-window*

#+BEGIN_QUOTE
  If this variable is non-=nil=, Emacs will try to automatically select the window under the mouse pointer. The following values are meaningful:

  - A positive number

    This specifies a delay in seconds after which auto-selection triggers. The window under the mouse pointer is selected after the mouse has remained in it for the entire duration of the delay.

  - A negative number

    A negative number has a similar effect as a positive number, but selects the window under the mouse pointer only after the mouse pointer has remained in it for the entire duration of the absolute value of that number and in addition has stopped moving.

  - Other value

    Any other non-=nil= value means to select a window instantaneously as soon as the mouse pointer enters it.

  In either case, the mouse pointer must enter the text area of a window in order to trigger its selection. Dragging the scroll bar slider or the mode line of a window conceptually should not cause its auto-selection.

  Mouse auto-selection selects the minibuffer window only if it is active, and never deselects the active minibuffer window.
#+END_QUOTE

Mouse auto-selection can be used to emulate a focus follows mouse policy for child frames (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Child-Frames][Child Frames]]) which usually are not tracked by the window manager. This requires to set the value of =focus-follows-mouse= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Focus][Input Focus]]) to a non-=nil= value. If the value of =focus-follows-mouse= is =auto-raise=, entering a child frame with the mouse will raise it automatically above all other child frames of that frame's parent frame.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mouse-Window-Auto_002dselection][Mouse Window Auto-selection]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.26 Window Configurations
    :PROPERTIES:
    :CUSTOM_ID: window-configurations
    :END:

A window configuration records the entire layout of one frame---all windows, their sizes, which buffers they contain, how those buffers are scrolled, and their value of point; also their fringes, margins, and scroll bar settings. It also includes the value of =minibuffer-scroll-window=. As a special exception, the window configuration does not record the value of point in the selected window for the current buffer.

You can bring back an entire frame layout by restoring a previously saved window configuration. If you want to record the layout of all frames instead of just one, use a frame configuration instead of a window configuration. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configurations][Frame Configurations]].

--- Function: *current-window-configuration* &optional frame

#+BEGIN_QUOTE
  This function returns a new object representing frame's current window configuration. The default for frame is the selected frame. The variable =window-persistent-parameters= specifies which window parameters (if any) are saved by this function. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]].
#+END_QUOTE

--- Function: *set-window-configuration* configuration

#+BEGIN_QUOTE
  This function restores the configuration of windows and buffers as specified by configuration, for the frame that configuration was created for.

  The argument configuration must be a value that was previously returned by =current-window-configuration=. The configuration is restored in the frame from which configuration was made, whether that frame is selected or not. In some rare cases this may trigger execution of the =window-size-change-functions= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Hooks][Window Hooks]]) even if the size of windows did not change at all. The =window-configuration-change-hook= functions will be called if and only if at least one window was added to or deleted from the frame.

  If the frame from which configuration was saved is dead, all this function does is restore the three variables =window-min-height=, =window-min-width= and =minibuffer-scroll-window=. In this case, the function returns =nil=. Otherwise, it returns =t=.

  Here is a way of using this function to get the same effect as =save-window-excursion=:

  #+BEGIN_EXAMPLE
                (let ((config (current-window-configuration)))
                  (unwind-protect
                      (progn (split-window-below nil)
                             ...)
                    (set-window-configuration config)))
  #+END_EXAMPLE
#+END_QUOTE

--- Macro: *save-window-excursion* forms...

#+BEGIN_QUOTE
  This macro records the window configuration of the selected frame, executes forms in sequence, then restores the earlier window configuration. The return value is the value of the final form in forms.

  Most Lisp code should not use this macro; =save-selected-window= is typically sufficient. In particular, this macro cannot reliably prevent the code in forms from opening new windows, because new windows might be opened in other frames (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]), and =save-window-excursion= only saves and restores the window configuration on the current frame.

  Do not use this macro in =window-size-change-functions=; exiting the macro triggers execution of =window-size-change-functions=, leading to an endless loop.
#+END_QUOTE

--- Function: *window-configuration-p* object

#+BEGIN_QUOTE
  This function returns =t= if object is a window configuration.
#+END_QUOTE

--- Function: *compare-window-configurations* config1 config2

#+BEGIN_QUOTE
  This function compares two window configurations as regards the structure of windows, but ignores the values of point and the saved scrolling positions---it can return =t= even if those aspects differ.

  The function =equal= can also compare two window configurations; it regards configurations as unequal if they differ in any respect, even a saved point.
#+END_QUOTE

--- Function: *window-configuration-frame* config

#+BEGIN_QUOTE
  This function returns the frame for which the window configuration config was made.
#+END_QUOTE

Other primitives to look inside of window configurations would make sense, but are not implemented because we did not need them. See the file winner.el for some more operations on windows configurations.

The objects returned by =current-window-configuration= die together with the Emacs process. In order to store a window configuration on disk and read it back in another Emacs session, you can use the functions described next. These functions are also useful to clone the state of a frame into an arbitrary live window (=set-window-configuration= effectively clones the windows of a frame into the root window of that very frame only).

--- Function: *window-state-get* &optional window writable

#+BEGIN_QUOTE
  This function returns the state of window as a Lisp object. The argument window must be a valid window and defaults to the root window of the selected frame.

  If the optional argument writable is non-=nil=, this means to not use markers for sampling positions like =window-point= or =window-start=. This argument should be non-=nil= when the state will be written to disk and read back in another session.

  Together, the argument writable and the variable =window-persistent-parameters= specify which window parameters are saved by this function. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]].
#+END_QUOTE

The value returned by =window-state-get= can be used in the same session to make a clone of a window in another window. It can be also written to disk and read back in another session. In either case, use the following function to restore the state of the window.

--- Function: *window-state-put* state &optional window ignore

#+BEGIN_QUOTE
  This function puts the window state state into window. The argument state should be the state of a window returned by an earlier invocation of =window-state-get=, see above. The optional argument window can be either a live window or an internal window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows-and-Frames][Windows and Frames]]) and defaults to the selected one. If window is not live, it is replaced by a live window before putting state into it.

  If the optional argument ignore is non-=nil=, it means to ignore minimum window sizes and fixed-size restrictions. If ignore is =safe=, this means windows can get as small as one line and/or two columns.
#+END_QUOTE

The functions =window-state-get= and =window-state-put= also allow to exchange the contents of two live windows. The following function does precisely that:

--- Command: *window-swap-states* &optional window-1 window-2 size

#+BEGIN_QUOTE
  This command swaps the states of the two live windows window-1 and window-2. window-1 must specify a live window and defaults to the selected one. window-2 must specify a live window and defaults to the window following window-1 in the cyclic ordering of windows, excluding minibuffer windows and including live windows on all visible frames.

  Optional argument size non-=nil= means to try swapping the sizes of window-1 and window-2 as well. A value of =height= means to swap heights only, a value of =width= means to swap widths only, while =t= means to swap both widths and heights, if possible. Frames are not resized by this function.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Hooks][Window Hooks]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.27 Window Parameters
    :PROPERTIES:
    :CUSTOM_ID: window-parameters
    :END:

This section describes the window parameters that can be used to associate additional information with windows.

--- Function: *window-parameter* window parameter

#+BEGIN_QUOTE
  This function returns window's value for parameter. The default for window is the selected window. If window has no setting for parameter, this function returns =nil=.
#+END_QUOTE

--- Function: *window-parameters* &optional window

#+BEGIN_QUOTE
  This function returns all parameters of window and their values. The default for window is the selected window. The return value is either =nil=, or an association list whose elements have the form =(=parameter=.=value=)=.
#+END_QUOTE

--- Function: *set-window-parameter* window parameter value

#+BEGIN_QUOTE
  This function sets window's value of parameter to value and returns value. The default for window is the selected window.
#+END_QUOTE

By default, the functions that save and restore window configurations or the states of windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]]) do not care about window parameters. This means that when you change the value of a parameter within the body of a =save-window-excursion=, the previous value is not restored when that macro exits. It also means that when you restore via =window-state-put= a window state saved earlier by =window-state-get=, all cloned windows have their parameters reset to =nil=. The following variable allows you to override the standard behavior:

--- Variable: *window-persistent-parameters*

#+BEGIN_QUOTE
  This variable is an alist specifying which parameters get saved by =current-window-configuration= and =window-state-get=, and subsequently restored by =set-window-configuration= and =window-state-put=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]].

  The car of each entry of this alist is a symbol specifying the parameter. The cdr should be one of the following:

  - =nil=

    This value means the parameter is saved neither by =window-state-get= nor by =current-window-configuration=.

  - =t=

    This value specifies that the parameter is saved by =current-window-configuration= and (provided its writable argument is =nil=) by =window-state-get=.

  - =writable=

    This means that the parameter is saved unconditionally by both =current-window-configuration= and =window-state-get=. This value should not be used for parameters whose values do not have a read syntax. Otherwise, invoking =window-state-put= in another session may fail with an =invalid-read-syntax= error.

#+END_QUOTE

Some functions (notably =delete-window=, =delete-other-windows= and =split-window=), may behave specially when the window specified by their window argument has a parameter whose name is equal to the function's name. You can override such special behavior by binding the following variable to a non-=nil= value:

--- Variable: *ignore-window-parameters*

#+BEGIN_QUOTE
  If this variable is non-=nil=, some standard functions do not process window parameters. The functions currently affected by this are =split-window=, =delete-window=, =delete-other-windows=, and =other-window=.

  An application can bind this variable to a non-=nil= value around calls to these functions. If it does so, the application is fully responsible for correctly assigning the parameters of all involved windows when exiting that function.
#+END_QUOTE

The following parameters are currently used by the window management code:

- =delete-window=

  This parameter affects the execution of =delete-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]).

- =delete-other-windows=

  This parameter affects the execution of =delete-other-windows= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]).

- =no-delete-other-windows=

  This parameter marks the window as not deletable by =delete-other-windows= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][Deleting Windows]]).

- =split-window=

  This parameter affects the execution of =split-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Splitting-Windows][Splitting Windows]]).

- =other-window=

  This parameter affects the execution of =other-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]).

- =no-other-window=

  This parameter marks the window as not selectable by =other-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cyclic-Window-Ordering][Cyclic Window Ordering]]).

- =clone-of=

  This parameter specifies the window that this one has been cloned from. It is installed by =window-state-get= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]]).

- =window-preserved-size=

  This parameter specifies a buffer, a direction where =nil= means vertical and =t= horizontal, and a size in pixels. If this window displays the specified buffer and its size in the indicated direction equals the size specified by this parameter, then Emacs will try to preserve the size of this window in the indicated direction. This parameter is installed and updated by the function =window-preserve-size= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Preserving-Window-Sizes][Preserving Window Sizes]]).

- =quit-restore=

  This parameter is installed by the buffer display functions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Choosing-Window][Choosing Window]]) and consulted by =quit-restore-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]]). It is a list of four elements, see the description of =quit-restore-window= in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]] for details.

- =window-side=

- =window-slot=

  These parameters are used internally for implementing side windows (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Side-Windows][Side Windows]]).

- =window-atom=

  This parameter is used internally for implementing atomic windows, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Atomic-Windows][Atomic Windows]].

- =mode-line-format=

  This parameter replaces the value of the buffer-local variable =mode-line-format= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mode-Line-Basics][Mode Line Basics]]) of this window's buffer whenever this window is displayed. The symbol =none= means to suppress display of a mode line for this window. Display and contents of the mode line on other windows showing this buffer are not affected.

- =header-line-format=

  This parameter replaces the value of the buffer-local variable =header-line-format= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mode-Line-Basics][Mode Line Basics]]) of this window's buffer whenever this window is displayed. The symbol =none= means to suppress display of a header line for this window. Display and contents of the header line on other windows showing this buffer are not affected.

- =min-margins=

  The value of this parameter is a cons cell whose car and cdr, if non-=nil=, specify the minimum values (in columns) for the left and right margin of this window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Display-Margins][Display Margins]]. When present, Emacs will use these values instead of the actual margin widths for determining whether a window can be split or shrunk horizontally. Emacs never auto-adjusts the margins of any window after splitting or resizing it. It is the sole responsibility of any application setting this parameter to adjust the margins of this window as well as those of any new window that inherits this window's margins due to a split. Both =window-configuration-change-hook= and =window-size-change-functions= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Hooks][Window Hooks]]) should be employed for this purpose. This parameter was introduced in Emacs version 25.1 to support applications that use large margins to center buffer text within a window and should be used, with due care, exclusively by those applications. It might be replaced by an improved solution in future versions of Emacs.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Parameters][Window Parameters]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]
* 28.28 Hooks for Window Scrolling and Changes
    :PROPERTIES:
    :CUSTOM_ID: hooks-for-window-scrolling-and-changes
    :END:

This section describes how a Lisp program can take action whenever a window displays a different part of its buffer or a different buffer. There are three actions that can change this: scrolling the window, switching buffers in the window, and changing the size of the window. The first two actions run =window-scroll-functions=; the last runs =window-size-change-functions=.

--- Variable: *window-scroll-functions*

#+BEGIN_QUOTE
  This variable holds a list of functions that Emacs should call before redisplaying a window with scrolling. Displaying a different buffer in the window also runs these functions.

  This variable is not a normal hook, because each function is called with two arguments: the window, and its new display-start position. At the time of the call, the display-start position of the window argument is already set to its new value, and the buffer to be displayed in the window is already set as the current buffer.

  These functions must take care when using =window-end= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Start-and-End][Window Start and End]]); if you need an up-to-date value, you must use the update argument to ensure you get it.

  *Warning:* don't use this feature to alter the way the window is scrolled. It's not designed for that, and such use probably won't work.
#+END_QUOTE

--- Function: *run-window-scroll-functions* &optional window

#+BEGIN_QUOTE
  This function calls =window-scroll-functions= for the specified window, which defaults to the selected window.
#+END_QUOTE

--- Variable: *window-size-change-functions*

#+BEGIN_QUOTE
  This variable holds a list of functions to be called if the size of any window changes for any reason. The functions are called once per redisplay, and once for each frame on which size changes have occurred.

  Each function receives the frame as its sole argument. To find out whether a specific window has changed size, compare the return values of =window-pixel-width-before-size-change= and =window-pixel-width= respectively =window-pixel-height-before-size-change= and =window-pixel-height= for that window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Sizes][Window Sizes]]).

  These function are usually only called when at least one window was added or has changed size since the last time this hook was run for the associated frame. In some rare cases this hook also runs when a window that was added intermittently has been deleted afterwards. In these cases none of the windows on the frame will appear to have changed its size.
#+END_QUOTE

--- Variable: *window-configuration-change-hook*

#+BEGIN_QUOTE
  A normal hook that is run every time the window configuration of a frame changes. Window configuration changes include splitting and deleting windows, and the display of a different buffer in a window.

  The hook can be also used for tracking changes of window sizes. It is, however, not run when the size of a frame changes or automatic resizing of a minibuffer window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffer-Windows][Minibuffer Windows]]) changes the size of another window. As a rule, adding a function to =window-size-change-functions=, see above, is the recommended way for reliably tracking size changes of any window.

  The buffer-local value of this hook is run once for each window on the affected frame, with the relevant window selected and its buffer current. The global value of this hook is run once for the modified frame, with that frame selected.
#+END_QUOTE

--- Function: *run-window-configuration-change-hook* &optional frame

#+BEGIN_QUOTE
  This function runs =window-configuration-change-hook= for the specified frame, which defaults to the selected frame.
#+END_QUOTE

In addition, you can use =jit-lock-register= to register a Font Lock fontification function, which will be called whenever parts of a buffer are (re)fontified because a window was scrolled or its size changed. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Other-Font-Lock-Variables][Other Font Lock Variables]].


