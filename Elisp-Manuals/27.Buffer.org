#+TITLE: 27.Buffer
* 27 Buffers
   :PROPERTIES:
   :CUSTOM_ID: buffers
   :END:

A buffer is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. While several buffers may exist at one time, only one buffer is designated the current buffer at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Basics][Buffer Basics]]: What is a buffer?
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Current-Buffer][Current Buffer]]: Designating a buffer as current so that primitives will access its contents.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Names][Buffer Names]]: Accessing and changing buffer names.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-File-Name][Buffer File Name]]: The buffer file name indicates which file is visited.
5) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Modification][Buffer Modification]]: A buffer is modified if it needs to be saved.
6) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Modification-Time][Modification Time]]: Determining whether the visited file was changed behind Emacs's back.
7) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-Only-Buffers][Read Only Buffers]]: Modifying text is not allowed in a read-only buffer.
8) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]]: How to look at all the existing buffers.
9) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Buffers][Creating Buffers]]: Functions that create buffers.
10) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Killing-Buffers][Killing Buffers]]: Buffers exist until explicitly killed.
11) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indirect-Buffers][Indirect Buffers]]: An indirect buffer shares text with some other buffer.
12) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Swapping-Text][Swapping Text]]: Swapping text between two buffers.
13) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Gap][Buffer Gap]]: The gap in the buffer.


* 27.1 Buffer Basics
    :PROPERTIES:
    :CUSTOM_ID: buffer-basics
    :END:

A buffer is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. Although several buffers normally exist, only one buffer is designated the current buffer at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.

Buffers in Emacs editing are objects that have distinct names and hold text that can be edited. Buffers appear to Lisp programs as a special data type. You can think of the contents of a buffer as a string that you can extend; insertions and deletions may occur in any part of the buffer. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]].

A Lisp buffer object contains numerous pieces of information. Some of this information is directly accessible to the programmer through variables, while other information is accessible only through special-purpose functions. For example, the visited file name is directly accessible through a variable, while the value of point is accessible only through a primitive function.

Buffer-specific information that is directly accessible is stored in buffer-local variable bindings, which are variable values that are effective only in a particular buffer. This feature allows each buffer to override the values of certain variables. Most major modes override variables such as =fill-column= or =comment-column= in this way. For more information about buffer-local variables and functions related to them, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer_002dLocal-Variables][Buffer-Local Variables]].

For functions and variables related to visiting files in buffers, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Visiting-Files][Visiting Files]] and [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Saving-Buffers][Saving Buffers]]. For functions and variables related to the display of buffers in windows, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]].

--- Function: *bufferp* object

#+BEGIN_QUOTE
  This function returns =t= if object is a buffer, =nil= otherwise.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Names][Buffer Names]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Basics][Buffer Basics]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.2 The Current Buffer
    :PROPERTIES:
    :CUSTOM_ID: the-current-buffer
    :END:

There are, in general, many buffers in an Emacs session. At any time, one of them is designated the current buffer---the buffer in which most editing takes place. Most of the primitives for examining or changing text operate implicitly on the current buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]).

Normally, the buffer displayed in the selected window is the current buffer, but this is not always so: a Lisp program can temporarily designate any buffer as current in order to operate on its contents, without changing what is displayed on the screen. The most basic function for designating a current buffer is =set-buffer=.

--- Function: *current-buffer*

#+BEGIN_QUOTE
  This function returns the current buffer.

  #+BEGIN_EXAMPLE
                (current-buffer)
                     â‡’ #<buffer buffers.texi>
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *set-buffer* buffer-or-name

#+BEGIN_QUOTE
  This function makes buffer-or-name the current buffer. buffer-or-name must be an existing buffer or the name of an existing buffer. The return value is the buffer made current.

  This function does not display the buffer in any window, so the user cannot necessarily see the buffer. But Lisp programs will now operate on it.
#+END_QUOTE

When an editing command returns to the editor command loop, Emacs automatically calls =set-buffer= on the buffer shown in the selected window. This is to prevent confusion: it ensures that the buffer that the cursor is in, when Emacs reads a command, is the buffer to which that command applies (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Command-Loop][Command Loop]]). Thus, you should not use =set-buffer= to switch visibly to a different buffer; for that, use the functions described in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]].

When writing a Lisp function, do /not/ rely on this behavior of the command loop to restore the current buffer after an operation. Editing commands can also be called as Lisp functions by other programs, not just from the command loop; it is convenient for the caller if the subroutine does not change which buffer is current (unless, of course, that is the subroutine's purpose).

To operate temporarily on another buffer, put the =set-buffer= within a =save-current-buffer= form. Here, as an example, is a simplified version of the command =append-to-buffer=:

#+BEGIN_EXAMPLE
         (defun append-to-buffer (buffer start end)
           "Append the text of the region to BUFFER."
           (interactive "BAppend to buffer: \nr")
           (let ((oldbuf (current-buffer)))
             (save-current-buffer
               (set-buffer (get-buffer-create buffer))
               (insert-buffer-substring oldbuf start end))))
#+END_EXAMPLE

Here, we bind a local variable to record the current buffer, and then =save-current-buffer= arranges to make it current again later. Next, =set-buffer= makes the specified buffer current, and =insert-buffer-substring= copies the string from the original buffer to the specified (and now current) buffer.

Alternatively, we can use the =with-current-buffer= macro:

#+BEGIN_EXAMPLE
         (defun append-to-buffer (buffer start end)
           "Append the text of the region to BUFFER."
           (interactive "BAppend to buffer: \nr")
           (let ((oldbuf (current-buffer)))
             (with-current-buffer (get-buffer-create buffer)
               (insert-buffer-substring oldbuf start end))))
#+END_EXAMPLE

In either case, if the buffer appended to happens to be displayed in some window, the next redisplay will show how its text has changed. If it is not displayed in any window, you will not see the change immediately on the screen. The command causes the buffer to become current temporarily, but does not cause it to be displayed.

If you make local bindings (with =let= or function arguments) for a variable that may also have buffer-local bindings, make sure that the same buffer is current at the beginning and at the end of the local binding's scope. Otherwise you might bind it in one buffer and unbind it in another!

Do not rely on using =set-buffer= to change the current buffer back, because that won't do the job if a quit happens while the wrong buffer is current. For instance, in the previous example, it would have been wrong to do this:

#+BEGIN_EXAMPLE
           (let ((oldbuf (current-buffer)))
             (set-buffer (get-buffer-create buffer))
             (insert-buffer-substring oldbuf start end)
             (set-buffer oldbuf))
#+END_EXAMPLE

Using =save-current-buffer= or =with-current-buffer=, as we did, correctly handles quitting, errors, and =throw=, as well as ordinary evaluation.

--- Special Form: *save-current-buffer* body...

#+BEGIN_QUOTE
  The =save-current-buffer= special form saves the identity of the current buffer, evaluates the body forms, and finally restores that buffer as current. The return value is the value of the last form in body. The current buffer is restored even in case of an abnormal exit via =throw= or error (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Nonlocal-Exits][Nonlocal Exits]]).

  If the buffer that used to be current has been killed by the time of exit from =save-current-buffer=, then it is not made current again, of course. Instead, whichever buffer was current just before exit remains current.
#+END_QUOTE

--- Macro: *with-current-buffer* buffer-or-name body...

#+BEGIN_QUOTE
  The =with-current-buffer= macro saves the identity of the current buffer, makes buffer-or-name current, evaluates the body forms, and finally restores the current buffer. buffer-or-name must specify an existing buffer or the name of an existing buffer.

  The return value is the value of the last form in body. The current buffer is restored even in case of an abnormal exit via =throw= or error (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Nonlocal-Exits][Nonlocal Exits]]).
#+END_QUOTE

--- Macro: *with-temp-buffer* body...

#+BEGIN_QUOTE
  The =with-temp-buffer= macro evaluates the body forms with a temporary buffer as the current buffer. It saves the identity of the current buffer, creates a temporary buffer and makes it current, evaluates the body forms, and finally restores the previous current buffer while killing the temporary buffer. By default, undo information (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]]) is not recorded in the buffer created by this macro (but body can enable that, if needed).

  The return value is the value of the last form in body. You can return the contents of the temporary buffer by using =(buffer-string)= as the last form.

  The current buffer is restored even in case of an abnormal exit via =throw= or error (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Nonlocal-Exits][Nonlocal Exits]]).

  See also =with-temp-file= in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Definition-of-with_002dtemp_002dfile][Writing to Files]].
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-File-Name][Buffer File Name]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Current-Buffer][Current Buffer]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.3 Buffer Names
    :PROPERTIES:
    :CUSTOM_ID: buffer-names
    :END:

Each buffer has a unique name, which is a string. Many of the functions that work on buffers accept either a buffer or a buffer name as an argument. Any argument called buffer-or-name is of this sort, and an error is signaled if it is neither a string nor a buffer. Any argument called buffer must be an actual buffer object, not a name.

Buffers that are ephemeral and generally uninteresting to the user have names starting with a space, so that the =list-buffers= and =buffer-menu= commands don't mention them (but if such a buffer visits a file, it *is* mentioned). A name starting with space also initially disables recording undo information; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]].

--- Function: *buffer-name* &optional buffer

#+BEGIN_QUOTE
  This function returns the name of buffer as a string. buffer defaults to the current buffer.

  If =buffer-name= returns =nil=, it means that buffer has been killed. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Killing-Buffers][Killing Buffers]].

  #+BEGIN_EXAMPLE
                (buffer-name)
                     â‡’ "buffers.texi"

                (setq foo (get-buffer "temp"))
                     â‡’ #<buffer temp>
                (kill-buffer foo)
                     â‡’ nil
                (buffer-name foo)
                     â‡’ nil
                foo
                     â‡’ #<killed buffer>
  #+END_EXAMPLE
#+END_QUOTE

--- Command: *rename-buffer* newname &optional unique

#+BEGIN_QUOTE
  This function renames the current buffer to newname. An error is signaled if newname is not a string.

  Ordinarily, =rename-buffer= signals an error if newname is already in use. However, if unique is non-=nil=, it modifies newname to make a name that is not in use. Interactively, you can make unique non-=nil= with a numeric prefix argument. (This is how the command =rename-uniquely= is implemented.)

  This function returns the name actually given to the buffer.
#+END_QUOTE

--- Function: *get-buffer* buffer-or-name

#+BEGIN_QUOTE
  This function returns the buffer specified by buffer-or-name. If buffer-or-name is a string and there is no buffer with that name, the value is =nil=. If buffer-or-name is a buffer, it is returned as given; that is not very useful, so the argument is usually a name. For example:

  #+BEGIN_EXAMPLE
                (setq b (get-buffer "lewis"))
                     â‡’ #<buffer lewis>
                (get-buffer b)
                     â‡’ #<buffer lewis>
                (get-buffer "Frazzle-nots")
                     â‡’ nil
  #+END_EXAMPLE

  See also the function =get-buffer-create= in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Buffers][Creating Buffers]].
#+END_QUOTE

--- Function: *generate-new-buffer-name* starting-name &optional ignore

#+BEGIN_QUOTE
  This function returns a name that would be unique for a new buffer---but does not create the buffer. It starts with starting-name, and produces a name not currently in use for any buffer by appending a number inside of '<...>'. It starts at 2 and keeps incrementing the number until it is not the name of an existing buffer.

  If the optional second argument ignore is non-=nil=, it should be a string, a potential buffer name. It means to consider that potential buffer acceptable, if it is tried, even it is the name of an existing buffer (which would normally be rejected). Thus, if buffers named 'foo', 'foo<2>', 'foo<3>' and 'foo<4>' exist,

  #+BEGIN_EXAMPLE
                (generate-new-buffer-name "foo")
                     â‡’ "foo<5>"
                (generate-new-buffer-name "foo" "foo<3>")
                     â‡’ "foo<3>"
                (generate-new-buffer-name "foo" "foo<6>")
                     â‡’ "foo<5>"
  #+END_EXAMPLE

  See the related function =generate-new-buffer= in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Buffers][Creating Buffers]].
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Modification][Buffer Modification]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Names][Buffer Names]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.4 Buffer File Name
    :PROPERTIES:
    :CUSTOM_ID: buffer-file-name
    :END:

The buffer file name is the name of the file that is visited in that buffer. When a buffer is not visiting a file, its buffer file name is =nil=. Most of the time, the buffer name is the same as the nondirectory part of the buffer file name, but the buffer file name and the buffer name are distinct and can be set independently. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Visiting-Files][Visiting Files]].

--- Function: *buffer-file-name* &optional buffer

#+BEGIN_QUOTE
  This function returns the absolute file name of the file that buffer is visiting. If buffer is not visiting any file, =buffer-file-name= returns =nil=. If buffer is not supplied, it defaults to the current buffer.

  #+BEGIN_EXAMPLE
                (buffer-file-name (other-buffer))
                     â‡’ "/usr/user/lewis/manual/files.texi"
  #+END_EXAMPLE
#+END_QUOTE

--- Variable: *buffer-file-name*

#+BEGIN_QUOTE
  This buffer-local variable contains the name of the file being visited in the current buffer, or =nil= if it is not visiting a file. It is a permanent local variable, unaffected by =kill-all-local-variables=.

  #+BEGIN_EXAMPLE
                buffer-file-name
                     â‡’ "/usr/user/lewis/manual/buffers.texi"
  #+END_EXAMPLE

  It is risky to change this variable's value without doing various other things. Normally it is better to use =set-visited-file-name= (see below); some of the things done there, such as changing the buffer name, are not strictly necessary, but others are essential to avoid confusing Emacs.
#+END_QUOTE

--- Variable: *buffer-file-truename*

#+BEGIN_QUOTE
  This buffer-local variable holds the abbreviated truename of the file visited in the current buffer, or =nil= if no file is visited. It is a permanent local, unaffected by =kill-all-local-variables=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Truenames][Truenames]], and [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#abbreviate_002dfile_002dname][abbreviate-file-name]].
#+END_QUOTE

--- Variable: *buffer-file-number*

#+BEGIN_QUOTE
  This buffer-local variable holds the file number and directory device number of the file visited in the current buffer, or =nil= if no file or a nonexistent file is visited. It is a permanent local, unaffected by =kill-all-local-variables=.

  The value is normally a list of the form =(=filenum devnum=)=. This pair of numbers uniquely identifies the file among all files accessible on the system. See the function =file-attributes=, in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#File-Attributes][File Attributes]], for more information about them.

  If =buffer-file-name= is the name of a symbolic link, then both numbers refer to the recursive target.
#+END_QUOTE

--- Function: *get-file-buffer* filename

#+BEGIN_QUOTE
  This function returns the buffer visiting file filename. If there is no such buffer, it returns =nil=. The argument filename, which must be a string, is expanded (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#File-Name-Expansion][File Name Expansion]]), then compared against the visited file names of all live buffers. Note that the buffer's =buffer-file-name= must match the expansion of filename exactly. This function will not recognize other names for the same file.

  #+BEGIN_EXAMPLE
                (get-file-buffer "buffers.texi")
                    â‡’ #<buffer buffers.texi>
  #+END_EXAMPLE

  In unusual circumstances, there can be more than one buffer visiting the same file name. In such cases, this function returns the first such buffer in the buffer list.
#+END_QUOTE

--- Function: *find-buffer-visiting* filename &optional predicate

#+BEGIN_QUOTE
  This is like =get-file-buffer=, except that it can return any buffer visiting the file /possibly under a different name/. That is, the buffer's =buffer-file-name= does not need to match the expansion of filename exactly, it only needs to refer to the same file. If predicate is non-=nil=, it should be a function of one argument, a buffer visiting filename. The buffer is only considered a suitable return value if predicate returns non-=nil=. If it can not find a suitable buffer to return, =find-buffer-visiting= returns =nil=.
#+END_QUOTE

--- Command: *set-visited-file-name* filename &optional no-query along-with-file

#+BEGIN_QUOTE
  If filename is a non-empty string, this function changes the name of the file visited in the current buffer to filename. (If the buffer had no visited file, this gives it one.) The /next time/ the buffer is saved it will go in the newly-specified file.

  This command marks the buffer as modified, since it does not (as far as Emacs knows) match the contents of filename, even if it matched the former visited file. It also renames the buffer to correspond to the new file name, unless the new name is already in use.

  If filename is =nil= or the empty string, that stands for "no visited file". In this case, =set-visited-file-name= marks the buffer as having no visited file, without changing the buffer's modified flag.

  Normally, this function asks the user for confirmation if there already is a buffer visiting filename. If no-query is non-=nil=, that prevents asking this question. If there already is a buffer visiting filename, and the user confirms or no-query is non-=nil=, this function makes the new buffer name unique by appending a number inside of '<...>' to filename.

  If along-with-file is non-=nil=, that means to assume that the former visited file has been renamed to filename. In this case, the command does not change the buffer's modified flag, nor the buffer's recorded last file modification time as reported by =visited-file-modtime= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Modification-Time][Modification Time]]). If along-with-file is =nil=, this function clears the recorded last file modification time, after which =visited-file-modtime= returns zero.

  When the function =set-visited-file-name= is called interactively, it prompts for filename in the minibuffer.
#+END_QUOTE

--- Variable: *list-buffers-directory*

#+BEGIN_QUOTE
  This buffer-local variable specifies a string to display in a buffer listing where the visited file name would go, for buffers that don't have a visited file name. Dired buffers use this variable.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Modification-Time][Modification Time]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-File-Name][Buffer File Name]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.5 Buffer Modification
    :PROPERTIES:
    :CUSTOM_ID: buffer-modification
    :END:

Emacs keeps a flag called the modified flag for each buffer, to record whether you have changed the text of the buffer. This flag is set to =t= whenever you alter the contents of the buffer, and cleared to =nil= when you save it. Thus, the flag shows whether there are unsaved changes. The flag value is normally shown in the mode line (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mode-Line-Variables][Mode Line Variables]]), and controls saving (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Saving-Buffers][Saving Buffers]]) and auto-saving (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto_002dSaving][Auto-Saving]]).

Some Lisp programs set the flag explicitly. For example, the function =set-visited-file-name= sets the flag to =t=, because the text does not match the newly-visited file, even if it is unchanged from the file formerly visited.

The functions that modify the contents of buffers are described in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]].

--- Function: *buffer-modified-p* &optional buffer

#+BEGIN_QUOTE
  This function returns =t= if the buffer buffer has been modified since it was last read in from a file or saved, or =nil= otherwise. If buffer is not supplied, the current buffer is tested.
#+END_QUOTE

--- Function: *set-buffer-modified-p* flag

#+BEGIN_QUOTE
  This function marks the current buffer as modified if flag is non-=nil=, or as unmodified if the flag is =nil=.

  Another effect of calling this function is to cause unconditional redisplay of the mode line for the current buffer. In fact, the function =force-mode-line-update= works by doing this:

  #+BEGIN_EXAMPLE
                (set-buffer-modified-p (buffer-modified-p))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *restore-buffer-modified-p* flag

#+BEGIN_QUOTE
  Like =set-buffer-modified-p=, but does not force redisplay of mode lines.
#+END_QUOTE

--- Command: *not-modified* &optional arg

#+BEGIN_QUOTE
  This command marks the current buffer as unmodified, and not needing to be saved. If arg is non-=nil=, it marks the buffer as modified, so that it will be saved at the next suitable occasion. Interactively, arg is the prefix argument.

  Don't use this function in programs, since it prints a message in the echo area; use =set-buffer-modified-p= (above) instead.
#+END_QUOTE

--- Function: *buffer-modified-tick* &optional buffer

#+BEGIN_QUOTE
  This function returns buffer's modification-count. This is a counter that increments every time the buffer is modified. If buffer is =nil= (or omitted), the current buffer is used. The counter can wrap around occasionally.
#+END_QUOTE

--- Function: *buffer-chars-modified-tick* &optional buffer

#+BEGIN_QUOTE
  This function returns buffer's character-change modification-count. Changes to text properties leave this counter unchanged; however, each time text is inserted or removed from the buffer, the counter is reset to the value that would be returned by =buffer-modified-tick=. By comparing the values returned by two =buffer-chars-modified-tick= calls, you can tell whether a character change occurred in that buffer in between the calls. If buffer is =nil= (or omitted), the current buffer is used.
#+END_QUOTE

Sometimes there's a need for modifying buffer in a way that doesn't really change its text, like if only its text properties are changed. If your program needs to modify a buffer without triggering any hooks and features that react to buffer modifications, use the =with-silent-modifications= macro.

--- Macro: *with-silent-modifications* body...

#+BEGIN_QUOTE
  Execute body pretending it does not modify the buffer. This includes checking whether the buffer's file is locked (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#File-Locks][File Locks]]), running buffer modification hooks (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Change-Hooks][Change Hooks]]), etc. Note that if body actually modifies the buffer text, its undo data may become corrupted.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-Only-Buffers][Read Only Buffers]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Modification][Buffer Modification]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.6 Buffer Modification Time
    :PROPERTIES:
    :CUSTOM_ID: buffer-modification-time
    :END:

Suppose that you visit a file and make changes in its buffer, and meanwhile the file itself is changed on disk. At this point, saving the buffer would overwrite the changes in the file. Occasionally this may be what you want, but usually it would lose valuable information. Emacs therefore checks the file's modification time using the functions described below before saving the file. (See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#File-Attributes][File Attributes]], for how to examine a file's modification time.)

--- Function: *verify-visited-file-modtime* &optional buffer

#+BEGIN_QUOTE
  This function compares what buffer (by default, the current-buffer) has recorded for the modification time of its visited file against the actual modification time of the file as recorded by the operating system. The two should be the same unless some other process has written the file since Emacs visited or saved it.

  The function returns =t= if the last actual modification time and Emacs's recorded modification time are the same, =nil= otherwise. It also returns =t= if the buffer has no recorded last modification time, that is if =visited-file-modtime= would return zero.

  It always returns =t= for buffers that are not visiting a file, even if =visited-file-modtime= returns a non-zero value. For instance, it always returns =t= for dired buffers. It returns =t= for buffers that are visiting a file that does not exist and never existed, but =nil= for file-visiting buffers whose file has been deleted.
#+END_QUOTE

--- Function: *clear-visited-file-modtime*

#+BEGIN_QUOTE
  This function clears out the record of the last modification time of the file being visited by the current buffer. As a result, the next attempt to save this buffer will not complain of a discrepancy in file modification times.

  This function is called in =set-visited-file-name= and other exceptional places where the usual test to avoid overwriting a changed file should not be done.
#+END_QUOTE

--- Function: *visited-file-modtime*

#+BEGIN_QUOTE
  This function returns the current buffer's recorded last file modification time, as a list of the form =(=high low microsec picosec=)=. (This is the same format that =file-attributes= uses to return time values; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#File-Attributes][File Attributes]].)

  If the buffer has no recorded last modification time, this function returns zero. This case occurs, for instance, if the buffer is not visiting a file or if the time has been explicitly cleared by =clear-visited-file-modtime=. Note, however, that =visited-file-modtime= returns a list for some non-file buffers too. For instance, in a Dired buffer listing a directory, it returns the last modification time of that directory, as recorded by Dired.

  If the buffer is visiting a file that doesn't exist, this function returns âˆ’1.
#+END_QUOTE

--- Function: *set-visited-file-modtime* &optional time

#+BEGIN_QUOTE
  This function updates the buffer's record of the last modification time of the visited file, to the value specified by time if time is not =nil=, and otherwise to the last modification time of the visited file.

  If time is neither =nil= nor an integer flag returned by =visited-file-modtime=, it should have the form =(=high low microsec picosec=)=, the format used by =current-time= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Time-of-Day][Time of Day]]).

  This function is useful if the buffer was not read from the file normally, or if the file itself has been changed for some known benign reason.
#+END_QUOTE

--- Function: *ask-user-about-supersession-threat* filename

#+BEGIN_QUOTE
  This function is used to ask a user how to proceed after an attempt to modify a buffer visiting file filename when the file is newer than the buffer text. Emacs detects this because the modification time of the file on disk is newer than the last save-time and its contents have changed. This means some other program has probably altered the file.

  Depending on the user's answer, the function may return normally, in which case the modification of the buffer proceeds, or it may signal a =file-supersession= error with data =(=filename=)=, in which case the proposed buffer modification is not allowed.

  This function is called automatically by Emacs on the proper occasions. It exists so you can customize Emacs by redefining it. See the file userlock.el for the standard definition.

  See also the file locking mechanism in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#File-Locks][File Locks]].
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Modification-Time][Modification Time]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.7 Read-Only Buffers
    :PROPERTIES:
    :CUSTOM_ID: read-only-buffers
    :END:

If a buffer is read-only, then you cannot change its contents, although you may change your view of the contents by scrolling and narrowing.

Read-only buffers are used in two kinds of situations:

- A buffer visiting a write-protected file is normally read-only.

  Here, the purpose is to inform the user that editing the buffer with the aim of saving it in the file may be futile or undesirable. The user who wants to change the buffer text despite this can do so after clearing the read-only flag with C-x C-q.

- Modes such as Dired and Rmail make buffers read-only when altering the contents with the usual editing commands would probably be a mistake.

  The special commands of these modes bind =buffer-read-only= to =nil= (with =let=) or bind =inhibit-read-only= to =t= around the places where they themselves change the text.

--- Variable: *buffer-read-only*

#+BEGIN_QUOTE
  This buffer-local variable specifies whether the buffer is read-only. The buffer is read-only if this variable is non-=nil=. However, characters that have the =inhibit-read-only= text property can still be modified. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][inhibit-read-only]].
#+END_QUOTE

--- Variable: *inhibit-read-only*

#+BEGIN_QUOTE
  If this variable is non-=nil=, then read-only buffers and, depending on the actual value, some or all read-only characters may be modified. Read-only characters in a buffer are those that have a non-=nil= =read-only= text property. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Properties][Special Properties]], for more information about text properties.

  If =inhibit-read-only= is =t=, all =read-only= character properties have no effect. If =inhibit-read-only= is a list, then =read-only= character properties have no effect if they are members of the list (comparison is done with =eq=).
#+END_QUOTE

--- Command: *read-only-mode* &optional arg

#+BEGIN_QUOTE
  This is the mode command for Read Only minor mode, a buffer-local minor mode. When the mode is enabled, =buffer-read-only= is non-=nil= in the buffer; when disabled, =buffer-read-only= is =nil= in the buffer. The calling convention is the same as for other minor mode commands (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minor-Mode-Conventions][Minor Mode Conventions]]).

  This minor mode mainly serves as a wrapper for =buffer-read-only=; unlike most minor modes, there is no separate =read-only-mode= variable. Even when Read Only mode is disabled, characters with non-=nil= =read-only= text properties remain read-only. To temporarily ignore all read-only states, bind =inhibit-read-only=, as described above.

  When enabling Read Only mode, this mode command also enables View mode if the option =view-read-only= is non-=nil=. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Misc-Buffer][Miscellaneous Buffer Operations]]. When disabling Read Only mode, it disables View mode if View mode was enabled.
#+END_QUOTE

--- Function: *barf-if-buffer-read-only* &optional position

#+BEGIN_QUOTE
  This function signals a =buffer-read-only= error if the current buffer is read-only. If the text at position (which defaults to point) has the =inhibit-read-only= text property set, the error will not be raised.

  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Using-Interactive][Using Interactive]], for another way to signal an error if the current buffer is read-only.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Buffers][Creating Buffers]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-Only-Buffers][Read Only Buffers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.8 The Buffer List
    :PROPERTIES:
    :CUSTOM_ID: the-buffer-list
    :END:

The buffer list is a list of all live buffers. The order of the buffers in this list is based primarily on how recently each buffer has been displayed in a window. Several functions, notably =other-buffer=, use this ordering. A buffer list displayed for the user also follows this order.

Creating a buffer adds it to the end of the buffer list, and killing a buffer removes it from that list. A buffer moves to the front of this list whenever it is chosen for display in a window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]]) or a window displaying it is selected (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Selecting-Windows][Selecting Windows]]). A buffer moves to the end of the list when it is buried (see =bury-buffer=, below). There are no functions available to the Lisp programmer which directly manipulate the buffer list.

In addition to the fundamental buffer list just described, Emacs maintains a local buffer list for each frame, in which the buffers that have been displayed (or had their windows selected) in that frame come first. (This order is recorded in the frame's =buffer-list= frame parameter; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Parameters][Buffer Parameters]].) Buffers never displayed in that frame come afterward, ordered according to the fundamental buffer list.

--- Function: *buffer-list* &optional frame

#+BEGIN_QUOTE
  This function returns the buffer list, including all buffers, even those whose names begin with a space. The elements are actual buffers, not their names.

  If frame is a frame, this returns frame's local buffer list. If frame is =nil= or omitted, the fundamental buffer list is used: the buffers appear in order of most recent display or selection, regardless of which frames they were displayed on.

  #+BEGIN_EXAMPLE
                (buffer-list)
                     â‡’ (#<buffer buffers.texi>
                         #<buffer  *Minibuf-1*> #<buffer buffer.c>
                         #<buffer *Help*> #<buffer TAGS>)

                ;; Note that the name of the minibuffer
                ;;   begins with a space!
                (mapcar (function buffer-name) (buffer-list))
                    â‡’ ("buffers.texi" " *Minibuf-1*"
                        "buffer.c" "*Help*" "TAGS")
  #+END_EXAMPLE
#+END_QUOTE

The list returned by =buffer-list= is constructed specifically; it is not an internal Emacs data structure, and modifying it has no effect on the order of buffers. If you want to change the order of buffers in the fundamental buffer list, here is an easy way:

#+BEGIN_EXAMPLE
         (defun reorder-buffer-list (new-list)
           (while new-list
             (bury-buffer (car new-list))
             (setq new-list (cdr new-list))))
#+END_EXAMPLE

With this method, you can specify any order for the list, but there is no danger of losing a buffer or adding something that is not a valid live buffer.

To change the order or value of a specific frame's buffer list, set that frame's =buffer-list= parameter with =modify-frame-parameters= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Parameter-Access][Parameter Access]]).

--- Function: *other-buffer* &optional buffer visible-ok frame

#+BEGIN_QUOTE
  This function returns the first buffer in the buffer list other than buffer. Usually, this is the buffer appearing in the most recently selected window (in frame frame or else the selected frame, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Focus][Input Focus]]), aside from buffer. Buffers whose names start with a space are not considered at all.

  If buffer is not supplied (or if it is not a live buffer), then =other-buffer= returns the first buffer in the selected frame's local buffer list. (If frame is non-=nil=, it returns the first buffer in frame's local buffer list instead.)

  If frame has a non-=nil= =buffer-predicate= parameter, then =other-buffer= uses that predicate to decide which buffers to consider. It calls the predicate once for each buffer, and if the value is =nil=, that buffer is ignored. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Parameters][Buffer Parameters]].

  If visible-ok is =nil=, =other-buffer= avoids returning a buffer visible in any window on any visible frame, except as a last resort. If visible-ok is non-=nil=, then it does not matter whether a buffer is displayed somewhere or not.

  If no suitable buffer exists, the buffer /scratch/ is returned (and created, if necessary).
#+END_QUOTE

--- Function: *last-buffer* &optional buffer visible-ok frame

#+BEGIN_QUOTE
  This function returns the last buffer in frame's buffer list other than buffer. If frame is omitted or =nil=, it uses the selected frame's buffer list.

  The argument visible-ok is handled as with =other-buffer=, see above. If no suitable buffer can be found, the buffer /scratch/ is returned.
#+END_QUOTE

--- Command: *bury-buffer* &optional buffer-or-name

#+BEGIN_QUOTE
  This command puts buffer-or-name at the end of the buffer list, without changing the order of any of the other buffers on the list. This buffer therefore becomes the least desirable candidate for =other-buffer= to return. The argument can be either a buffer itself or the name of one.

  This function operates on each frame's =buffer-list= parameter as well as the fundamental buffer list; therefore, the buffer that you bury will come last in the value of =(buffer-list=frame=)= and in the value of =(buffer-list)=. In addition, it also puts the buffer at the end of the list of buffers of the selected window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]]) provided it is shown in that window.

  If buffer-or-name is =nil= or omitted, this means to bury the current buffer. In addition, if the current buffer is displayed in the selected window, this makes sure that the window is either deleted or another buffer is shown in it. More precisely, if the selected window is dedicated (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dedicated-Windows][Dedicated Windows]]) and there are other windows on its frame, the window is deleted. If it is the only window on its frame and that frame is not the only frame on its terminal, the frame is dismissed by calling the function specified by =frame-auto-hide-function= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Quitting-Windows][Quitting Windows]]). Otherwise, it calls =switch-to-prev-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-History][Window History]]) to show another buffer in that window. If buffer-or-name is displayed in some other window, it remains displayed there.

  To replace a buffer in all the windows that display it, use =replace-buffer-in-windows=, See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers-and-Windows][Buffers and Windows]].
#+END_QUOTE

--- Command: *unbury-buffer*

#+BEGIN_QUOTE
  This command switches to the last buffer in the local buffer list of the selected frame. More precisely, it calls the function =switch-to-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Switching-Buffers][Switching Buffers]]), to display the buffer returned by =last-buffer= (see above), in the selected window.
#+END_QUOTE

--- Variable: *buffer-list-update-hook*

#+BEGIN_QUOTE
  This is a normal hook run whenever the buffer list changes. Functions (implicitly) running this hook are =get-buffer-create= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Buffers][Creating Buffers]]), =rename-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Names][Buffer Names]]), =kill-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Killing-Buffers][Killing Buffers]]), =bury-buffer= (see above) and =select-window= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Selecting-Windows][Selecting Windows]]).

  Functions run by this hook should avoid calling =select-window= with a nil norecord argument or =with-temp-buffer= since either may lead to infinite recursion.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Killing-Buffers][Killing Buffers]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-List][Buffer List]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.9 Creating Buffers
    :PROPERTIES:
    :CUSTOM_ID: creating-buffers
    :END:

This section describes the two primitives for creating buffers. =get-buffer-create= creates a buffer if it finds no existing buffer with the specified name; =generate-new-buffer= always creates a new buffer and gives it a unique name.

Other functions you can use to create buffers include =with-output-to-temp-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Temporary-Displays][Temporary Displays]]) and =create-file-buffer= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Visiting-Files][Visiting Files]]). Starting a subprocess can also create a buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Processes][Processes]]).

--- Function: *get-buffer-create* buffer-or-name

#+BEGIN_QUOTE
  This function returns a buffer named buffer-or-name. The buffer returned does not become the current buffer---this function does not change which buffer is current.

  buffer-or-name must be either a string or an existing buffer. If it is a string and a live buffer with that name already exists, =get-buffer-create= returns that buffer. If no such buffer exists, it creates a new buffer. If buffer-or-name is a buffer instead of a string, it is returned as given, even if it is dead.

  #+BEGIN_EXAMPLE
                (get-buffer-create "foo")
                     â‡’ #<buffer foo>
  #+END_EXAMPLE

  The major mode for a newly created buffer is set to Fundamental mode. (The default value of the variable =major-mode= is handled at a higher level; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Major-Mode][Auto Major Mode]].) If the name begins with a space, the buffer initially disables undo information recording (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Undo][Undo]]).
#+END_QUOTE

--- Function: *generate-new-buffer* name

#+BEGIN_QUOTE
  This function returns a newly created, empty buffer, but does not make it current. The name of the buffer is generated by passing name to the function =generate-new-buffer-name= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Names][Buffer Names]]). Thus, if there is no buffer named name, then that is the name of the new buffer; if that name is in use, a suffix of the form '', where n is an integer, is appended to name.

  An error is signaled if name is not a string.

  #+BEGIN_EXAMPLE
                (generate-new-buffer "bar")
                     â‡’ #<buffer bar>
                (generate-new-buffer "bar")
                     â‡’ #<buffer bar<2>>
                (generate-new-buffer "bar")
                     â‡’ #<buffer bar<3>>
  #+END_EXAMPLE

  The major mode for the new buffer is set to Fundamental mode. The default value of the variable =major-mode= is handled at a higher level. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Auto-Major-Mode][Auto Major Mode]].
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indirect-Buffers][Indirect Buffers]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Buffers][Creating Buffers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.10 Killing Buffers
    :PROPERTIES:
    :CUSTOM_ID: killing-buffers
    :END:

Killing a buffer makes its name unknown to Emacs and makes the memory space it occupied available for other use.

The buffer object for the buffer that has been killed remains in existence as long as anything refers to it, but it is specially marked so that you cannot make it current or display it. Killed buffers retain their identity, however; if you kill two distinct buffers, they remain distinct according to =eq= although both are dead.

If you kill a buffer that is current or displayed in a window, Emacs automatically selects or displays some other buffer instead. This means that killing a buffer can change the current buffer. Therefore, when you kill a buffer, you should also take the precautions associated with changing the current buffer (unless you happen to know that the buffer being killed isn't current). See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Current-Buffer][Current Buffer]].

If you kill a buffer that is the base buffer of one or more indirect buffers (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indirect-Buffers][Indirect Buffers]]), the indirect buffers are automatically killed as well.

The =buffer-name= of a buffer is =nil= if, and only if, the buffer is killed. A buffer that has not been killed is called a live buffer. To test whether a buffer is live or killed, use the function =buffer-live-p= (see below).

--- Command: *kill-buffer* &optional buffer-or-name

#+BEGIN_QUOTE
  This function kills the buffer buffer-or-name, freeing all its memory for other uses or to be returned to the operating system. If buffer-or-name is =nil= or omitted, it kills the current buffer.

  Any processes that have this buffer as the =process-buffer= are sent the =SIGHUP= (hangup) signal, which normally causes them to terminate. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Signals-to-Processes][Signals to Processes]].

  If the buffer is visiting a file and contains unsaved changes, =kill-buffer= asks the user to confirm before the buffer is killed. It does this even if not called interactively. To prevent the request for confirmation, clear the modified flag before calling =kill-buffer=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Modification][Buffer Modification]].

  This function calls =replace-buffer-in-windows= for cleaning up all windows currently displaying the buffer to be killed.

  Killing a buffer that is already dead has no effect.

  This function returns =t= if it actually killed the buffer. It returns =nil= if the user refuses to confirm or if buffer-or-name was already dead.

  #+BEGIN_EXAMPLE
                (kill-buffer "foo.unchanged")
                     â‡’ t
                (kill-buffer "foo.changed")

                ---------- Buffer: Minibuffer ----------
                Buffer foo.changed modified; kill anyway? (yes or no) yes
                ---------- Buffer: Minibuffer ----------

                     â‡’ t
  #+END_EXAMPLE
#+END_QUOTE

--- Variable: *kill-buffer-query-functions*

#+BEGIN_QUOTE
  Before confirming unsaved changes, =kill-buffer= calls the functions in the list =kill-buffer-query-functions=, in order of appearance, with no arguments. The buffer being killed is the current buffer when they are called. The idea of this feature is that these functions will ask for confirmation from the user. If any of them returns =nil=, =kill-buffer= spares the buffer's life.
#+END_QUOTE

--- Variable: *kill-buffer-hook*

#+BEGIN_QUOTE
  This is a normal hook run by =kill-buffer= after asking all the questions it is going to ask, just before actually killing the buffer. The buffer to be killed is current when the hook functions run. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Hooks][Hooks]]. This variable is a permanent local, so its local binding is not cleared by changing major modes.
#+END_QUOTE

--- User Option: *buffer-offer-save*

#+BEGIN_QUOTE
  This variable, if non-=nil= in a particular buffer, tells =save-buffers-kill-emacs= to offer to save that buffer, just as it offers to save file-visiting buffers. If =save-some-buffers= is called with the second optional argument set to =t=, it will also offer to save the buffer. Lastly, if this variable is set to the symbol =always=, both =save-buffers-kill-emacs= and =save-some-buffers= will always offer to save. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Definition-of-save_002dsome_002dbuffers][Definition of save-some-buffers]]. The variable =buffer-offer-save= automatically becomes buffer-local when set for any reason. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer_002dLocal-Variables][Buffer-Local Variables]].
#+END_QUOTE

--- Variable: *buffer-save-without-query*

#+BEGIN_QUOTE
  This variable, if non-=nil= in a particular buffer, tells =save-buffers-kill-emacs= and =save-some-buffers= to save this buffer (if it's modified) without asking the user. The variable automatically becomes buffer-local when set for any reason.
#+END_QUOTE

--- Function: *buffer-live-p* object

#+BEGIN_QUOTE
  This function returns =t= if object is a live buffer (a buffer which has not been killed), =nil= otherwise.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Swapping-Text][Swapping Text]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Killing-Buffers][Killing Buffers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.11 Indirect Buffers
    :PROPERTIES:
    :CUSTOM_ID: indirect-buffers
    :END:

An indirect buffer shares the text of some other buffer, which is called the base buffer of the indirect buffer. In some ways it is the analogue, for buffers, of a symbolic link among files. The base buffer may not itself be an indirect buffer.

The text of the indirect buffer is always identical to the text of its base buffer; changes made by editing either one are visible immediately in the other. This includes the text properties as well as the characters themselves.

In all other respects, the indirect buffer and its base buffer are completely separate. They have different names, independent values of point, independent narrowing, independent markers and overlays (though inserting or deleting text in either buffer relocates the markers and overlays for both), independent major modes, and independent buffer-local variable bindings.

An indirect buffer cannot visit a file, but its base buffer can. If you try to save the indirect buffer, that actually saves the base buffer.

Killing an indirect buffer has no effect on its base buffer. Killing the base buffer effectively kills the indirect buffer in that it cannot ever again be the current buffer.

--- Command: *make-indirect-buffer* base-buffer name &optional clone

#+BEGIN_QUOTE
  This creates and returns an indirect buffer named name whose base buffer is base-buffer. The argument base-buffer may be a live buffer or the name (a string) of an existing buffer. If name is the name of an existing buffer, an error is signaled.

  If clone is non-=nil=, then the indirect buffer originally shares the state of base-buffer such as major mode, minor modes, buffer local variables and so on. If clone is omitted or =nil= the indirect buffer's state is set to the default state for new buffers.

  If base-buffer is an indirect buffer, its base buffer is used as the base for the new buffer. If, in addition, clone is non-=nil=, the initial state is copied from the actual base buffer, not from base-buffer.
#+END_QUOTE

--- Command: *clone-indirect-buffer* newname display-flag &optional norecord

#+BEGIN_QUOTE
  This function creates and returns a new indirect buffer that shares the current buffer's base buffer and copies the rest of the current buffer's attributes. (If the current buffer is not indirect, it is used as the base buffer.)

  If display-flag is non-=nil=, as it always is in interactive calls, that means to display the new buffer by calling =pop-to-buffer=. If norecord is non-=nil=, that means not to put the new buffer to the front of the buffer list.
#+END_QUOTE

--- Function: *buffer-base-buffer* &optional buffer

#+BEGIN_QUOTE
  This function returns the base buffer of buffer, which defaults to the current buffer. If buffer is not indirect, the value is =nil=. Otherwise, the value is another buffer, which is never an indirect buffer.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Gap][Buffer Gap]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indirect-Buffers][Indirect Buffers]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.12 Swapping Text Between Two Buffers
    :PROPERTIES:
    :CUSTOM_ID: swapping-text-between-two-buffers
    :END:

Specialized modes sometimes need to let the user access from the same buffer several vastly different types of text. For example, you may need to display a summary of the buffer text, in addition to letting the user access the text itself.

This could be implemented with multiple buffers (kept in sync when the user edits the text), or with narrowing (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Narrowing][Narrowing]]). But these alternatives might sometimes become tedious or prohibitively expensive, especially if each type of text requires expensive buffer-global operations in order to provide correct display and editing commands.

Emacs provides another facility for such modes: you can quickly swap buffer text between two buffers with =buffer-swap-text=. This function is very fast because it doesn't move any text, it only changes the internal data structures of the buffer object to point to a different chunk of text. Using it, you can pretend that a group of two or more buffers are actually a single virtual buffer that holds the contents of all the individual buffers together.

--- Function: *buffer-swap-text* buffer

#+BEGIN_QUOTE
  This function swaps the text of the current buffer and that of its argument buffer. It signals an error if one of the two buffers is an indirect buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indirect-Buffers][Indirect Buffers]]) or is a base buffer of an indirect buffer.

  All the buffer properties that are related to the buffer text are swapped as well: the positions of point and mark, all the markers, the overlays, the text properties, the undo list, the value of the =enable-multibyte-characters= flag (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Representations][enable-multibyte-characters]]), etc.

  *Warning:* If this function is called from within a =save-excursion= form, the current buffer will be set to buffer upon leaving the form, since the marker used by =save-excursion= to save the position and buffer will be swapped as well.
#+END_QUOTE

If you use =buffer-swap-text= on a file-visiting buffer, you should set up a hook to save the buffer's original text rather than what it was swapped with. =write-region-annotate-functions= works for this purpose. You should probably set =buffer-saved-size= to âˆ’2 in the buffer, so that changes in the text it is swapped with will not interfere with auto-saving.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Swapping-Text][Swapping Text]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]

* 27.13 The Buffer Gap
    :PROPERTIES:
    :CUSTOM_ID: the-buffer-gap
    :END:

Emacs buffers are implemented using an invisible gap to make insertion and deletion faster. Insertion works by filling in part of the gap, and deletion adds to the gap. Of course, this means that the gap must first be moved to the locus of the insertion or deletion. Emacs moves the gap only when you try to insert or delete. This is why your first editing command in one part of a large buffer, after previously editing in another far-away part, sometimes involves a noticeable delay.

This mechanism works invisibly, and Lisp code should never be affected by the gap's current location, but these functions are available for getting information about the gap status.

--- Function: *gap-position*

#+BEGIN_QUOTE
  This function returns the current gap position in the current buffer.
#+END_QUOTE

--- Function: *gap-size*

#+BEGIN_QUOTE
  This function returns the current gap size of the current buffer.
#+END_QUOTE
