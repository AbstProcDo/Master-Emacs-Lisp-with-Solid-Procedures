#+TITLE: GNU_Emacs_Lisp_Reference_Manual
* Emacs Lisp Manual                        :PROJECT:emacs:
:PROPERTIES:
:Effort:   10:00
:END:
:LOGBOOK:
- Note taken on [2019-07-16 Tue 11:01] \\
  啰里啰嗦真的没有更进一步的内容．
  学习另外两本书的目录，对冲一下．
CLOCK: [2019-07-16 Tue 08:28]--[2019-07-16 Tue 10:52] =>  2:24
CLOCK: [2019-07-16 Tue 07:57]--[2019-07-16 Tue 08:12] =>  0:15
- Note taken on [2019-07-16 Tue 06:49] \\
  任务的想法归类到任务, 分享agenda任务管理的技巧.
CLOCK: [2019-07-16 Tue 06:16]--[2019-07-16 Tue 07:57] =>  1:41
- Note taken on [2019-07-16 Tue 05:54] \\
  - 真啰嗦, 不然还以为是赚稿费呢
CLOCK: [2019-07-16 Tue 03:23]--[2019-07-16 Tue 06:01] =>  2:38
:END:
* Reference
- [GNU Emacs Lisp Reference
  Manual](https://www.gnu.org/software/emacs/manual/html_mono/elisp.html)

* 1 Introduction
Most of the GNU Emacs text editor is written in the programming language called Emacs Lisp. You can write new code in Emacs Lisp and install it as an extension to the editor. However, Emacs Lisp is more than a mere extension language; it is a full computer programming language in its own right. You can use it as you would any other programming language.

Because Emacs Lisp is designed for use in an editor, it has special features for scanning and parsing text as well as features for *handling files, buffers, displays, subprocesses*, and so on. Emacs Lisp is closely integrated with the editing facilities; thus, editing commands are functions that can also conveniently be called from Lisp programs, and parameters for customization are ordinary Lisp variables.

This manual attempts to be a full description of Emacs Lisp. For a beginner's introduction to Emacs Lisp, see An Introduction to Emacs Lisp Programming, by Bob Chassell, also published by the Free Software Foundation. This manual presumes considerable familiarity with the use of Emacs for editing; see The GNU Emacs Manual for this basic information.

Generally speaking, the earlier chapters describe features of Emacs Lisp that have counterparts in many programming languages, and later chapters describe features that are peculiar to Emacs Lisp or relate specifically to editing.

This is the GNU Emacs Lisp Reference Manual, corresponding to Emacs version 26.2.

** Caveats: Flaws and a request for help.
M-x report-emacs-bug.
** Lisp History: Emacs Lisp is descended from Maclisp.
Emacs Lisp is not at all influenced by Scheme; but the GNU project has an implementation of Scheme, called Guile. We use it in all new GNU software that calls for extensibility.
** Conventions: How the manual is formatted.
#+BEGIN_SRC elisp
 (cons 'foo ())                ; Emphasize the empty list
     (setq foo-flag nil)           ; Emphasize the truth value false

     (car '(1 2))
          ⇒ 1
     (third '(a b c))
          ==> (car (cdr (cdr '(a b c))))
          ⇒ c

     (make-sparse-keymap) == (list 'keymap)
#+END_SRC

*** nil and t
In Emacs Lisp, nil and t are special symbols that always evaluate to themselves.
This is so that you do not need to quote them to use them as constants in a
program. An attempt to change their values results in a setting-constant error.
See Constant Variables.

#+BEGIN_SRC elisp
(progn (prin1 'foo) (princ "\n") (prin1 'bar))
#+END_SRC

#+RESULTS:
: bar

#+BEGIN_SRC python
print('hello')
#+END_SRC

#+RESULTS:
: None

** Version Info: Which Emacs version is running?
** Acknowledgments: The authors, editors, and sponsors of this manual.







* 2 Lisp Data Types

A Lisp object is a piece of data used and manipulated by Lisp programs. For our purposes, a type or data type is a set of possible objects.

Every object belongs to at least one type. Objects of the same type have similar structures and may usually be used in the same contexts. Types can overlap, and objects can belong to two or more types. Consequently, we can ask whether an object belongs to a particular type, but not for /the/ type of an object.

A few fundamental object types are built into Emacs. These, from which all other types are constructed, are called primitive types. Each object belongs to one and only one primitive type. These types include integer, float, cons, symbol, string, vector, hash-table, subr, byte-code function, and record, plus several special types, such as buffer, that are related to editing. (See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]].)

Each primitive type has a corresponding Lisp function that checks whether an object is a member of that type.

Lisp is unlike many other languages in that its objects are self-typing: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.

In most languages, the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp. A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. (Actually, a small number of Emacs Lisp variables can only take on values of a certain type. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Variables-with-Restricted-Values][Variables with Restricted Values]].)

This chapter describes the purpose, printed representation, and read syntax of each of the standard types in GNU Emacs Lisp. Details on how to use these types can be found in later chapters.


** 2.1 Printed Representation and Read Syntax
    :PROPERTIES:
    :CUSTOM_ID: printed-representation-and-read-syntax
    :END:

The printed representation of an object is the format of the output generated by the Lisp printer (the function =prin1=) for that object. Every data type has a unique printed representation. The read syntax of an object is the format of the input accepted by the Lisp reader (the function =read=) for that object. This is not necessarily unique; many kinds of object have more than one syntax. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-and-Print][Read and Print]].

In most cases, an object's printed representation is also a read syntax for the object. However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. These objects are printed in hash notation, which consists of the characters '#<', a descriptive string (typically the type name followed by the name of the object), and a closing '>'. For example:

#+BEGIN_EXAMPLE
         (current-buffer)
              ⇒ #<buffer objects.texi>
#+END_EXAMPLE

Hash notation cannot be read at all, so the Lisp reader signals the error =invalid-read-syntax= whenever it encounters '#<'. In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object's read syntax. Often there is no need to emphasize this distinction, but you must keep it in the back of your mind, or you will occasionally be very confused.

When you evaluate an expression interactively, the Lisp interpreter first reads the textual representation of it, producing a Lisp object, and then evaluates that object (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Evaluation][Evaluation]]). However, evaluation and reading are separate activities. Reading returns the Lisp object represented by the text that is read; the object may or may not be evaluated later. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Functions][Input Functions]], for a description of =read=, the basic function for reading objects.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Printed-Representation][Printed Representation]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lisp-Data-Types][Lisp Data Types]]

** 2.2 Comments

A comment is text that is written in a program only for the sake of humans that read the program, and that has no effect on the meaning of the program. In Lisp, an unescaped semicolon (';') starts a comment if it is not within a string or character constant. The comment continues to the end of line. The Lisp reader discards comments; they do not become part of the Lisp objects which represent the program within the Lisp system.

The '#@count' construct, which skips the next count characters, is useful for program-generated comments containing binary data. The Emacs Lisp byte compiler uses this in its output files (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Byte-Compilation][Byte Compilation]]). It isn't meant for source files, however.

** 2.3 Programming Types

There are two general categories of types in Emacs Lisp: those having to do with Lisp programming, and those having to do with editing. The former exist in many Lisp implementations, in one form or another. The latter are unique to Emacs Lisp.

*** 2.3.1 Integer Type

The range of values for an integer depends on the machine. The minimum range is −536,870,912 to 536,870,911 (30 bits; i.e., −2*29 to 2*29 − 1) but many machines provide a wider range. Emacs Lisp arithmetic functions do not check for integer overflow. Thus =(1+ 536870911)= is −536,870,912 if Emacs integers are 30 bits.

The read syntax for integers is a sequence of (base ten) digits with an optional sign at the beginning and an optional period at the end. The printed representation produced by the Lisp interpreter never has a leading '+' or a final '.'.

#+BEGIN_EXAMPLE
         -1               ; The integer −1.
         1                ; The integer 1.
         1.               ; Also the integer 1.
         +1               ; Also the integer 1.
#+END_EXAMPLE

As a special exception, if a sequence of digits specifies an integer too large or too small to be a valid integer object, the Lisp reader reads it as a floating-point number (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Floating_002dPoint-Type][Floating-Point Type]]). For instance, if Emacs integers are 30 bits, =536870912= is read as the floating-point number =536870912.0=.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Numbers][Numbers]], for more information.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Integer-Type][Integer Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.2 Floating-Point Type
     :PROPERTIES:
     :CUSTOM_ID: floating-point-type
     :END:

Floating-point numbers are the computer equivalent of scientific notation; you can think of a floating-point number as a fraction together with a power of ten. The precise number of significant figures and the range of possible exponents is machine-specific; Emacs uses the C data type =double= to store the value, and internally this records a power of 2 rather than a power of 10.

The printed representation for floating-point numbers requires either a decimal point (with at least one digit following), an exponent, or both. For example, '1500.0', '+15e2', '15.0e+2', '+1500000e-3', and '.15e4' are five ways of writing a floating-point number whose value is 1500. They are all equivalent.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Numbers][Numbers]], for more information.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Symbol-Type][Symbol Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Floating_002dPoint-Type][Floating-Point Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.3 Character Type
     :PROPERTIES:
     :CUSTOM_ID: character-type
     :END:

A character in Emacs Lisp is nothing more than an integer. In other words, characters are represented by their character codes. For example, the character A is represented as the integer 65.

Individual characters are used occasionally in programs, but it is more common to work with /strings/, which are sequences composed of characters. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type][String Type]].

Characters in strings and buffers are currently limited to the range of 0 to 4194303---twenty two bits (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Codes][Character Codes]]). Codes 0 through 127 are ASCII codes; the rest are non-ASCII (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Non_002dASCII-Characters][Non-ASCII Characters]]). Characters that represent keyboard input have a much wider range, to encode modifier keys such as Control, Meta and Shift.

There are special functions for producing a human-readable textual description of a character for the sake of messages. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Describing-Characters][Describing Characters]].

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Char-Syntax][Basic Char Syntax]]: Syntax for regular characters.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#General-Escape-Syntax][General Escape Syntax]]: How to specify characters by their codes.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Ctl_002dChar-Syntax][Ctl-Char Syntax]]: Syntax for control characters.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Meta_002dChar-Syntax][Meta-Char Syntax]]: Syntax for meta-characters.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Other-Char-Bits][Other Char Bits]]: Syntax for hyper-, super-, and alt-characters.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#General-Escape-Syntax][General Escape Syntax]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]]

**** 2.3.3.1 Basic Char Syntax
      :PROPERTIES:
      :CUSTOM_ID: basic-char-syntax
      :END:

Since characters are really integers, the printed representation of a character is a decimal number. This is also a possible read syntax for a character, but writing characters that way in Lisp programs is not clear programming. You should /always/ use the special read syntax formats that Emacs Lisp provides for characters. These syntax formats start with a question mark.

The usual read syntax for alphanumeric characters is a question mark followed by the character; thus, '?A' for the character A, '?B' for the character B, and '?a' for the character a.

For example:

#+BEGIN_EXAMPLE
         ?Q ⇒ 81     ?q ⇒ 113
#+END_EXAMPLE

You can use the same syntax for punctuation characters. However, if the punctuation character has a special syntactic meaning in Lisp, you must quote it with a ''. For example, ‘?(' is the way to write the open-paren character. Likewise, if the character is '', you must use a second ‘' to quote it: ‘?'.

You can express the characters control-g, backspace, tab, newline, vertical tab, formfeed, space, return, del, and escape as '?a', '?b', '?t', '?n', '?v’, ‘?f', '?s', '?r', '?d', and '?e', respectively. ('?s' followed by a dash has a different meaning---it applies the Super modifier to the following character.) Thus,

#+BEGIN_EXAMPLE
         ?a ⇒ 7                 ; control-g, C-g
         ?b ⇒ 8                 ; backspace, <BS>, C-h
         ?t ⇒ 9                 ; tab, <TAB>, C-i
         ?n ⇒ 10                ; newline, C-j
         ?v ⇒ 11                ; vertical tab, C-k
         ?f ⇒ 12                ; formfeed character, C-l
         ?r ⇒ 13                ; carriage return, <RET>, C-m
         ?e ⇒ 27                ; escape character, <ESC>, C-[
         ?s ⇒ 32                ; space character, <SPC>
         ? ⇒ 92                ; backslash character,
         ?d ⇒ 127               ; delete character, <DEL>
#+END_EXAMPLE

These sequences which start with backslash are also known as escape sequences, because backslash plays the role of an escape character; this has nothing to do with the character . 's' is meant for use in character constants; in string constants, just write the space.

A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, '?+' is equivalent to '?+'. There is no reason to add a backslash before most characters. However, you must add a backslash before any of the characters '()[];"', and you should add a backslash before any of the characters '|'`#.,' to avoid confusing the Emacs commands for editing Lisp code. You can also add a backslash before whitespace characters such as space, tab, newline and formfeed. However, it is cleaner to use one of the easily readable escape sequences, such as 't' or 's', instead of an actual whitespace character such as a tab or a space. (If you do write backslash followed by a space, you should write an extra space after the character constant to separate it from the following text.)

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Ctl_002dChar-Syntax][Ctl-Char Syntax]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Char-Syntax][Basic Char Syntax]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]]

**** 2.3.3.2 General Escape Syntax
      :PROPERTIES:
      :CUSTOM_ID: general-escape-syntax
      :END:

In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-ASCII text characters.

1. You can specify characters by their Unicode names, if any. =?N{=NAME=}= represents the Unicode character named NAME. Thus, '?N{LATIN SMALL LETTER A WITH GRAVE}' is equivalent to =?à= and denotes the Unicode character U+00E0. To simplify entering multi-line strings, you can replace spaces in the names by non-empty sequences of whitespace (e.g., newlines).
2. You can specify characters by their Unicode values. =?N{U+=X=}= represents a character with Unicode code point X, where X is a hexadecimal number. Also, =?u=xxxx and =?U=xxxxxxxx represent code points xxxx and xxxxxxxx, respectively, where each x is a single hexadecimal digit. For example, =?N{U+E0}=, =?u00e0= and =?U000000E0= are all equivalent to =?à= and to '?N{LATIN SMALL LETTER A WITH GRAVE}'. The Unicode Standard defines code points only up to 'U+10ffff', so if you specify a code point higher than that, Emacs signals an error.
3. You can specify characters by their hexadecimal character codes. A hexadecimal escape sequence consists of a backslash, 'x', and the hexadecimal character code. Thus, '?x41' is the character A, '?x1' is the character C-a, and =?xe0= is the character à (a with grave accent). You can use any number of hex digits, so you can represent any character code in this way.
4. You can specify characters by their character code in octal. An octal escape sequence consists of a backslash followed by up to three octal digits; thus, '?101' for the character A, '?001' for the character C-a, and =?002= for the character C-b. Only characters up to octal code 777 can be specified this way.

These escape sequences may also be used in strings. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Non_002dASCII-in-Strings][Non-ASCII in Strings]].

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Meta_002dChar-Syntax][Meta-Char Syntax]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#General-Escape-Syntax][General Escape Syntax]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]]

**** 2.3.3.3 Control-Character Syntax
      :PROPERTIES:
      :CUSTOM_ID: control-character-syntax
      :END:

Control characters can be represented using yet another read syntax. This consists of a question mark followed by a backslash, caret, and the corresponding non-control character, in either upper or lower case. For example, both '?^I' and '?^i' are valid read syntax for the character C-i, the character whose value is 9.

Instead of the '^', you can use 'C-'; thus, '?C-i' is equivalent to '?^I' and to '?^i':

#+BEGIN_EXAMPLE
         ?^I ⇒ 9     ?C-I ⇒ 9
#+END_EXAMPLE

In strings and buffers, the only control characters allowed are those that exist in ASCII; but for keyboard input purposes, you can turn any character into a control character with 'C-'. The character codes for these non-ASCII control characters include the 2**26 bit as well as the code for the corresponding non-control character. Ordinary text terminals have no way of generating non-ASCII control characters, but you can generate them straightforwardly using X and other window systems.

For historical reasons, Emacs treats the character as the control equivalent of ?:

#+BEGIN_EXAMPLE
         ?^? ⇒ 127     ?C-? ⇒ 127
#+END_EXAMPLE

As a result, it is currently not possible to represent the character Control-?, which is a meaningful input character under X, using 'C-'. It is not easy to change this, as various Lisp files refer to in this way.

For representing control characters to be found in files or strings, we recommend the '^' syntax; for control characters in keyboard input, we prefer the 'C-' syntax. Which one you use does not affect the meaning of the program, but may guide the understanding of people who read it.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Other-Char-Bits][Other Char Bits]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Ctl_002dChar-Syntax][Ctl-Char Syntax]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]]

**** 2.3.3.4 Meta-Character Syntax
      :PROPERTIES:
      :CUSTOM_ID: meta-character-syntax
      :END:

A meta character is a character typed with the

#+BEGIN_HTML
  <META>
#+END_HTML

modifier key. The integer that represents such a character has the 2**27 bit set. We use high bits for this and other modifiers to make possible a wide range of basic character codes.

In a string, the 2**7 bit attached to an ASCII character indicates a meta character; thus, the meta characters that can fit in a string have codes in the range from 128 to 255, and are the meta versions of the ordinary ASCII characters. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Strings-of-Events][Strings of Events]], for details about

#+BEGIN_HTML
  <META>
#+END_HTML

-handling in strings.

The read syntax for meta characters uses 'M-'. For example, '?M-A' stands for M-A. You can use 'M-' together with octal character codes (see below), with 'C-', or with any other syntax for a character. Thus, you can write M-A as '?M-A', or as '?M-101'. Likewise, you can write C-M-b as '?M-C-b', '?C-M-b', or '?M-002'.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Meta_002dChar-Syntax][Meta-Char Syntax]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]]

**** 2.3.3.5 Other Character Modifier Bits
      :PROPERTIES:
      :CUSTOM_ID: other-character-modifier-bits
      :END:

The case of a graphic character is indicated by its character code; for example, ASCII distinguishes between the characters 'a' and 'A'. But ASCII has no way to represent whether a control character is upper case or lower case. Emacs uses the 2**25 bit to indicate that the shift key was used in typing a control character. This distinction is possible only when you use X terminals or other special terminals; ordinary text terminals do not report the distinction. The Lisp syntax for the shift bit is 'S-'; thus, '?C-S-o' or '?C-S-O' represents the shifted-control-o character.

The X Window System defines three other modifier bits that can be set in a character: hyper, super and alt. The syntaxes for these bits are 'H-', 's-' and 'A-'. (Case is significant in these prefixes.) Thus, '?H-M-A-x' represents Alt-Hyper-Meta-x. (Note that 's' with no following '-' represents the space character.) Numerically, the bit values are 2*22 for alt, 2*23 for super and 2**24 for hyper.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequence-Type][Sequence Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.4 Symbol Type
     :PROPERTIES:
     :CUSTOM_ID: symbol-type
     :END:

A symbol in GNU Emacs Lisp is an object with a name. The symbol name serves as the printed representation of the symbol. In ordinary Lisp use, with one single obarray (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Symbols][Creating Symbols]]), a symbol's name is unique---no two symbols have the same name.

A symbol can serve as a variable, as a function name, or to hold a property list. Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably. In a given context, usually only one of these uses is intended. But you can use one symbol in all of these ways, independently.

A symbol whose name starts with a colon (':') is called a keyword symbol. These symbols automatically act as constants, and are normally used only by comparing an unknown symbol with a few specific alternatives. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Constant-Variables][Constant Variables]].

A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters ‘-+=*/'. Such names require no special punctuation; the characters of the name suffice as long as the name does not look like a number. (If it does, write a ‘' at the beginning of the name to force interpretation as a symbol.) The characters ‘_~!@$%^&:<>{}?' are less often used but also require no special punctuation. Any other characters may be included in a symbol's name by escaping them with a backslash. In contrast to its use in strings, however, a backslash in the name of a symbol simply quotes the single character that follows the backslash. For example, in a string, 't' represents a tab character; in the name of a symbol, however, 't' merely quotes the letter 't'. To have a symbol with a tab character in its name, you must actually use a tab (preceded with a backslash). But it's rare to do such a thing.

#+BEGIN_QUOTE
  *Common Lisp note:* In Common Lisp, lower case letters are always folded to upper case, unless they are explicitly escaped. In Emacs Lisp, upper case and lower case letters are distinct.
#+END_QUOTE

Here are several examples of symbol names. Note that the '+' in the fourth example is escaped to prevent it from being read as a number. This is not necessary in the sixth example because the rest of the name makes it invalid as a number.

#+BEGIN_EXAMPLE
         foo                 ; A symbol named ‘foo’.
         FOO                 ; A symbol named ‘FOO’, different from ‘foo’.
         1+                  ; A symbol named ‘1+’
                             ;   (not ‘+1’, which is an integer).
         +1                 ; A symbol named ‘+1’
                             ;   (not a very readable name).
         (* 1 2)         ; A symbol named ‘(* 1 2)’ (a worse name).


         +-*/_~!@$%^&=:<>{}  ; A symbol named ‘+-*/_~!@$%^&=:<>{}’.
                             ;   These characters need not be escaped.
#+END_EXAMPLE

As an exception to the rule that a symbol's name serves as its printed representation, '##' is the printed representation for an interned symbol whose name is an empty string. Furthermore, '#:foo' is the printed representation for an uninterned symbol whose name is foo. (Normally, the Lisp reader interns all symbols; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Symbols][Creating Symbols]].)

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cell-Type][Cons Cell Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Symbol-Type][Symbol Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.5 Sequence Types
     :PROPERTIES:
     :CUSTOM_ID: sequence-types
     :END:

A sequence is a Lisp object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp: lists and arrays.

Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.

Arrays are fixed-length sequences. They are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, whereas string elements must be characters, and bool-vector elements must be =t= or =nil=. Char-tables are like vectors except that they are indexed by any valid character code. The characters in a string can have text properties like characters in a buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]), but vectors do not support text properties, even when their elements happen to be characters.

Lists, strings and the other array types also share important similarities. For example, all have a length l, and all have elements which can be indexed from zero to l minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function =length= reports the length of any kind of sequence. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequences-Arrays-Vectors][Sequences Arrays Vectors]].

It is generally impossible to read the same sequence twice, since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list =()= always stands for the same object, =nil=.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Array-Type][Array Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequence-Type][Sequence Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.6 Cons Cell and List Types
     :PROPERTIES:
     :CUSTOM_ID: cons-cell-and-list-types
     :END:

A cons cell is an object that consists of two slots, called the car slot and the cdr slot. Each slot can hold any Lisp object. We also say that the car of this cons cell is whatever object its car slot currently holds, and likewise for the cdr.

A list is a series of cons cells, linked together so that the cdr slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol =nil=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lists][Lists]], for details. Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a list structure.

#+BEGIN_QUOTE
  A note to C programmers: a Lisp list thus works as a linked list built up of cons cells. Because pointers in Lisp are implicit, we do not distinguish between a cons cell slot holding a value versus pointing to the value.
#+END_QUOTE

Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called atoms.

The read syntax and printed representation for lists are identical, and consist of a left parenthesis, an arbitrary number of elements, and a right parenthesis. Here are examples of lists:

#+BEGIN_EXAMPLE
         (A 2 "A")            ; A list of three elements.
         ()                   ; A list of no elements (the empty list).
         nil                  ; A list of no elements (the empty list).
         ("A ()")             ; A list of one element: the string "A ()".
         (A ())               ; A list of two elements: A and the empty list.
         (A nil)              ; Equivalent to the previous.
         ((A B C))            ; A list of one element
                              ;   (which is a list of three elements).
#+END_EXAMPLE

Upon reading, each object inside the parentheses becomes an element of the list. That is, a cons cell is made for each element. The car slot of the cons cell holds the element, and its cdr slot refers to the next cons cell of the list, which holds the next element in the list. The cdr slot of the last cons cell is set to hold =nil=.

The names car and cdr derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; car was an instruction to extract the contents of the address part of a register, and cdr an instruction to extract the contents of the decrement. By contrast, cons cells are named for the function =cons= that creates them, which in turn was named for its purpose, the construction of cells.

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Box-Diagrams][Box Diagrams]]: Drawing pictures of lists.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dotted-Pair-Notation][Dotted Pair Notation]]: A general syntax for cons cells.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Association-List-Type][Association List Type]]: A specially constructed list.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dotted-Pair-Notation][Dotted Pair Notation]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cell-Type][Cons Cell Type]]

**** 2.3.6.1 Drawing Lists as Box Diagrams
      :PROPERTIES:
      :CUSTOM_ID: drawing-lists-as-box-diagrams
      :END:

A list can be illustrated by a diagram in which the cons cells are shown as pairs of boxes, like dominoes. (The Lisp reader cannot read such an illustration; unlike the textual notation, which can be understood by both humans and computers, the box illustrations can be understood only by humans.) This picture represents the three-element list =(rose violet buttercup)=:

#+BEGIN_EXAMPLE
             --- ---      --- ---      --- ---
            |   |   |--> |   |   |--> |   |   |--> nil
             --- ---      --- ---      --- ---
              |            |            |
              |            |            |
               --> rose     --> violet   --> buttercup
#+END_EXAMPLE

In this diagram, each box represents a slot that can hold or refer to any Lisp object. Each pair of boxes represents a cons cell. Each arrow represents a reference to a Lisp object, either an atom or another cons cell.

In this example, the first box, which holds the car of the first cons cell, refers to or holds =rose= (a symbol). The second box, holding the cdr of the first cons cell, refers to the next pair of boxes, the second cons cell. The car of the second cons cell is =violet=, and its cdr is the third cons cell. The cdr of the third (and last) cons cell is =nil=.

Here is another diagram of the same list, =(rose violet buttercup)=, sketched in a different manner:

#+BEGIN_EXAMPLE
          ---------------       ----------------       -------------------
         | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
         | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
         |       |       |     |        |       |     |           |       |
          ---------------       ----------------       -------------------
#+END_EXAMPLE

A list with no elements in it is the empty list; it is identical to the symbol =nil=. In other words, =nil= is both a symbol and a list.

Here is the list =(A ())=, or equivalently =(A nil)=, depicted with boxes and arrows:

#+BEGIN_EXAMPLE
             --- ---      --- ---
            |   |   |--> |   |   |--> nil
             --- ---      --- ---
              |            |
              |            |
               --> A        --> nil
#+END_EXAMPLE

Here is a more complex illustration, showing the three-element list, =((pine needles) oak maple)=, the first element of which is a two-element list:

#+BEGIN_EXAMPLE
             --- ---      --- ---      --- ---
            |   |   |--> |   |   |--> |   |   |--> nil
             --- ---      --- ---      --- ---
              |            |            |
              |            |            |
              |             --> oak      --> maple
              |
              |     --- ---      --- ---
               --> |   |   |--> |   |   |--> nil
                    --- ---      --- ---
                     |            |
                     |            |
                      --> pine     --> needles
#+END_EXAMPLE

The same list represented in the second box notation looks like this:

#+BEGIN_EXAMPLE
          --------------       --------------       --------------
         | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
         |   o   |   o------->| oak   |   o------->| maple |  nil |
         |   |   |      |     |       |      |     |       |      |
          -- | ---------       --------------       --------------
             |
             |
             |        --------------       ----------------
             |       | car   | cdr  |     | car     | cdr  |
              ------>| pine  |   o------->| needles |  nil |
                     |       |      |     |         |      |
                      --------------       ----------------
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Association-List-Type][Association List Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Box-Diagrams][Box Diagrams]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cell-Type][Cons Cell Type]]

**** 2.3.6.2 Dotted Pair Notation
      :PROPERTIES:
      :CUSTOM_ID: dotted-pair-notation
      :END:

Dotted pair notation is a general syntax for cons cells that represents the car and cdr explicitly. In this syntax, =(=a=.=b=)= stands for a cons cell whose car is the object a and whose cdr is the object b. Dotted pair notation is more general than list syntax because the cdr does not have to be a list. However, it is more cumbersome in cases where list syntax would work. In dotted pair notation, the list '(1 2 3)' is written as '(1 . (2 . (3 . nil)))'. For =nil=-terminated lists, you can use either notation, but list notation is usually clearer and more convenient. When printing a list, the dotted pair notation is only used if the cdr of a cons cell is not a list.

Here's an example using boxes to illustrate dotted pair notation. This example shows the pair =(rose . violet)=:

#+BEGIN_EXAMPLE
             --- ---
            |   |   |--> violet
             --- ---
              |
              |
               --> rose
#+END_EXAMPLE

You can combine dotted pair notation with list notation to represent conveniently a chain of cons cells with a non-=nil= final cdr. You write a dot after the last element of the list, followed by the cdr of the final cons cell. For example, =(rose violet . buttercup)= is equivalent to =(rose . (violet . buttercup))=. The object looks like this:

#+BEGIN_EXAMPLE
             --- ---      --- ---
            |   |   |--> |   |   |--> buttercup
             --- ---      --- ---
              |            |
              |            |
               --> rose     --> violet
#+END_EXAMPLE

The syntax =(rose . violet . buttercup)= is invalid because there is nothing that it could mean. If anything, it would say to put =buttercup= in the cdr of a cons cell whose cdr is already used for =violet=.

The list =(rose violet)= is equivalent to =(rose . (violet))=, and looks like this:

#+BEGIN_EXAMPLE
             --- ---      --- ---
            |   |   |--> |   |   |--> nil
             --- ---      --- ---
              |            |
              |            |
               --> rose     --> violet
#+END_EXAMPLE

Similarly, the three-element list =(rose violet buttercup)= is equivalent to =(rose . (violet . (buttercup)))=. It looks like this:

#+BEGIN_EXAMPLE
             --- ---      --- ---      --- ---
            |   |   |--> |   |   |--> |   |   |--> nil
             --- ---      --- ---      --- ---
              |            |            |
              |            |            |
               --> rose     --> violet   --> buttercup
#+END_EXAMPLE

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dotted-Pair-Notation][Dotted Pair Notation]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cell-Type][Cons Cell Type]]

**** 2.3.6.3 Association List Type
      :PROPERTIES:
      :CUSTOM_ID: association-list-type
      :END:

An association list or alist is a specially-constructed list whose elements are cons cells. In each element, the car is considered a key, and the cdr is considered an associated value. (In some cases, the associated value is stored in the car of the cdr.) Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.

For example,

#+BEGIN_EXAMPLE
         (setq alist-of-colors
               '((rose . red) (lily . white) (buttercup . yellow)))
#+END_EXAMPLE

sets the variable =alist-of-colors= to an alist of three elements. In the first element, =rose= is the key and =red= is the value.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Association-Lists][Association Lists]], for a further explanation of alists and for functions that work on alists. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Hash-Tables][Hash Tables]], for another kind of lookup table, which is much faster for handling a large number of keys.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type][String Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cell-Type][Cons Cell Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.7 Array Type
     :PROPERTIES:
     :CUSTOM_ID: array-type
     :END:

An array is composed of an arbitrary number of slots for holding or referring to other Lisp objects, arranged in a contiguous block of memory. Accessing any element of an array takes approximately the same amount of time. In contrast, accessing an element of a list requires time proportional to the position of the element in the list. (Elements at the end of a list take longer to access than elements at the beginning of a list.)

Emacs defines four types of array: strings, vectors, bool-vectors, and char-tables.

A string is an array of characters and a vector is an array of arbitrary objects. A bool-vector can hold only =t= or =nil=. These kinds of array may have any length up to the largest integer. Char-tables are sparse arrays indexed by any valid character code; they can hold arbitrary objects.

The first element of an array has index zero, the second element has index 1, and so on. This is called zero-origin indexing. For example, an array of four elements has indices 0, 1, 2, and 3. The largest possible index value is one less than the length of the array. Once an array is created, its length is fixed.

All Emacs Lisp arrays are one-dimensional. (Most other programming languages support multidimensional arrays, but they are not essential; you can get the same effect with nested one-dimensional arrays.) Each type of array has its own read syntax; see the following sections for details.

The array type is a subset of the sequence type, and contains the string type, the vector type, the bool-vector type, and the char-table type.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vector-Type][Vector Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Array-Type][Array Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.8 String Type
     :PROPERTIES:
     :CUSTOM_ID: string-type
     :END:

A string is an array of characters. Strings are used for many purposes in Emacs, as can be expected in a text editor; for example, as the names of Lisp symbols, as messages for the user, and to represent text extracted from buffers. Strings in Lisp are constants: evaluation of a string returns the same string.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Strings-and-Characters][Strings and Characters]], for functions that operate on strings.

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-for-Strings][Syntax for Strings]]: How to specify Lisp strings.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Non_002dASCII-in-Strings][Non-ASCII in Strings]]: International characters in strings.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Nonprinting-Characters][Nonprinting Characters]]: Literal unprintable characters in strings.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Props-and-Strings][Text Props and Strings]]: Strings with text properties.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Non_002dASCII-in-Strings][Non-ASCII in Strings]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type][String Type]]

**** 2.3.8.1 Syntax for Strings
      :PROPERTIES:
      :CUSTOM_ID: syntax-for-strings
      :END:

The read syntax for a string is a double-quote, an arbitrary number of characters, and another double-quote, ="like this"=. To include a double-quote in a string, precede it with a backslash; thus, ="""= is a string containing just one double-quote character. Likewise, you can include a backslash by preceding it with another backslash, like this: ="this  is a single embedded backslash"=.

The newline character is not special in the read syntax for strings; if you write a new line between the double-quotes, it becomes a character in the string. But an escaped newline---one that is preceded by ''---does not become part of the string; i.e., the Lisp reader ignores an escaped newline while reading a string. An escaped space ‘ ' is likewise ignored.

#+BEGIN_EXAMPLE
         "It is useful to include newlines
         in documentation strings,
         but the newline is
         ignored if escaped."
              ⇒ "It is useful to include newlines
         in documentation strings,
         but the newline is ignored if escaped."
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Nonprinting-Characters][Nonprinting Characters]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-for-Strings][Syntax for Strings]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type][String Type]]

**** 2.3.8.2 Non-ASCII Characters in Strings
      :PROPERTIES:
      :CUSTOM_ID: non-ascii-characters-in-strings
      :END:

There are two text representations for non-ASCII characters in Emacs strings: multibyte and unibyte (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Representations][Text Representations]]). Roughly speaking, unibyte strings store raw bytes, while multibyte strings store human-readable text. Each character in a unibyte string is a byte, i.e., its value is between 0 and 255. By contrast, each character in a multibyte string may have a value between 0 to 4194303 (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]]). In both cases, characters above 127 are non-ASCII.

You can include a non-ASCII character in a string constant by writing it literally. If the string constant is read from a multibyte source, such as a multibyte buffer or string, or a file that would be visited as multibyte, then Emacs reads each non-ASCII character as a multibyte character and automatically makes the string a multibyte string. If the string constant is read from a unibyte source, then Emacs reads the non-ASCII character as unibyte, and makes the string unibyte.

Instead of writing a character literally into a multibyte string, you can write it as its character code using an escape sequence. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#General-Escape-Syntax][General Escape Syntax]], for details about escape sequences.

If you use any Unicode-style escape sequence 'uNNNN' or 'U00NNNNNN' in a string constant (even for an ASCII character), Emacs automatically assumes that it is multibyte.

You can also use hexadecimal escape sequences ('xn') and octal escape sequences ('n') in string constants. *But beware:* If a string constant contains hexadecimal or octal escape sequences, and these escape sequences all specify unibyte characters (i.e., less than 256), and there are no other literal non-ASCII characters or Unicode-style escape sequences in the string, then Emacs automatically assumes that it is a unibyte string. That is to say, it assumes that all non-ASCII characters occurring in the string are 8-bit raw bytes.

In hexadecimal and octal escape sequences, the escaped character code may contain a variable number of digits, so the first subsequent character which is not a valid hexadecimal or octal digit terminates the escape sequence. If the next character in a string could be interpreted as a hexadecimal or octal digit, write ' ' (backslash and space) to terminate the escape sequence. For example, 'xe0 ' represents one character, 'a' with grave accent. ' ' in a string constant is just like backslash-newline; it does not contribute any character to the string, but it does terminate any preceding hex escape.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Props-and-Strings][Text Props and Strings]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Non_002dASCII-in-Strings][Non-ASCII in Strings]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type][String Type]]

**** 2.3.8.3 Nonprinting Characters in Strings
      :PROPERTIES:
      :CUSTOM_ID: nonprinting-characters-in-strings
      :END:

You can use the same backslash escape-sequences in a string constant as in character literals (but do not use the question mark that begins a character constant). For example, you can write a string containing the nonprinting characters tab and C-a, with commas and spaces between them, like this: ="t, C-a"=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]], for a description of the read syntax for characters.

However, not all of the characters you can write with backslash escape-sequences are valid in strings. The only control characters that a string can hold are the ASCII control characters. Strings do not distinguish case in ASCII control characters.

Properly speaking, strings cannot hold meta characters; but when a string is to be used as a key sequence, there is a special convention that provides a way to represent meta versions of ASCII characters in a string. If you use the 'M-' syntax to indicate a meta character in a string constant, this sets the 2**7 bit of the character in the string. If the string is used in =define-key= or =lookup-key=, this numeric code is translated into the equivalent meta character. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]].

Strings cannot hold characters that have the hyper, super, or alt modifiers.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Nonprinting-Characters][Nonprinting Characters]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type][String Type]]

**** 2.3.8.4 Text Properties in Strings
      :PROPERTIES:
      :CUSTOM_ID: text-properties-in-strings
      :END:

A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text's properties with no special effort. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]], for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:

#+BEGIN_EXAMPLE
         #("characters" property-data...)
#+END_EXAMPLE

where property-data consists of zero or more elements, in groups of three as follows:

#+BEGIN_EXAMPLE
         beg end plist
#+END_EXAMPLE

The elements beg and end are integers, and together specify a range of indices in the string; plist is the property list for that range. For example,

#+BEGIN_EXAMPLE
         #("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
#+END_EXAMPLE

represents a string whose textual contents are 'foo bar', in which the first three characters have a =face= property with value =bold=, and the last three have a =face= property with value =italic=. (The fourth character has no text properties, so its property list is =nil=. It is not actually necessary to mention ranges with =nil= as the property list, since any characters not mentioned in any range will default to having no properties.)

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Char_002dTable-Type][Char-Table Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type][String Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.9 Vector Type

A vector is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)

The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket. This is also the read syntax. Like numbers and strings, vectors are considered constants for evaluation.

#+BEGIN_EXAMPLE
         [1 "two" (three)]      ; A vector of three elements.
              ⇒ [1 "two" (three)]
#+END_EXAMPLE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vectors][Vectors]], for functions that work with vectors.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Bool_002dVector-Type][Bool-Vector Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vector-Type][Vector Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.10 Char-Table Type
     :PROPERTIES:
     :CUSTOM_ID: char-table-type
     :END:

A char-table is a one-dimensional array of elements of any type, indexed by character codes. Char-tables have certain extra features to make them more useful for many jobs that involve assigning information to character codes---for example, a char-table can have a parent to inherit from, a default value, and a small number of extra slots to use for special purposes. A char-table can also specify a single value for a whole character set.

The printed representation of a char-table is like a vector except that there is an extra '#^' at the beginning.[[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#fn-1][1]]

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Char_002dTables][Char-Tables]], for special functions to operate on char-tables. Uses of char-tables include:

- Case tables (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Case-Tables][Case Tables]]).
- Character category tables (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Categories][Categories]]).
- Display tables (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Display-Tables][Display Tables]]).
- Syntax tables (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Tables][Syntax Tables]]).

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Hash-Table-Type][Hash Table Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Char_002dTable-Type][Char-Table Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.11 Bool-Vector Type
     :PROPERTIES:
     :CUSTOM_ID: bool-vector-type
     :END:

A bool-vector is a one-dimensional array whose elements must be =t= or =nil=.

The printed representation of a bool-vector is like a string, except that it begins with '#&' followed by the length. The string constant that follows actually specifies the contents of the bool-vector as a bitmap---each character in the string contains 8 bits, which specify the next 8 elements of the bool-vector (1 stands for =t=, and 0 for =nil=). The least significant bits of the character correspond to the lowest indices in the bool-vector.

#+BEGIN_EXAMPLE
         (make-bool-vector 3 t)
              ⇒ #&3"^G"
         (make-bool-vector 3 nil)
              ⇒ #&3"^@"
#+END_EXAMPLE

These results make sense, because the binary code for 'C-g' is 111 and 'C-@' is the character with code 0.

If the length is not a multiple of 8, the printed representation shows extra elements, but these extras really make no difference. For instance, in the next example, the two bool-vectors are equal, because only the first 3 bits are used:

#+BEGIN_EXAMPLE
         (equal #&3"377" #&3"007")
              ⇒ t
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Function-Type][Function Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Bool_002dVector-Type][Bool-Vector Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.12 Hash Table Type
     :PROPERTIES:
     :CUSTOM_ID: hash-table-type
     :END:

A hash table is a very fast kind of lookup table, somewhat like an alist in that it maps keys to corresponding values, but much faster. The printed representation of a hash table specifies its properties and contents, like this:

#+BEGIN_EXAMPLE
         (make-hash-table)
              ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                                      rehash-threshold 0.8125 data ())
#+END_EXAMPLE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Hash-Tables][Hash Tables]], for more information about hash tables.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Macro-Type][Macro Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Hash-Table-Type][Hash Table Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.13 Function Type
     :PROPERTIES:
     :CUSTOM_ID: function-type
     :END:

Lisp functions are executable code, just like functions in other programming languages. In Lisp, unlike most languages, functions are also Lisp objects. A non-compiled function in Lisp is a lambda expression: that is, a list whose first element is the symbol =lambda= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lambda-Expressions][Lambda Expressions]]).

In most programming languages, it is impossible to have a function without a name. In Lisp, a function has no intrinsic name. A lambda expression can be called as a function even though it has no name; to emphasize this, we also call it an anonymous function (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Anonymous-Functions][Anonymous Functions]]). A named function in Lisp is just a symbol with a valid function in its function cell (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Defining-Functions][Defining Functions]]).

Most of the time, functions are called when their names are written in Lisp expressions in Lisp programs. However, you can construct or obtain a function object at run time and then call it with the primitive functions =funcall= and =apply=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Calling-Functions][Calling Functions]].

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Primitive-Function-Type][Primitive Function Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Function-Type][Function Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.14 Macro Type
     :PROPERTIES:
     :CUSTOM_ID: macro-type
     :END:

A Lisp macro is a user-defined construct that extends the Lisp language. It is represented as an object much like a function, but with different argument-passing semantics. A Lisp macro has the form of a list whose first element is the symbol =macro= and whose cdr is a Lisp function object, including the =lambda= symbol.

Lisp macro objects are usually defined with the built-in =defmacro= macro, but any list that begins with =macro= is a macro as far as Emacs is concerned. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Macros][Macros]], for an explanation of how to write a macro.

*Warning*: Lisp macros and keyboard macros (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keyboard-Macros][Keyboard Macros]]) are entirely different things. When we use the word "macro" without qualification, we mean a Lisp macro, not a keyboard macro.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Byte_002dCode-Type][Byte-Code Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Macro-Type][Macro Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.15 Primitive Function Type
     :PROPERTIES:
     :CUSTOM_ID: primitive-function-type
     :END:

A primitive function is a function callable from Lisp but written in the C programming language. Primitive functions are also called subrs or built-in functions. (The word "subr" is derived from "subroutine".) Most primitive functions evaluate all their arguments when they are called. A primitive function that does not evaluate all its arguments is called a special form (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Special-Forms][Special Forms]]).

It does not matter to the caller of a function whether the function is primitive. However, this does matter if you try to redefine a primitive with a function written in Lisp. The reason is that the primitive function may be called directly from C code. Calls to the redefined function from Lisp will use the new definition, but calls from C code may still use the built-in definition. Therefore, *we discourage redefinition of primitive functions*.

The term function refers to all Emacs functions, whether written in Lisp or C. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Function-Type][Function Type]], for information about the functions written in Lisp.

Primitive functions have no read syntax and print in hash notation with the name of the subroutine.

#+BEGIN_EXAMPLE
         (symbol-function 'car)          ; Access the function cell
                                         ;   of the symbol.
              ⇒ #<subr car>
         (subrp (symbol-function 'car))  ; Is this a primitive function?
              ⇒ t                       ; Yes.
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Record-Type][Record Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Primitive-Function-Type][Primitive Function Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.16 Byte-Code Function Type
     :PROPERTIES:
     :CUSTOM_ID: byte-code-function-type
     :END:

Byte-code function objects are produced by byte-compiling Lisp code (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Byte-Compilation][Byte Compilation]]). Internally, a byte-code function object is much like a vector; however, the evaluator handles this data type specially when it appears in a function call. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Byte_002dCode-Objects][Byte-Code Objects]].

The printed representation and read syntax for a byte-code function object is like that for a vector, with an additional '#' before the opening '['.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Type-Descriptors][Type Descriptors]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Byte_002dCode-Type][Byte-Code Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.17 Record Type
     :PROPERTIES:
     :CUSTOM_ID: record-type
     :END:

A record is much like a =vector=. However, the first element is used to hold its type as returned by =type-of=. The purpose of records is to allow programmers to create objects with new types that are not built into Emacs.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Records][Records]], for functions that work with records.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Autoload-Type][Autoload Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Record-Type][Record Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.18 Type Descriptors
     :PROPERTIES:
     :CUSTOM_ID: type-descriptors
     :END:

A type descriptor is a =record= which holds information about a type. Slot 1 in the record must be a symbol naming the type, and =type-of= relies on this to return the type of =record= objects. No other type descriptor slot is used by Emacs; they are free for use by Lisp extensions.

An example of a type descriptor is any instance of =cl-structure-class=.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Finalizer-Type][Finalizer Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Type-Descriptors][Type Descriptors]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.19 Autoload Type
     :PROPERTIES:
     :CUSTOM_ID: autoload-type
     :END:

An autoload object is a list whose first element is the symbol =autoload=. It is stored as the function definition of a symbol, where it serves as a placeholder for the real definition. The autoload object says that the real definition is found in a file of Lisp code that should be loaded when necessary. It contains the name of the file, plus some other information about the real definition.

After the file has been loaded, the symbol should have a new function definition that is not an autoload object. The new definition is then called as if it had been there to begin with. From the user's point of view, the function call works as expected, using the function definition in the loaded file.

An autoload object is usually created with the function =autoload=, which stores the object in the function cell of a symbol. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Autoload][Autoload]], for more details.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Autoload-Type][Autoload Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]

*** 2.3.20 Finalizer Type
     :PROPERTIES:
     :CUSTOM_ID: finalizer-type
     :END:

A finalizer object helps Lisp code clean up after objects that are no longer needed. A finalizer holds a Lisp function object. When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer's associated function object. When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves.

Errors in finalizers are printed to =*Messages*=. Emacs runs a given finalizer object's associated function exactly once, even if that function fails.

--- Function: *make-finalizer*

#+BEGIN_QUOTE
  Make a finalizer that will run function. function will be called after garbage collection when the returned finalizer object becomes unreachable. If the finalizer object is reachable only through references from finalizer objects, it does not count as reachable for the purpose of deciding whether to run function. function will be run once per finalizer object.
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Circular-Objects][Circular Objects]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lisp-Data-Types][Lisp Data Types]]

** 2.4 Editing Types
    :PROPERTIES:
    :CUSTOM_ID: editing-types
    :END:

The types in the previous section are used for general programming purposes, and most of them are common to most Lisp dialects. Emacs Lisp provides several additional data types for purposes connected with editing.

- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Type][Buffer Type]]: The basic object of editing.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Marker-Type][Marker Type]]: A position in a buffer.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Type][Window Type]]: Buffers are displayed in windows.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Type][Frame Type]]: Windows subdivide frames.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Terminal-Type][Terminal Type]]: A terminal device displays frames.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configuration-Type][Window Configuration Type]]: Recording the way a frame is subdivided.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configuration-Type][Frame Configuration Type]]: Recording the status of all frames.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Process-Type][Process Type]]: A subprocess of Emacs running on the underlying OS.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Thread-Type][Thread Type]]: A thread of Emacs Lisp execution.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mutex-Type][Mutex Type]]: An exclusive lock for thread synchronization.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Condition-Variable-Type][Condition Variable Type]]: Condition variable for thread synchronization.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Stream-Type][Stream Type]]: Receive or send characters.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymap-Type][Keymap Type]]: What function a keystroke invokes.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlay-Type][Overlay Type]]: How an overlay is represented.
- [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Font-Type][Font Type]]: Fonts for displaying text.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Marker-Type][Marker Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.1 Buffer Type
     :PROPERTIES:
     :CUSTOM_ID: buffer-type
     :END:

A buffer is an object that holds text that can be edited (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffers][Buffers]]). Most buffers hold the contents of a disk file (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Files][Files]]) so they can be edited, but some are used for other purposes. Most buffers are also meant to be seen by the user, and therefore displayed, at some time, in a window (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]]). But a buffer need not be displayed in any window. Each buffer has a designated position called point (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Positions][Positions]]); most editing commands act on the contents of the current buffer in the neighborhood of point. At any time, one buffer is the current buffer.

The contents of a buffer are much like a string, but buffers are not used like strings in Emacs Lisp, and the available operations are different. For example, you can insert text efficiently into an existing buffer, altering the buffer's contents, whereas inserting text into a string requires concatenating substrings, and the result is an entirely new string object.

Many of the standard Emacs functions manipulate or test the characters in the current buffer; a whole chapter in this manual is devoted to describing these functions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text][Text]]).

Several other data structures are associated with each buffer:

- a local syntax table (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Tables][Syntax Tables]]);
- a local keymap (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymaps][Keymaps]]); and,
- a list of buffer-local variable bindings (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer_002dLocal-Variables][Buffer-Local Variables]]).
- overlays (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlays][Overlays]]).
- text properties for the text in the buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]).

The local keymap and variable list contain entries that individually override global bindings or values. These are used to customize the behavior of programs in different buffers, without actually changing the programs.

A buffer may be indirect, which means it shares the text of another buffer, but presents it differently. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Indirect-Buffers][Indirect Buffers]].

Buffers have no read syntax. They print in hash notation, showing the buffer name.

#+BEGIN_EXAMPLE
         (current-buffer)
              ⇒ #<buffer objects.texi>
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Type][Window Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Type][Buffer Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.2 Marker Type
     :PROPERTIES:
     :CUSTOM_ID: marker-type
     :END:

A marker denotes a position in a specific buffer. Markers therefore have two components: one for the buffer, and one for the position. Changes in the buffer's text automatically relocate the position value as necessary to ensure that the marker always points between the same two characters in the buffer.

Markers have no read syntax. They print in hash notation, giving the current character position and the name of the buffer.

#+BEGIN_EXAMPLE
         (point-marker)
              ⇒ #<marker at 10779 in objects.texi>
#+END_EXAMPLE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Markers][Markers]], for information on how to test, create, copy, and move markers.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Type][Frame Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Marker-Type][Marker Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.3 Window Type
     :PROPERTIES:
     :CUSTOM_ID: window-type
     :END:

A window describes the portion of the terminal screen that Emacs uses to display a buffer. Every window has one associated buffer, whose contents appear in the window. By contrast, a given buffer may appear in one window, no window, or several windows.

Though many windows may exist simultaneously, at any time one window is designated the selected window. This is the window where the cursor is (usually) displayed when Emacs is ready for a command. The selected window usually displays the current buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Current-Buffer][Current Buffer]]), but this is not necessarily the case.

Windows are grouped on the screen into frames; each window belongs to one and only one frame. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Type][Frame Type]].

Windows have no read syntax. They print in hash notation, giving the window number and the name of the buffer being displayed. The window numbers exist to identify windows uniquely, since the buffer displayed in any given window can change frequently.

#+BEGIN_EXAMPLE
         (selected-window)
              ⇒ #<window 1 on objects.texi>
#+END_EXAMPLE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Windows][Windows]], for a description of the functions that work on windows.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Terminal-Type][Terminal Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Type][Window Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.4 Frame Type
     :PROPERTIES:
     :CUSTOM_ID: frame-type
     :END:

A frame is a screen area that contains one or more Emacs windows; we also use the term "frame" to refer to the Lisp object that Emacs uses to refer to the screen area.

Frames have no read syntax. They print in hash notation, giving the frame's title, plus its address in core (useful to identify the frame uniquely).

#+BEGIN_EXAMPLE
         (selected-frame)
              ⇒ #<frame emacs@psilocin.gnu.org 0xdac80>
#+END_EXAMPLE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frames][Frames]], for a description of the functions that work on frames.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configuration-Type][Window Configuration Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Type][Frame Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.5 Terminal Type
     :PROPERTIES:
     :CUSTOM_ID: terminal-type
     :END:

A terminal is a device capable of displaying one or more Emacs frames (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Type][Frame Type]]).

Terminals have no read syntax. They print in hash notation giving the terminal's ordinal number and its TTY device file name.

#+BEGIN_EXAMPLE
         (get-device-terminal nil)
              ⇒ #<terminal 1 on /dev/tty>
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configuration-Type][Frame Configuration Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Terminal-Type][Terminal Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.6 Window Configuration Type
     :PROPERTIES:
     :CUSTOM_ID: window-configuration-type
     :END:

A window configuration stores information about the positions, sizes, and contents of the windows in a frame, so you can recreate the same arrangement of windows later.

Window configurations do not have a read syntax; their print syntax looks like '#'. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][Window Configurations]], for a description of several functions related to window configurations.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Process-Type][Process Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configuration-Type][Window Configuration Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.7 Frame Configuration Type
     :PROPERTIES:
     :CUSTOM_ID: frame-configuration-type
     :END:

A frame configuration stores information about the positions, sizes, and contents of the windows in all frames. It is not a primitive type---it is actually a list whose car is =frame-configuration= and whose cdr is an alist. Each alist element describes one frame, which appears as the car of that element.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configurations][Frame Configurations]], for a description of several functions related to frame configurations.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Thread-Type][Thread Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configuration-Type][Frame Configuration Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.8 Process Type
     :PROPERTIES:
     :CUSTOM_ID: process-type
     :END:

The word process usually means a running program. Emacs itself runs in a process of this sort. However, in Emacs Lisp, a process is a Lisp object that designates a subprocess created by the Emacs process. Programs such as shells, GDB, ftp, and compilers, running in subprocesses of Emacs, extend the capabilities of Emacs. An Emacs subprocess takes textual input from Emacs and returns textual output to Emacs for further manipulation. Emacs can also send signals to the subprocess.

Process objects have no read syntax. They print in hash notation, giving the name of the process:

#+BEGIN_EXAMPLE
         (process-list)
              ⇒ (#<process shell>)
#+END_EXAMPLE

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Processes][Processes]], for information about functions that create, delete, return information about, send input or signals to, and receive output from processes.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mutex-Type][Mutex Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Process-Type][Process Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.9 Thread Type
     :PROPERTIES:
     :CUSTOM_ID: thread-type
     :END:

A thread in Emacs represents a separate thread of Emacs Lisp execution. It runs its own Lisp program, has its own current buffer, and can have subprocesses locked to it, i.e. subprocesses whose output only this thread can accept. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Threads][Threads]].

Thread objects have no read syntax. They print in hash notation, giving the name of the thread (if it has been given a name) or its address in core:

#+BEGIN_EXAMPLE
         (all-threads)
             ⇒ (#<thread 0176fc40>)
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Condition-Variable-Type][Condition Variable Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Thread-Type][Thread Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.10 Mutex Type
     :PROPERTIES:
     :CUSTOM_ID: mutex-type
     :END:

A mutex is an exclusive lock that threads can own and disown, in order to synchronize between them. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mutexes][Mutexes]].

Mutex objects have no read syntax. They print in hash notation, giving the name of the mutex (if it has been given a name) or its address in core:

#+BEGIN_EXAMPLE
         (make-mutex "my-mutex")
             ⇒ #<mutex my-mutex>
         (make-mutex)
             ⇒ #<mutex 01c7e4e0>
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Stream-Type][Stream Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mutex-Type][Mutex Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.11 Condition Variable Type
     :PROPERTIES:
     :CUSTOM_ID: condition-variable-type
     :END:

A condition variable is a device for a more complex thread synchronization than the one supported by a mutex. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.

Condition variable objects have no read syntax. They print in hash notation, giving the name of the condition variable (if it has been given a name) or its address in core:

#+BEGIN_EXAMPLE
         (make-condition-variable (make-mutex))
             ⇒ #<condvar 01c45ae8>
#+END_EXAMPLE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymap-Type][Keymap Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Condition-Variable-Type][Condition Variable Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.12 Stream Type
     :PROPERTIES:
     :CUSTOM_ID: stream-type
     :END:

A stream is an object that can be used as a source or sink for characters---either to supply characters for input or to accept them as output. Many different types can be used this way: markers, buffers, strings, and functions. Most often, input streams (character sources) obtain characters from the keyboard, a buffer, or a file, and output streams (character sinks) send characters to a buffer, such as a /Help/ buffer, or to the echo area.

The object =nil=, in addition to its other meanings, may be used as a stream. It stands for the value of the variable =standard-input= or =standard-output=. Also, the object =t= as a stream specifies input using the minibuffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Minibuffers][Minibuffers]]) or output in the echo area (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#The-Echo-Area][The Echo Area]]).

Streams have no special printed representation or read syntax, and print as whatever primitive type they are.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Read-and-Print][Read and Print]], for a description of functions related to streams, including parsing and printing functions.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlay-Type][Overlay Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Stream-Type][Stream Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.13 Keymap Type
     :PROPERTIES:
     :CUSTOM_ID: keymap-type
     :END:

A keymap maps keys typed by the user to commands. This mapping controls how the user's command input is executed. A keymap is actually a list whose car is the symbol =keymap=.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymaps][Keymaps]], for information about creating keymaps, handling prefix keys, local as well as global keymaps, and changing key bindings.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Font-Type][Font Type]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymap-Type][Keymap Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.14 Overlay Type
     :PROPERTIES:
     :CUSTOM_ID: overlay-type
     :END:

An overlay specifies properties that apply to a part of a buffer. Each overlay applies to a specified range of the buffer, and contains a property list (a list whose elements are alternating property names and values). Overlay properties are used to present parts of the buffer temporarily in a different display style. Overlays have no read syntax, and print in hash notation, giving the buffer name and range of positions.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlays][Overlays]], for information on how you can create and use overlays.

Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlay-Type][Overlay Type]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]

*** 2.4.15 Font Type
     :PROPERTIES:
     :CUSTOM_ID: font-type
     :END:

A font specifies how to display text on a graphical terminal. There are actually three separate font types---font objects, font specs, and font entities---each of which has slightly different properties. None of them have a read syntax; their print syntax looks like '#', '#', and '#' respectively. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Low_002dLevel-Font][Low-Level Font]], for a description of these Lisp objects.

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Type-Predicates][Type Predicates]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lisp-Data-Types][Lisp Data Types]]

** 2.5 Read Syntax for Circular Objects
    :PROPERTIES:
    :CUSTOM_ID: read-syntax-for-circular-objects
    :END:

To represent shared or circular structures within a complex of Lisp objects, you can use the reader constructs '#n=' and '#n#'.

Use =#=n=== before an object to label it for later reference; subsequently, you can use =#=n=#= to refer the same object in another place. Here, n is some integer. For example, here is how to make a list in which the first element recurs as the third element:

#+BEGIN_EXAMPLE
         (#1=(a) b #1#)
#+END_EXAMPLE

This differs from ordinary syntax such as this

#+BEGIN_EXAMPLE
         ((a) b (a))
#+END_EXAMPLE

which would result in a list whose first and third elements look alike but are not the same Lisp object. This shows the difference:

#+BEGIN_EXAMPLE
         (prog1 nil
           (setq x '(#1=(a) b #1#)))
         (eq (nth 0 x) (nth 2 x))
              ⇒ t
         (setq x '((a) b (a)))
         (eq (nth 0 x) (nth 2 x))
              ⇒ nil
#+END_EXAMPLE

You can also use the same syntax to make a circular structure, which appears as an element within itself. Here is an example:

#+BEGIN_EXAMPLE
         #1=(a #1#)
#+END_EXAMPLE

This makes a list whose second element is the list itself. Here's how you can see that it really works:

#+BEGIN_EXAMPLE
         (prog1 nil
           (setq x '#1=(a #1#)))
         (eq x (cadr x))
              ⇒ t
#+END_EXAMPLE

The Lisp printer can produce this syntax to record circular and shared structure in a Lisp object, if you bind the variable =print-circle= to a non-=nil= value. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Output-Variables][Output Variables]].

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Equality-Predicates][Equality Predicates]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Circular-Objects][Circular Objects]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lisp-Data-Types][Lisp Data Types]]

** 2.6 Type Predicates

The Emacs Lisp interpreter itself does not perform type checking on the actual arguments passed to functions when they are called. It could not do so, since function arguments in Lisp do not have declared data types, as they do in other programming languages. It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use.

All built-in functions do check the types of their actual arguments when appropriate, and signal a =wrong-type-argument= error if an argument is of the wrong type. For example, here is what happens if you pass an argument to =+= that it cannot handle:

#+BEGIN_EXAMPLE
         (+ 2 'a)
              error--> Wrong type argument: number-or-marker-p, a
#+END_EXAMPLE

If you want your program to handle different types differently, you must do explicit type checking. The most common way to check the type of an object is to call a type predicate function. Emacs has a type predicate for each type, as well as some predicates for combinations of types.

A type predicate function takes one argument; it returns =t= if the argument belongs to the appropriate type, and =nil= otherwise. Following a general Lisp convention for predicate functions, most type predicates' names end with 'p'.

Here is an example which uses the predicates =listp= to check for a list and =symbolp= to check for a symbol.

#+BEGIN_EXAMPLE
         (defun add-on (x)
           (cond ((symbolp x)
                  ;; If X is a symbol, put it on LIST.
                  (setq list (cons x list)))
                 ((listp x)
                  ;; If X is a list, add its elements to LIST.
                  (setq list (append x list)))
                 (t
                  ;; We handle only symbols and lists.
                  (error "Invalid argument %s in add-on" x))))
#+END_EXAMPLE

Here is a table of predefined type predicates, in alphabetical order, with references to further information.

- =atom=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][atom]].

- =arrayp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Array-Functions][arrayp]].

- =bool-vector-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Bool_002dVectors][bool-vector-p]].

- =booleanp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#nil-and-t][booleanp]].

- =bufferp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Basics][bufferp]].

- =byte-code-function-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Byte_002dCode-Type][byte-code-function-p]].

- =case-table-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Case-Tables][case-table-p]].

- =char-or-string-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-for-Strings][char-or-string-p]].

- =char-table-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Char_002dTables][char-table-p]].

- =commandp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Interactive-Call][commandp]].

- =condition-variable-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Condition-Variables][condition-variable-p]].

- =consp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][consp]].

- =custom-variable-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Variable-Definitions][custom-variable-p]].

- =floatp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Numbers][floatp]].

- =fontp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Low_002dLevel-Font][Low-Level Font]].

- =frame-configuration-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configurations][frame-configuration-p]].

- =frame-live-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Frames][frame-live-p]].

- =framep=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frames][framep]].

- =functionp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Functions][functionp]].

- =hash-table-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Other-Hash][hash-table-p]].

- =integer-or-marker-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Markers][integer-or-marker-p]].

- =integerp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Numbers][integerp]].

- =keymapp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Keymaps][keymapp]].

- =keywordp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Constant-Variables][Constant Variables]].

- =listp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][listp]].

- =markerp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Markers][markerp]].

- =mutexp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mutexes][mutexp]].

- =nlistp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][nlistp]].

- =number-or-marker-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Markers][number-or-marker-p]].

- =numberp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Numbers][numberp]].

- =overlayp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlays][overlayp]].

- =processp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Processes][processp]].

- =recordp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Record-Type][recordp]].

- =sequencep=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequence-Functions][sequencep]].

- =string-or-null-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-for-Strings][string-or-null-p]].

- =stringp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-for-Strings][stringp]].

- =subrp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Function-Cells][subrp]].

- =symbolp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Symbols][symbolp]].

- =syntax-table-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Tables][syntax-table-p]].

- =threadp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Thread-Functions][threadp]].

- =vectorp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vectors][vectorp]].

- =wholenump=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Numbers][wholenump]].

- =window-configuration-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][window-configuration-p]].

- =window-live-p=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][window-live-p]].

- =windowp=
  See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Windows][windowp]].

The most general way to check the type of an object is to call the function =type-of=. Recall that each object belongs to one and only one primitive type; =type-of= tells you which one (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lisp-Data-Types][Lisp Data Types]]). But =type-of= knows nothing about non-primitive types. In most cases, it is more convenient to use type predicates than =type-of=.

--- Function: *type-of*

  This function returns a symbol naming the primitive type of object. The value is one of the symbols =bool-vector=, =buffer=, =char-table=, =compiled-function=, =condition-variable=, =cons=, =finalizer=, =float=, =font-entity=, =font-object=, =font-spec=, =frame=, =hash-table=, =integer=, =marker=, =mutex=, =overlay=, =process=, =string=, =subr=, =symbol=, =thread=, =vector=, =window=, or =window-configuration=. However, if object is a record, the type specified by its first slot is returned; [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Records][Records]].

  #+BEGIN_EXAMPLE
                (type-of 1)
                     ⇒ integer
                (type-of 'nil)
                     ⇒ symbol
                (type-of '())    ; () is nil.
                     ⇒ symbol
                (type-of '(x))
                     ⇒ cons
                (type-of (record 'foo))
                     ⇒ foo
  #+END_EXAMPLE


Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Type-Predicates][Type Predicates]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lisp-Data-Types][Lisp Data Types]]

** 2.7 Equality Predicates
    :PROPERTIES:
    :CUSTOM_ID: equality-predicates
    :END:

Here we describe functions that test for equality between two objects. Other functions test equality of contents between objects of specific types, e.g., strings. For these predicates, see the appropriate chapter describing the data type.

--- Function: *eq*

#+BEGIN_QUOTE
  This function returns =t= if object1 and object2 are the same object, and =nil= otherwise.

  If object1 and object2 are integers with the same value, they are considered to be the same object (i.e., =eq= returns =t=). If object1 and object2 are symbols with the same name, they are normally the same object---but see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Symbols][Creating Symbols]] for exceptions. For other types (e.g., lists, vectors, strings), two arguments with the same contents or elements are not necessarily =eq= to each other: they are =eq= only if they are the same object, meaning that a change in the contents of one will be reflected by the same change in the contents of the other.

  #+BEGIN_EXAMPLE
                (eq 'foo 'foo)
                     ⇒ t

                (eq 456 456)
                     ⇒ t

                (eq "asdf" "asdf")
                     ⇒ nil

                (eq "" "")
                     ⇒ t
                ;; This exception occurs because Emacs Lisp
                ;; makes just one multibyte empty string, to save space.

                (eq '(1 (2 (3))) '(1 (2 (3))))
                     ⇒ nil

                (setq foo '(1 (2 (3))))
                     ⇒ (1 (2 (3)))
                (eq foo foo)
                     ⇒ t
                (eq foo '(1 (2 (3))))
                     ⇒ nil

                (eq [(1 2) 3] [(1 2) 3])
                     ⇒ nil

                (eq (point-marker) (point-marker))
                     ⇒ nil
  #+END_EXAMPLE

  The =make-symbol= function returns an uninterned symbol, distinct from the symbol that is used if you write the name in a Lisp expression. Distinct symbols with the same name are not =eq=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Symbols][Creating Symbols]].

  #+BEGIN_EXAMPLE
                (eq (make-symbol "foo") 'foo)
                     ⇒ nil
  #+END_EXAMPLE

  The Emacs Lisp byte compiler may collapse identical literal objects, such as literal strings, into references to the same object, with the effect that the byte-compiled code will compare such objects as =eq=, while the interpreted version of the same code will not. Therefore, your code should never rely on objects with the same literal contents being either =eq= or not =eq=, it should instead use functions that compare object contents such as =equal=, described below. Similarly, your code should not modify literal objects (e.g., put text properties on literal strings), since doing that might affect other literal objects of the same contents, if the byte compiler collapses them.
#+END_QUOTE

--- Function: *equal*

#+BEGIN_QUOTE
  This function returns =t= if object1 and object2 have equal components, and =nil= otherwise. Whereas =eq= tests if its arguments are the same object, =equal= looks inside nonidentical arguments to see if their elements or contents are the same. So, if two objects are =eq=, they are =equal=, but the converse is not always true.

  #+BEGIN_EXAMPLE
                (equal 'foo 'foo)
                     ⇒ t

                (equal 456 456)
                     ⇒ t

                (equal "asdf" "asdf")
                     ⇒ t
                (eq "asdf" "asdf")
                     ⇒ nil

                (equal '(1 (2 (3))) '(1 (2 (3))))
                     ⇒ t
                (eq '(1 (2 (3))) '(1 (2 (3))))
                     ⇒ nil

                (equal [(1 2) 3] [(1 2) 3])
                     ⇒ t
                (eq [(1 2) 3] [(1 2) 3])
                     ⇒ nil

                (equal (point-marker) (point-marker))
                     ⇒ t

                (eq (point-marker) (point-marker))
                     ⇒ nil
  #+END_EXAMPLE

  Comparison of strings is case-sensitive, but does not take account of text properties---it compares only the characters in the strings. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]. Use =equal-including-properties= to also compare text properties. For technical reasons, a unibyte string and a multibyte string are =equal= if and only if they contain the same sequence of character codes and all these codes are in the range 0 through 127 (ASCII).

  #+BEGIN_EXAMPLE
                (equal "asdf" "ASDF")
                     ⇒ nil
  #+END_EXAMPLE

  However, two distinct buffers are never considered =equal=, even if their textual contents are the same.
#+END_QUOTE

The test for equality is implemented recursively; for example, given two cons cells x and y, =(equal=x y=)= returns =t= if and only if both the expressions below return =t=:

#+BEGIN_EXAMPLE
         (equal (car x) (car y))
         (equal (cdr x) (cdr y))
#+END_EXAMPLE

Because of this recursive method, circular lists may therefore cause infinite recursion (leading to an error).

--- Function: *equal-including-properties*

#+BEGIN_QUOTE
  This function behaves like =equal= in all cases but also requires that for two strings to be equal, they have the same text properties.

  #+BEGIN_EXAMPLE
                (equal "asdf" (propertize "asdf" 'asdf t))
                     ⇒ t
                (equal-including-properties "asdf"
                                            (propertize "asdf" 'asdf t))
                     ⇒ nil
  #+END_EXAMPLE
#+END_QUOTE

Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Strings-and-Characters][Strings and Characters]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lisp-Data-Types][Lisp Data Types]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Top][Top]]
* 3 Numbers
   :PROPERTIES:
   :CUSTOM_ID: numbers
   :END:

GNU Emacs supports two numeric data types: integers and floating-point numbers. Integers are whole numbers such as −3, 0, 7, 13, and 511. Floating-point numbers are numbers with fractional parts, such as −4.5, 0.0, and 2.71828. They can also be expressed in exponential notation: '1.5e2' is the same as '150.0'; here, 'e2' stands for ten to the second power, and that is multiplied by 1.5. Integer computations are exact, though they may overflow. Floating-point computations often involve rounding errors, as the numbers have a fixed amount of precision.


** 3.1 Integer Basics
    :PROPERTIES:
    :CUSTOM_ID: integer-basics
    :END:

The range of values for an integer depends on the machine. The minimum range is −536,870,912 to 536,870,911 (30 bits; i.e., −2*29 to 2*29 − 1), but many machines provide a wider range. Many examples in this chapter assume the minimum integer width of 30 bits. The Lisp reader reads an integer as a sequence of digits with optional initial sign and optional final period. An integer that is out of the Emacs range is treated as a floating-point number.

#+BEGIN_EXAMPLE
          1               ; The integer 1.
          1.              ; The integer 1.
         +1               ; Also the integer 1.
         -1               ; The integer −1.
          9000000000000000000
                          ; The floating-point number 9e18.
          0               ; The integer 0.
         -0               ; The integer 0.
#+END_EXAMPLE

The syntax for integers in bases other than 10 uses '#' followed by a letter that specifies the radix: 'b' for binary, 'o' for octal, 'x' for hex, or 'radixr' to specify radix radix. Case is not significant for the letter that specifies the radix. Thus, '#binteger' reads integer in binary, and '#radixrinteger' reads integer in radix radix. Allowed values of radix run from 2 to 36. For example:

#+BEGIN_EXAMPLE
         #b101100 ⇒ 44
         #o54 ⇒ 44
         #x2c ⇒ 44
         #24r1k ⇒ 44
#+END_EXAMPLE

To understand how various functions work on integers, especially the bitwise operators (see [[file:///home/gaowei/Desktop/elisp-manual.html#Bitwise-Operations][Bitwise Operations]]), it is often helpful to view the numbers in their binary form.

In 30-bit binary, the decimal integer 5 looks like this:

#+BEGIN_EXAMPLE
         0000...000101 (30 bits total)
#+END_EXAMPLE

(The '...' stands for enough bits to fill out a 30-bit word; in this case, '...' stands for twenty 0 bits. Later examples also use the '...' notation to make binary integers easier to read.)

The integer −1 looks like this:

#+BEGIN_EXAMPLE
         1111...111111 (30 bits total)
#+END_EXAMPLE

−1 is represented as 30 ones. (This is called two's complement notation.)

Subtracting 4 from −1 returns the negative integer −5. In binary, the decimal integer 4 is 100. Consequently, −5 looks like this:

#+BEGIN_EXAMPLE
         1111...111011 (30 bits total)
#+END_EXAMPLE

In this implementation, the largest 30-bit binary integer is 536,870,911 in decimal. In binary, it looks like this:

#+BEGIN_EXAMPLE
         0111...111111 (30 bits total)
#+END_EXAMPLE

Since the arithmetic functions do not check whether integers go outside their range, when you add 1 to 536,870,911, the value is the negative integer −536,870,912:

#+BEGIN_EXAMPLE
         (+ 1 536870911)
              ⇒ -536870912
              ⇒ 1000...000000 (30 bits total)
#+END_EXAMPLE

Many of the functions described in this chapter accept markers for arguments in place of numbers. (See [[file:///home/gaowei/Desktop/elisp-manual.html#Markers][Markers]].) Since the actual arguments to such functions may be either numbers or markers, we often give these arguments the name number-or-marker. When the argument value is a marker, its position value is used and its buffer is ignored.

--- Variable: *most-positive-fixnum*

#+BEGIN_QUOTE
  The value of this variable is the largest integer that Emacs Lisp can handle. Typical values are 2*29 − 1 on 32-bit and 2*61 − 1 on 64-bit platforms.
#+END_QUOTE

--- Variable: *most-negative-fixnum*

#+BEGIN_QUOTE
  The value of this variable is the smallest integer that Emacs Lisp can handle. It is negative. Typical values are −2*29 on 32-bit and −2*61 on 64-bit platforms.
#+END_QUOTE

In Emacs Lisp, text characters are represented by integers. Any integer between zero and the value of =(max-char)=, inclusive, is considered to be valid as a character. See [[file:///home/gaowei/Desktop/elisp-manual.html#Character-Codes][Character Codes]].

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Predicates-on-Numbers][Predicates on Numbers]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Integer-Basics][Integer Basics]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.2 Floating-Point Basics
    :PROPERTIES:
    :CUSTOM_ID: floating-point-basics
    :END:

Floating-point numbers are useful for representing numbers that are not integral. The range of floating-point numbers is the same as the range of the C data type =double= on the machine you are using. On all computers currently supported by Emacs, this is double-precision IEEE floating point.

The read syntax for floating-point numbers requires either a decimal point, an exponent, or both. Optional signs ('+' or '-') precede the number and its exponent. For example, '1500.0', '+15e2', '15.0e+2', '+1500000e-3', and '.15e4' are five ways of writing a floating-point number whose value is 1500. They are all equivalent. Like Common Lisp, Emacs Lisp requires at least one digit after any decimal point in a floating-point number; '1500.' is an integer, not a floating-point number.

Emacs Lisp treats =-0.0= as numerically equal to ordinary zero with respect to =equal= and ===. This follows the IEEE floating-point standard, which says =-0.0= and =0.0= are numerically equal even though other operations can distinguish them.

The IEEE floating-point standard supports positive infinity and negative infinity as floating-point values. It also provides for a class of values called NaN, or "not a number"; numerical functions return such values in cases where there is no correct answer. For example, =(/ 0.0 0.0)= returns a NaN. Although NaN values carry a sign, for practical purposes there is no other significant difference between different NaN values in Emacs Lisp.

Here are read syntaxes for these special floating-point values:

- infinity

  '1.0e+INF' and '-1.0e+INF'

- not-a-number

  '0.0e+NaN' and '-0.0e+NaN'

The following functions are specialized for handling floating-point numbers:

--- Function: *isnan* x

#+BEGIN_QUOTE
  This predicate returns =t= if its floating-point argument is a NaN, =nil= otherwise.
#+END_QUOTE

--- Function: *frexp* x

#+BEGIN_QUOTE
  This function returns a cons cell =(=s=.=e=)=, where s and e are respectively the significand and exponent of the floating-point number x.

  If x is finite, then s is a floating-point number between 0.5 (inclusive) and 1.0 (exclusive), e is an integer, and x = s * 2**e. If x is zero or infinity, then s is the same as x. If x is a NaN, then s is also a NaN. If x is zero, then e is 0.
#+END_QUOTE

--- Function: *ldexp* s e

#+BEGIN_QUOTE
  Given a numeric significand s and an integer exponent e, this function returns the floating point number s * 2**e.
#+END_QUOTE

--- Function: *copysign* x1 x2

#+BEGIN_QUOTE
  This function copies the sign of x2 to the value of x1, and returns the result. x1 and x2 must be floating point.
#+END_QUOTE

--- Function: *logb* x

#+BEGIN_QUOTE
  This function returns the binary exponent of x. More precisely, the value is the logarithm base 2 of |x|, rounded down to an integer.

  #+BEGIN_EXAMPLE
                (logb 10)
                     ⇒ 3
                (logb 10.0e20)
                     ⇒ 69
  #+END_EXAMPLE
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Comparison-of-Numbers][Comparison of Numbers]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Float-Basics][Float Basics]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.3 Type Predicates for Numbers
    :PROPERTIES:
    :CUSTOM_ID: type-predicates-for-numbers
    :END:

The functions in this section test for numbers, or for a specific type of number. The functions =integerp= and =floatp= can take any type of Lisp object as argument (they would not be of much use otherwise), but the =zerop= predicate requires a number as its argument. See also =integer-or-marker-p= and =number-or-marker-p=, in [[file:///home/gaowei/Desktop/elisp-manual.html#Predicates-on-Markers][Predicates on Markers]].

--- Function: *floatp* object

#+BEGIN_QUOTE
  This predicate tests whether its argument is floating point and returns =t= if so, =nil= otherwise.
#+END_QUOTE

--- Function: *integerp* object

#+BEGIN_QUOTE
  This predicate tests whether its argument is an integer, and returns =t= if so, =nil= otherwise.
#+END_QUOTE

--- Function: *numberp* object

#+BEGIN_QUOTE
  This predicate tests whether its argument is a number (either integer or floating point), and returns =t= if so, =nil= otherwise.
#+END_QUOTE

--- Function: *natnump* object

#+BEGIN_QUOTE
  This predicate (whose name comes from the phrase "natural number") tests to see whether its argument is a nonnegative integer, and returns =t= if so, =nil= otherwise. 0 is considered non-negative.

  =wholenump= is a synonym for =natnump=.
#+END_QUOTE

--- Function: *zerop* number

#+BEGIN_QUOTE
  This predicate tests whether its argument is zero, and returns =t= if so, =nil= otherwise. The argument must be a number.

  =(zerop x)= is equivalent to =(= x 0)=.
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Numeric-Conversions][Numeric Conversions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Predicates-on-Numbers][Predicates on Numbers]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.4 Comparison of Numbers
    :PROPERTIES:
    :CUSTOM_ID: comparison-of-numbers
    :END:

To test numbers for numerical equality, you should normally use ===, not =eq=. There can be many distinct floating-point objects with the same numeric value. If you use =eq= to compare them, then you test whether two values are the same /object/. By contrast, === compares only the numeric values of the objects.

In Emacs Lisp, each integer is a unique Lisp object. Therefore, =eq= is equivalent to === where integers are concerned. It is sometimes convenient to use =eq= for comparing an unknown value with an integer, because =eq= does not report an error if the unknown value is not a number---it accepts arguments of any type. By contrast, === signals an error if the arguments are not numbers or markers. However, it is better programming practice to use === if you can, even for comparing integers.

Sometimes it is useful to compare numbers with =equal=, which treats two numbers as equal if they have the same data type (both integers, or both floating point) and the same value. By contrast, === can treat an integer and a floating-point number as equal. See [[file:///home/gaowei/Desktop/elisp-manual.html#Equality-Predicates][Equality Predicates]].

There is another wrinkle: because floating-point arithmetic is not exact, it is often a bad idea to check for equality of floating-point values. Usually it is better to test for approximate equality. Here's a function to do this:

#+BEGIN_EXAMPLE
         (defvar fuzz-factor 1.0e-6)
         (defun approx-equal (x y)
           (or (= x y)
               (< (/ (abs (- x y))
                     (max (abs x) (abs y)))
                  fuzz-factor)))
#+END_EXAMPLE

#+BEGIN_QUOTE
  *Common Lisp note:* Comparing numbers in Common Lisp always requires === because Common Lisp implements multi-word integers, and two distinct integer objects can have the same numeric value. Emacs Lisp can have just one integer object for any given value because it has a limited range of integers.
#+END_QUOTE

--- Function: *=* number-or-marker &rest number-or-markers

#+BEGIN_QUOTE
  This function tests whether all its arguments are numerically equal, and returns =t= if so, =nil= otherwise.
#+END_QUOTE

--- Function: *eql* value1 value2

#+BEGIN_QUOTE
  This function acts like =eq= except when both arguments are numbers. It compares numbers by type and numeric value, so that =(eql 1.0 1)= returns =nil=, but =(eql 1.0 1.0)= and =(eql 1 1)= both return =t=.
#+END_QUOTE

--- Function: */=* number-or-marker1 number-or-marker2

#+BEGIN_QUOTE
  This function tests whether its arguments are numerically equal, and returns =t= if they are not, and =nil= if they are.
#+END_QUOTE

--- Function: *<* number-or-marker &rest number-or-markers

#+BEGIN_QUOTE
  This function tests whether each argument is strictly less than the following argument. It returns =t= if so, =nil= otherwise.
#+END_QUOTE

--- Function: *<=* number-or-marker &rest number-or-markers

#+BEGIN_QUOTE
  This function tests whether each argument is less than or equal to the following argument. It returns =t= if so, =nil= otherwise.
#+END_QUOTE

--- Function: *>* number-or-marker &rest number-or-markers

#+BEGIN_QUOTE
  This function tests whether each argument is strictly greater than the following argument. It returns =t= if so, =nil= otherwise.
#+END_QUOTE

--- Function: *>=* number-or-marker &rest number-or-markers

#+BEGIN_QUOTE
  This function tests whether each argument is greater than or equal to the following argument. It returns =t= if so, =nil= otherwise.
#+END_QUOTE

--- Function: *max* number-or-marker &rest numbers-or-markers

#+BEGIN_QUOTE
  This function returns the largest of its arguments.

  #+BEGIN_EXAMPLE
                (max 20)
                     ⇒ 20
                (max 1 2.5)
                     ⇒ 2.5
                (max 1 3 2.5)
                     ⇒ 3
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *min* number-or-marker &rest numbers-or-markers

#+BEGIN_QUOTE
  This function returns the smallest of its arguments.

  #+BEGIN_EXAMPLE
                (min -4 1)
                     ⇒ -4
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *abs* number

#+BEGIN_QUOTE
  This function returns the absolute value of number.
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Arithmetic-Operations][Arithmetic Operations]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Comparison-of-Numbers][Comparison of Numbers]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.5 Numeric Conversions
    :PROPERTIES:
    :CUSTOM_ID: numeric-conversions
    :END:

To convert an integer to floating point, use the function =float=.

--- Function: *float* number

#+BEGIN_QUOTE
  This returns number converted to floating point. If number is already floating point, =float= returns it unchanged.
#+END_QUOTE

There are four functions to convert floating-point numbers to integers; they differ in how they round. All accept an argument number and an optional argument divisor. Both arguments may be integers or floating-point numbers. divisor may also be =nil=. If divisor is =nil= or omitted, these functions convert number to an integer, or return it unchanged if it already is an integer. If divisor is non-=nil=, they divide number by divisor and convert the result to an integer. If divisor is zero (whether integer or floating point), Emacs signals an =arith-error= error.

--- Function: *truncate* number &optional divisor

#+BEGIN_QUOTE
  This returns number, converted to an integer by rounding towards zero.

  #+BEGIN_EXAMPLE
                (truncate 1.2)
                     ⇒ 1
                (truncate 1.7)
                     ⇒ 1
                (truncate -1.2)
                     ⇒ -1
                (truncate -1.7)
                     ⇒ -1
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *floor* number &optional divisor

#+BEGIN_QUOTE
  This returns number, converted to an integer by rounding downward (towards negative infinity).

  If divisor is specified, this uses the kind of division operation that corresponds to =mod=, rounding downward.

  #+BEGIN_EXAMPLE
                (floor 1.2)
                     ⇒ 1
                (floor 1.7)
                     ⇒ 1
                (floor -1.2)
                     ⇒ -2
                (floor -1.7)
                     ⇒ -2
                (floor 5.99 3)
                     ⇒ 1
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *ceiling* number &optional divisor

#+BEGIN_QUOTE
  This returns number, converted to an integer by rounding upward (towards positive infinity).

  #+BEGIN_EXAMPLE
                (ceiling 1.2)
                     ⇒ 2
                (ceiling 1.7)
                     ⇒ 2
                (ceiling -1.2)
                     ⇒ -1
                (ceiling -1.7)
                     ⇒ -1
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *round* number &optional divisor

#+BEGIN_QUOTE
  This returns number, converted to an integer by rounding towards the nearest integer. Rounding a value equidistant between two integers returns the even integer.

  #+BEGIN_EXAMPLE
                (round 1.2)
                     ⇒ 1
                (round 1.7)
                     ⇒ 2
                (round -1.2)
                     ⇒ -1
                (round -1.7)
                     ⇒ -2
  #+END_EXAMPLE
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Rounding-Operations][Rounding Operations]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Numeric-Conversions][Numeric Conversions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.6 Arithmetic Operations
    :PROPERTIES:
    :CUSTOM_ID: arithmetic-operations
    :END:

Emacs Lisp provides the traditional four arithmetic operations (addition, subtraction, multiplication, and division), as well as remainder and modulus functions, and functions to add or subtract 1. Except for =%=, each of these functions accepts both integer and floating-point arguments, and returns a floating-point number if any argument is floating point.

Emacs Lisp arithmetic functions do not check for integer overflow. Thus =(1+ 536870911)= may evaluate to −536870912, depending on your hardware.

--- Function: *1+* number-or-marker

#+BEGIN_QUOTE
  This function returns number-or-marker plus 1. For example,

  #+BEGIN_EXAMPLE
                (setq foo 4)
                     ⇒ 4
                (1+ foo)
                     ⇒ 5
  #+END_EXAMPLE

  This function is not analogous to the C operator =++=---it does not increment a variable. It just computes a sum. Thus, if we continue,

  #+BEGIN_EXAMPLE
                foo
                     ⇒ 4
  #+END_EXAMPLE

  If you want to increment the variable, you must use =setq=, like this:

  #+BEGIN_EXAMPLE
                (setq foo (1+ foo))
                     ⇒ 5
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *1-* number-or-marker

#+BEGIN_QUOTE
  This function returns number-or-marker minus 1.
#+END_QUOTE

--- Function: *+* &rest numbers-or-markers

#+BEGIN_QUOTE
  This function adds its arguments together. When given no arguments, =+= returns 0.

  #+BEGIN_EXAMPLE
                (+)
                     ⇒ 0
                (+ 1)
                     ⇒ 1
                (+ 1 2 3 4)
                     ⇒ 10
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *-* &optional number-or-marker &rest more-numbers-or-markers

#+BEGIN_QUOTE
  The =-= function serves two purposes: negation and subtraction. When =-= has a single argument, the value is the negative of the argument. When there are multiple arguments, =-= subtracts each of the more-numbers-or-markers from number-or-marker, cumulatively. If there are no arguments, the result is 0.

  #+BEGIN_EXAMPLE
                (- 10 1 2 3 4)
                     ⇒ 0
                (- 10)
                     ⇒ -10
                (-)
                     ⇒ 0
  #+END_EXAMPLE
#+END_QUOTE

--- Function: ***** &rest numbers-or-markers

#+BEGIN_QUOTE
  This function multiplies its arguments together, and returns the product. When given no arguments, =*= returns 1.

  #+BEGIN_EXAMPLE
                (*)
                     ⇒ 1
                (* 1)
                     ⇒ 1
                (* 1 2 3 4)
                     ⇒ 24
  #+END_EXAMPLE
#+END_QUOTE

--- Function: */* number &rest divisors

#+BEGIN_QUOTE
  With one or more divisors, this function divides number by each divisor in divisors in turn, and returns the quotient. With no divisors, this function returns 1/number, i.e., the multiplicative inverse of number. Each argument may be a number or a marker.

  If all the arguments are integers, the result is an integer, obtained by rounding the quotient towards zero after each division.

  #+BEGIN_EXAMPLE
                (/ 6 2)
                     ⇒ 3
                (/ 5 2)
                     ⇒ 2
                (/ 5.0 2)
                     ⇒ 2.5
                (/ 5 2.0)
                     ⇒ 2.5
                (/ 5.0 2.0)
                     ⇒ 2.5
                (/ 4.0)
                     ⇒ 0.25
                (/ 4)
                     ⇒ 0
                (/ 25 3 2)
                     ⇒ 4
                (/ -17 6)
                     ⇒ -2
  #+END_EXAMPLE

  If you divide an integer by the integer 0, Emacs signals an =arith-error= error (see [[file:///home/gaowei/Desktop/elisp-manual.html#Errors][Errors]]). Floating-point division of a nonzero number by zero yields either positive or negative infinity (see [[file:///home/gaowei/Desktop/elisp-manual.html#Float-Basics][Float Basics]]).
#+END_QUOTE

--- Function: *%* dividend divisor

#+BEGIN_QUOTE
  This function returns the integer remainder after division of dividend by divisor. The arguments must be integers or markers.

  For any two integers dividend and divisor,

  #+BEGIN_EXAMPLE
                (+ (% dividend divisor)
                   (* (/ dividend divisor) divisor))
  #+END_EXAMPLE

  always equals dividend if divisor is nonzero.

  #+BEGIN_EXAMPLE
                (% 9 4)
                     ⇒ 1
                (% -9 4)
                     ⇒ -1
                (% 9 -4)
                     ⇒ 1
                (% -9 -4)
                     ⇒ -1
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *mod* dividend divisor

#+BEGIN_QUOTE
  This function returns the value of dividend modulo divisor; in other words, the remainder after division of dividend by divisor, but with the same sign as divisor. The arguments must be numbers or markers.

  Unlike =%=, =mod= permits floating-point arguments; it rounds the quotient downward (towards minus infinity) to an integer, and uses that quotient to compute the remainder.

  If divisor is zero, =mod= signals an =arith-error= error if both arguments are integers, and returns a NaN otherwise.

  #+BEGIN_EXAMPLE
                (mod 9 4)
                     ⇒ 1
                (mod -9 4)
                     ⇒ 3
                (mod 9 -4)
                     ⇒ -3
                (mod -9 -4)
                     ⇒ -1
                (mod 5.5 2.5)
                     ⇒ .5
  #+END_EXAMPLE

  For any two numbers dividend and divisor,

  #+BEGIN_EXAMPLE
                (+ (mod dividend divisor)
                   (* (floor dividend divisor) divisor))
  #+END_EXAMPLE

  always equals dividend, subject to rounding error if either argument is floating point and to an =arith-error= if dividend is an integer and divisor is 0. For =floor=, see [[file:///home/gaowei/Desktop/elisp-manual.html#Numeric-Conversions][Numeric Conversions]].
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Bitwise-Operations][Bitwise Operations]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Arithmetic-Operations][Arithmetic Operations]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.7 Rounding Operations
    :PROPERTIES:
    :CUSTOM_ID: rounding-operations
    :END:

The functions =ffloor=, =fceiling=, =fround=, and =ftruncate= take a floating-point argument and return a floating-point result whose value is a nearby integer. =ffloor= returns the nearest integer below; =fceiling=, the nearest integer above; =ftruncate=, the nearest integer in the direction towards zero; =fround=, the nearest integer.

--- Function: *ffloor* float

#+BEGIN_QUOTE
  This function rounds float to the next lower integral value, and returns that value as a floating-point number.
#+END_QUOTE

--- Function: *fceiling* float

#+BEGIN_QUOTE
  This function rounds float to the next higher integral value, and returns that value as a floating-point number.
#+END_QUOTE

--- Function: *ftruncate* float

#+BEGIN_QUOTE
  This function rounds float towards zero to an integral value, and returns that value as a floating-point number.
#+END_QUOTE

--- Function: *fround* float

#+BEGIN_QUOTE
  This function rounds float to the nearest integral value, and returns that value as a floating-point number. Rounding a value equidistant between two integers returns the even integer.
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Math-Functions][Math Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Rounding-Operations][Rounding Operations]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.8 Bitwise Operations on Integers
    :PROPERTIES:
    :CUSTOM_ID: bitwise-operations-on-integers
    :END:

In a computer, an integer is represented as a binary number, a sequence of bits (digits which are either zero or one). A bitwise operation acts on the individual bits of such a sequence. For example, shifting moves the whole sequence left or right one or more places, reproducing the same pattern moved over.

The bitwise operations in Emacs Lisp apply only to integers.

--- Function: *lsh* integer1 count

#+BEGIN_QUOTE
  =lsh=, which is an abbreviation for logical shift, shifts the bits in integer1 to the left count places, or to the right if count is negative, bringing zeros into the vacated bits. If count is negative, =lsh= shifts zeros into the leftmost (most-significant) bit, producing a positive result even if integer1 is negative. Contrast this with =ash=, below.

  Here are two examples of =lsh=, shifting a pattern of bits one place to the left. We show only the low-order eight bits of the binary pattern; the rest are all zero.

  #+BEGIN_EXAMPLE
                (lsh 5 1)
                     ⇒ 10
                ;; Decimal 5 becomes decimal 10.
                00000101 ⇒ 00001010

                (lsh 7 1)
                     ⇒ 14
                ;; Decimal 7 becomes decimal 14.
                00000111 ⇒ 00001110
  #+END_EXAMPLE

  As the examples illustrate, shifting the pattern of bits one place to the left produces a number that is twice the value of the previous number.

  Shifting a pattern of bits two places to the left produces results like this (with 8-bit binary numbers):

  #+BEGIN_EXAMPLE
                (lsh 3 2)
                     ⇒ 12
                ;; Decimal 3 becomes decimal 12.
                00000011 ⇒ 00001100
  #+END_EXAMPLE

  On the other hand, shifting one place to the right looks like this:

  #+BEGIN_EXAMPLE
                (lsh 6 -1)
                     ⇒ 3
                ;; Decimal 6 becomes decimal 3.
                00000110 ⇒ 00000011

                (lsh 5 -1)
                     ⇒ 2
                ;; Decimal 5 becomes decimal 2.
                00000101 ⇒ 00000010
  #+END_EXAMPLE

  As the example illustrates, shifting one place to the right divides the value of a positive integer by two, rounding downward.

  The function =lsh=, like all Emacs Lisp arithmetic functions, does not check for overflow, so shifting left can discard significant bits and change the sign of the number. For example, left shifting 536,870,911 produces −2 in the 30-bit implementation:

  #+BEGIN_EXAMPLE
                (lsh 536870911 1)          ; left shift
                     ⇒ -2
  #+END_EXAMPLE

  In binary, the argument looks like this:

  #+BEGIN_EXAMPLE
                ;; Decimal 536,870,911
                0111...111111 (30 bits total)
  #+END_EXAMPLE

  which becomes the following when left shifted:

  #+BEGIN_EXAMPLE
                ;; Decimal −2
                1111...111110 (30 bits total)
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *ash* integer1 count

#+BEGIN_QUOTE
  =ash= (arithmetic shift) shifts the bits in integer1 to the left count places, or to the right if count is negative.

  =ash= gives the same results as =lsh= except when integer1 and count are both negative. In that case, =ash= puts ones in the empty bit positions on the left, while =lsh= puts zeros in those bit positions.

  Thus, with =ash=, shifting the pattern of bits one place to the right looks like this:

  #+BEGIN_EXAMPLE
                (ash -6 -1) ⇒ -3
                ;; Decimal −6 becomes decimal −3.
                1111...111010 (30 bits total)
                     ⇒
                1111...111101 (30 bits total)
  #+END_EXAMPLE

  In contrast, shifting the pattern of bits one place to the right with =lsh= looks like this:

  #+BEGIN_EXAMPLE
                (lsh -6 -1) ⇒ 536870909
                ;; Decimal −6 becomes decimal 536,870,909.
                1111...111010 (30 bits total)
                     ⇒
                0111...111101 (30 bits total)
  #+END_EXAMPLE

  Here are other examples:

  #+BEGIN_EXAMPLE
                                   ;         30-bit binary values

                (lsh 5 2)          ;   5  =  0000...000101
                     ⇒ 20         ;      =  0000...010100
                (ash 5 2)
                     ⇒ 20
                (lsh -5 2)         ;  -5  =  1111...111011
                     ⇒ -20        ;      =  1111...101100
                (ash -5 2)
                     ⇒ -20
                (lsh 5 -2)         ;   5  =  0000...000101
                     ⇒ 1          ;      =  0000...000001
                (ash 5 -2)
                     ⇒ 1
                (lsh -5 -2)        ;  -5  =  1111...111011
                     ⇒ 268435454
                                   ;      =  0011...111110
                (ash -5 -2)        ;  -5  =  1111...111011
                     ⇒ -2         ;      =  1111...111110
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *logand* &rest ints-or-markers

#+BEGIN_QUOTE
  This function returns the bitwise AND of the arguments: the nth bit is 1 in the result if, and only if, the nth bit is 1 in all the arguments.

  For example, using 4-bit binary numbers, the bitwise AND of 13 and 12 is 12: 1101 combined with 1100 produces 1100. In both the binary numbers, the leftmost two bits are both 1 so the leftmost two bits of the returned value are both 1. However, for the rightmost two bits, each is 0 in at least one of the arguments, so the rightmost two bits of the returned value are both 0.

  Therefore,

  #+BEGIN_EXAMPLE
                (logand 13 12)
                     ⇒ 12
  #+END_EXAMPLE

  If =logand= is not passed any argument, it returns a value of −1. This number is an identity element for =logand= because its binary representation consists entirely of ones. If =logand= is passed just one argument, it returns that argument.

  #+BEGIN_EXAMPLE
                                   ;        30-bit binary values

                (logand 14 13)     ; 14  =  0000...001110
                                   ; 13  =  0000...001101
                     ⇒ 12         ; 12  =  0000...001100

                (logand 14 13 4)   ; 14  =  0000...001110
                                   ; 13  =  0000...001101
                                   ;  4  =  0000...000100
                     ⇒ 4          ;  4  =  0000...000100

                (logand)
                     ⇒ -1         ; -1  =  1111...111111
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *logior* &rest ints-or-markers

#+BEGIN_QUOTE
  This function returns the bitwise inclusive OR of its arguments: the nth bit is 1 in the result if, and only if, the nth bit is 1 in at least one of the arguments. If there are no arguments, the result is 0, which is an identity element for this operation. If =logior= is passed just one argument, it returns that argument.

  #+BEGIN_EXAMPLE
                                   ;        30-bit binary values

                (logior 12 5)      ; 12  =  0000...001100
                                   ;  5  =  0000...000101
                     ⇒ 13         ; 13  =  0000...001101

                (logior 12 5 7)    ; 12  =  0000...001100
                                   ;  5  =  0000...000101
                                   ;  7  =  0000...000111
                     ⇒ 15         ; 15  =  0000...001111
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *logxor* &rest ints-or-markers

#+BEGIN_QUOTE
  This function returns the bitwise exclusive OR of its arguments: the nth bit is 1 in the result if, and only if, the nth bit is 1 in an odd number of the arguments. If there are no arguments, the result is 0, which is an identity element for this operation. If =logxor= is passed just one argument, it returns that argument.

  #+BEGIN_EXAMPLE
                                   ;        30-bit binary values

                (logxor 12 5)      ; 12  =  0000...001100
                                   ;  5  =  0000...000101
                     ⇒ 9          ;  9  =  0000...001001

                (logxor 12 5 7)    ; 12  =  0000...001100
                                   ;  5  =  0000...000101
                                   ;  7  =  0000...000111
                     ⇒ 14         ; 14  =  0000...001110
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *lognot* integer

#+BEGIN_QUOTE
  This function returns the bitwise complement of its argument: the nth bit is one in the result if, and only if, the nth bit is zero in integer, and vice-versa.

  #+BEGIN_EXAMPLE
                (lognot 5)
                     ⇒ -6
                ;;  5  =  0000...000101 (30 bits total)
                ;; becomes
                ;; -6  =  1111...111010 (30 bits total)
  #+END_EXAMPLE
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Random-Numbers][Random Numbers]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Bitwise-Operations][Bitwise Operations]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.9 Standard Mathematical Functions
    :PROPERTIES:
    :CUSTOM_ID: standard-mathematical-functions
    :END:

These mathematical functions allow integers as well as floating-point numbers as arguments.

--- Function: *sin* arg --- Function: *cos* arg --- Function: *tan* arg

#+BEGIN_QUOTE
  These are the basic trigonometric functions, with argument arg measured in radians.
#+END_QUOTE

--- Function: *asin* arg

#+BEGIN_QUOTE
  The value of =(asin=arg=)= is a number between −pi/2 and pi/2 (inclusive) whose sine is arg. If arg is out of range (outside [−1, 1]), =asin= returns a NaN.
#+END_QUOTE

--- Function: *acos* arg

#+BEGIN_QUOTE
  The value of =(acos=arg=)= is a number between 0 and pi (inclusive) whose cosine is arg. If arg is out of range (outside [−1, 1]), =acos= returns a NaN.
#+END_QUOTE

--- Function: *atan* y &optional x

#+BEGIN_QUOTE
  The value of =(atan=y=)= is a number between −pi/2 and pi/2 (exclusive) whose tangent is y. If the optional second argument x is given, the value of =(atan y x)= is the angle in radians between the vector =[=x=,=y=]= and the =X= axis.
#+END_QUOTE

--- Function: *exp* arg

#+BEGIN_QUOTE
  This is the exponential function; it returns e to the power arg.
#+END_QUOTE

--- Function: *log* arg &optional base

#+BEGIN_QUOTE
  This function returns the logarithm of arg, with base base. If you don't specify base, the natural base e is used. If arg or base is negative, =log= returns a NaN.
#+END_QUOTE

--- Function: *expt* x y

#+BEGIN_QUOTE
  This function returns x raised to power y. If both arguments are integers and y is positive, the result is an integer; in this case, overflow causes truncation, so watch out. If x is a finite negative number and y is a finite non-integer, =expt= returns a NaN.
#+END_QUOTE

--- Function: *sqrt* arg

#+BEGIN_QUOTE
  This returns the square root of arg. If arg is finite and less than zero, =sqrt= returns a NaN.
#+END_QUOTE

In addition, Emacs defines the following common mathematical constants:

--- Variable: *float-e*

#+BEGIN_QUOTE
  The mathematical constant e (2.71828...).
#+END_QUOTE

--- Variable: *float-pi*

#+BEGIN_QUOTE
  The mathematical constant pi (3.14159...).
#+END_QUOTE

Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Math-Functions][Math Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Numbers][Numbers]]

** 3.10 Random Numbers
    :PROPERTIES:
    :CUSTOM_ID: random-numbers
    :END:

A deterministic computer program cannot generate true random numbers. For most purposes, pseudo-random numbers suffice. A series of pseudo-random numbers is generated in a deterministic fashion. The numbers are not truly random, but they have certain properties that mimic a random series. For example, all possible values occur equally often in a pseudo-random series.

Pseudo-random numbers are generated from a seed value. Starting from any given seed, the =random= function always generates the same sequence of numbers. By default, Emacs initializes the random seed at startup, in such a way that the sequence of values of =random= (with overwhelming likelihood) differs in each Emacs run.

Sometimes you want the random number sequence to be repeatable. For example, when debugging a program whose behavior depends on the random number sequence, it is helpful to get the same behavior in each program run. To make the sequence repeat, execute =(random "")=. This sets the seed to a constant value for your particular Emacs executable (though it may differ for other Emacs builds). You can use other strings to choose various seed values.

--- Function: *random* &optional limit

#+BEGIN_QUOTE
  This function returns a pseudo-random integer. Repeated calls return a series of pseudo-random integers.

  If limit is a positive integer, the value is chosen to be nonnegative and less than limit. Otherwise, the value might be any integer representable in Lisp, i.e., an integer between =most-negative-fixnum= and =most-positive-fixnum= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Integer-Basics][Integer Basics]]).

  If limit is =t=, it means to choose a new seed as if Emacs were restarting, typically from the system entropy. On systems lacking entropy pools, choose the seed from less-random volatile data such as the current time.

  If limit is a string, it means to choose a new seed based on the string's contents.
#+END_QUOTE
* 4 Strings and Characters
A string in Emacs Lisp is an array that contains an ordered sequence of characters. Strings are used as names of symbols, buffers, and files; to send messages to users; to hold text being copied between buffers; and for many other purposes. Because strings are so important, Emacs Lisp has many functions expressly for manipulating them. Emacs Lisp programs use strings more often than individual characters.

See Strings of Events, for special considerations for strings of keyboard character events.

1) Basics: Basic properties of strings and characters.
   #+BEGIN_SRC elisp

          (make-string 5 ?x)
               ⇒ "xxxxx"
          (make-string 0 ?x)
               ⇒ ""
          (string ?a ?b ?c)
          ⇒ "abc"
          (substring "abcdefg" 0 3)
               ⇒ "abc"
          (substring "abcdefg" -3 -1)
               ⇒ "ef"
          (substring "abcdefg" -3 nil)
               ⇒ "efg"
          (substring "abcdefg" 0)
               ⇒ "abcdefg"
          (substring [a b (c) "d"] 1 3)
               ⇒ [b (c)]
          (concat "abc" "-def")
               ⇒ "abc-def"
          (concat "abc" (list 120 121) [122])
               ⇒ "abcxyz"
          ;; nil is an empty sequence.
          (concat "abc" nil "-def")
               ⇒ "abc-def"
          (concat "The " "quick brown " "fox.")
               ⇒ "The quick brown fox."
          (concat)
               ⇒ ""
   #+END_SRC
2) Predicates for Strings: Testing whether an object is a string or char.
3) Creating Strings: Functions to allocate new strings.
4) Modifying Strings: Altering the contents of an existing string.
5) Text Comparison: Comparing characters or strings.
6) String Conversion: Converting to and from characters and strings.
7) Formatting Strings: format: Emacs's analogue of printf.
8) Case Conversion: Case conversion functions.
9) Case Tables: Customizing case conversion.

* 5.Lists
A list represents a sequence of zero or more elements (which may be any Lisp objects). The important difference between lists and vectors is that two or more lists can share part of their structure; in addition, you can insert or delete elements in a list without copying the whole list.

** 5.1. Cons Cells: How lists are made out of cons cells.
** 5.2. List-related Predicates: Is this object a list? Comparing two lists.

The ollowing predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object nil. (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)
— Function: consp object

    This function returns t if object is a cons cell, nil otherwise. nil is not a cons cell, although it is a list.

— Function: atom object

    This function returns t if object is an atom, nil otherwise. All objects except cons cells are atoms. The symbol nil is an atom and is also a list; it is the only Lisp object that is both.

:              (atom object) == (not (consp object))

— Function: listp object

    This function returns t if object is a cons cell or nil. Otherwise, it returns nil.

:              (listp '(1))
                   ⇒ t
:              (listp '())
                   ⇒ t

— Function: nlistp object

    This function is the opposite of listp: it returns t if object is not a list. Otherwise, it returns nil.

:              (listp object) == (not (nlistp object))

— Function: null object

This function returns t if object is nil, and returns nil otherwise. This function is identical to not, but as a matter of clarity we use null when object is considered a list and not when it is considered a truth value (see not in Combining Conditions).

:              (null '(1))
                   ⇒ nil
:              (null '())
                   ⇒ t

** 5.3. List Elements: Extracting the pieces of a list.
4. Building Lists: Creating list structure.
5. List Variables: Modifying lists stored in variables.
6. Modifying Lists: Storing new pieces into an existing list.
7. Sets And Lists: A list can represent a finite mathematical set.
8. Association Lists: A list can represent a finite relation or mapping.
   #+BEGIN_SRC elisp
     ((pine . cones)
      (oak . acorns)
      (maple . seeds))
   #+END_SRC
9. Property Lists: A list of paired elements.

** 5.6 Modifying Existing List Structure

You can modify the car and cdr contents of a cons cell with the primitives setcar and setcdr. These are destructive operations because they change existing list structure.

    Common Lisp note: Common Lisp uses functions rplaca and rplacd to alter list structure; they change structure the same way as setcar and setcdr, but the Common Lisp functions return the cons cell while setcar and setcdr return the new car or cdr.

    Setcar: Replacing an element in a list.
    Setcdr: Replacing part of the list backbone. This can be used to remove or add elements.
    Rearrangement: Reordering the elements in a list; combining lists. 
*** 5.6.1 Altering List Elements with setcar


Changing the car of a cons cell is done with setcar. When used on a list, setcar replaces one element of a list with a different element.
— Function: setcar cons object

    This function stores object as the new car of cons, replacing its previous car. In other words, it changes the car slot of cons to refer to object. It returns the value object. For example:

              (setq x '(1 2))
                   ⇒ (1 2)
              (setcar x 4)
                   ⇒ 4
              x
                   ⇒ (4 2)

When a cons cell is part of the shared structure of several lists, storing a new car into the cons changes one element of each of these lists. Here is an example:

     ;; Create two lists that are partly shared.
     (setq x1 '(a b c))
          ⇒ (a b c)
     (setq x2 (cons 'z (cdr x1)))
          ⇒ (z b c)

     ;; Replace the car of a shared link.
     (setcar (cdr x1) 'foo)
          ⇒ foo
     x1                           ; Both lists are changed.
          ⇒ (a foo c)
     x2
          ⇒ (z foo c)

     ;; Replace the car of a link that is not shared.
     (setcar x1 'baz)
          ⇒ baz
     x1                           ; Only one list is changed.
          ⇒ (baz foo c)
     x2
          ⇒ (z foo c)

Here is a graphical depiction of the shared structure of the two lists in the variables x1 and x2, showing why replacing b changes them both:

             --- ---        --- ---      --- ---
     x1---> |   |   |----> |   |   |--> |   |   |--> nil
             --- ---        --- ---      --- ---
              |        -->   |            |
              |       |      |            |
               --> a  |       --> b        --> c
                      |
            --- ---   |
     x2--> |   |   |--
            --- ---
             |
             |
              --> z

Here is an alternative form of box diagram, showing the same relationship:

     x1:
      --------------       --------------       --------------
     | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
     |   a   |   o------->|   b   |   o------->|   c   |  nil |
     |       |      |  -->|       |      |     |       |      |
      --------------  |    --------------       --------------
                      |
     x2:              |
      --------------  |
     | car   | cdr  | |
     |   z   |   o----
     |       |      |
      --------------

*** 5.6.2 Altering the CDR of a List

The lowest-level primitive for modifying a cdr is setcdr:
— Function: setcdr cons object

    This function stores object as the new cdr of cons, replacing its previous cdr. In other words, it changes the cdr slot of cons to refer to object. It returns the value object.

Here is an example of replacing the cdr of a list with a different list. All but the first element of the list are removed in favor of a different sequence of elements. The first element is unchanged, because it resides in the car of the list, and is not reached via the cdr.

     (setq x '(1 2 3))
          ⇒ (1 2 3)
     (setcdr x '(4))
          ⇒ (4)
     x
          ⇒ (1 4)

You can delete elements from the middle of a list by altering the cdrs of the cons cells in the list. For example, here we delete the second element, b, from the list (a b c), by changing the cdr of the first cons cell:

     (setq x1 '(a b c))
          ⇒ (a b c)
     (setcdr x1 (cdr (cdr x1)))
          ⇒ (c)
     x1
          ⇒ (a c)

Here is the result in box notation:

                        --------------------
                       |                    |
      --------------   |   --------------   |    --------------
     | car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
     |   a   |   o-----   |   b   |   o-------->|   c   |  nil |
     |       |      |     |       |      |      |       |      |
      --------------       --------------        --------------

The second cons cell, which previously held the element b, still exists and its car is still b, but it no longer forms part of this list.

It is equally easy to insert a new element by changing cdrs:

     (setq x1 '(a b c))
          ⇒ (a b c)
     (setcdr x1 (cons 'd (cdr x1)))
          ⇒ (d b c)
     x1
          ⇒ (a d b c)

Here is this result in box notation:

      --------------        -------------       -------------
     | car  | cdr   |      | car  | cdr  |     | car  | cdr  |
     |   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
     |      |   |   |  |   |      |      |     |      |      |
      --------- | --   |    -------------       -------------
                |      |
          -----         --------
         |                      |
         |    ---------------   |
         |   | car   | cdr   |  |
          -->|   d   |   o------
             |       |       |
              ---------------

*** 5.6.3 Functions that Rearrange Lists

Here are some functions that rearrange lists destructively by modifying the cdrs of their component cons cells. These functions are destructive because they chew up the original lists passed to them as arguments, relinking their cons cells to form a new list that is the returned value.

See delq, in Sets And Lists, for another function that modifies cons cells.
— Function: nconc &rest lists

    This function returns a list containing all the elements of lists. Unlike append (see Building Lists), the lists are not copied. Instead, the last cdr of each of the lists is changed to refer to the following list. The last of the lists is not altered. For example:

              (setq x '(1 2 3))
                   ⇒ (1 2 3)
              (nconc x '(4 5))
                   ⇒ (1 2 3 4 5)
              x
                   ⇒ (1 2 3 4 5)

    Since the last argument of nconc is not itself modified, it is reasonable to use a constant list, such as '(4 5), as in the above example. For the same reason, the last argument need not be a list:

              (setq x '(1 2 3))
                   ⇒ (1 2 3)
              (nconc x 'z)
                   ⇒ (1 2 3 . z)
              x
                   ⇒ (1 2 3 . z)

    However, the other arguments (all but the last) must be lists.

    A common pitfall is to use a quoted constant list as a non-last argument to nconc. If you do this, your program will change each time you run it! Here is what happens:

              (defun add-foo (x)            ; We want this function to add
                (nconc '(foo) x))           ;   foo to the front of its arg.

              (symbol-function 'add-foo)
                   ⇒ (lambda (x) (nconc (quote (foo)) x))

              (setq xx (add-foo '(1 2)))    ; It seems to work.
                   ⇒ (foo 1 2)
              (setq xy (add-foo '(3 4)))    ; What happened?
                   ⇒ (foo 1 2 3 4)
              (eq xx xy)
                   ⇒ t

              (symbol-function 'add-foo)
                   ⇒ (lambda (x) (nconc (quote (foo 1 2 3 4) x)))



* 6 Sequences, Arrays, and Vectors
The sequence type is the union of two other Lisp types: lists and arrays. In other words, any list is a sequence, and any array is a sequence. The common property that all sequences have is that each is an ordered collection of elements.

An array is a fixed-length object with a slot for each of its elements. All the elements are accessible in constant time. The four types of arrays are strings, vectors, char-tables and bool-vectors.

A list is a sequence of elements, but it is not a single primitive object; it is made of cons cells, one cell per element. Finding the nth element requires looking through n cons cells, so elements farther from the beginning of the list take longer to access. But it is possible to add elements to the list, or remove elements.

The following diagram shows the relationship between these types:

         _____________________________________________
              |                                             |
              |          Sequence                           |
              |  ______   ________________________________  |
              | |      | |                                | |
              | | List | |             Array              | |
              | |      | |    ________       ________     | |
              | |______| |   |        |     |        |    | |
              |          |   | Vector |     | String |    | |
              |          |   |________|     |________|    | |
              |          |  ____________   _____________  | |
              |          | |            | |             | | |
              |          | | Char-table | | Bool-vector | | |
              |          | |____________| |_____________| | |
              |          |________________________________| |
              |_____________________________________________|

1. Sequence Functions: Functions that accept any kind of sequence.
2. Arrays: Characteristics of arrays in Emacs Lisp.
3. Array Functions: Functions specifically for arrays.
4. Vectors: Special characteristics of Emacs Lisp vectors.
5. Vector Functions: Functions specifically for vectors.
6. Char-Tables: How to work with char-tables.
7. Bool-Vectors: How to work with bool-vectors.
8. Rings: Managing a fixed-size ring of objects.

* 7 Records
The purpose of records is to allow programmers to create objects with new types that are not built into Emacs. They are used as the underlying representation of cl-defstruct and defclass instances.

Internally, a record object is much like a vector; its slots can be accessed using aref and it can be copied using copy-sequence. However, the first slot is used to hold its type as returned by type-of. Also, in the current implementation records can have at most 4096 slots, whereas vectors can be much larger. Like arrays, records use zero-origin indexing: the first slot has index 0.

The type slot should be a symbol or a type descriptor. If it's a type descriptor, the symbol naming its type will be returned; Type Descriptors. Any other kind of object is returned as-is.

The printed representation of records is ‘#s’ followed by a list specifying the contents. The first list element must be the record type. The following elements are the record slots.

To avoid conflicts with other type names, Lisp programs that define new types of records should normally use the naming conventions of the package where these record types are introduced for the names of the types. Note that the names of the types which could possibly conflict might not be known at the time the package defining a record type is loaded; they could be loaded at some future point in time.

A record is considered a constant for evaluation: the result of evaluating it is the same record. This does not evaluate or even examine the slots. See Self-Evaluating Forms.

Record Functions: Functions for records.
Backward Compatibility: Compatibility for cl-defstruct.

* 8 Hash Tables
A hash table is a very fast kind of lookup table, somewhat like an alist (see Association Lists) in that it maps keys to corresponding values. It differs from an alist in these ways:

1) Lookup in a hash table is extremely fast for large tables—in fact, the time required is essentially independent of how many elements are stored in the table. For smaller tables (a few tens of elements) alists may still be faster because hash tables have a more-or-less constant overhead.
2) The correspondences in a hash table are in no particular order.
3) There is no way to share structure between two hash tables, the way two alists can share a common tail.
Emacs Lisp provides a general-purpose hash table data type, along with a series of functions for operating on them. Hash tables have a special printed representation, which consists of ‘#s’ followed by a list specifying the hash table properties and contents. See Creating Hash. (Hash notation, the initial ‘#’ character used in the printed representations of objects with no read representation, has nothing to do with hash tables. See Printed Representation.)

Obarrays are also a kind of hash table, but they are a different type of object and are used only for recording interned symbols (see Creating Symbols).

1. Creating Hash: Functions to create hash tables.
2. Hash Access: Reading and writing the hash table contents.
3. Defining Hash: Defining new comparison methods.
4. Other Hash: Miscellaneous.

* 9 Symbols
A symbol is an object with a unique name. This chapter describes symbols, their components, their property lists, and how they are created and interned. Separate chapters describe the use of symbols as variables and as function names; see Variables, and Functions. For the precise read syntax for symbols, see Symbol Type.

You can test whether an arbitrary Lisp object is a symbol with symbolp:

— Function: symbolp object
This function returns t if object is a symbol, nil otherwise.

Symbol Components: Symbols have names, values, function definitions and property lists.
Definitions: A definition says how a symbol will be used.
Creating Symbols: How symbols are kept unique.
Symbol Properties: Each symbol has a property list for recording miscellaneous information.

* 10 Evaluation
The evaluation of expressions in Emacs Lisp is performed by the Lisp interpreter—a program that receives a Lisp object as input and computes its value as an expression. How it does this depends on the data type of the object, according to rules described in this chapter. The interpreter runs automatically to evaluate portions of your program, but can also be called explicitly via the Lisp primitive function eval.

Intro Eval: Evaluation in the scheme of things.
Forms: How various sorts of objects are evaluated.
Quoting: Avoiding evaluation (to put constants in the program).
Backquote: Easier construction of list structure.
Eval: How to invoke the Lisp interpreter explicitly.

** 10.1 Introduction to Evaluation

The Lisp interpreter, or evaluator, is the part of Emacs that computes the value of an expression that is given to it. When a function written in Lisp is called, the evaluator computes the value of the function by evaluating the expressions in the function body. Thus, running any Lisp program really means running the Lisp interpreter.
# evluate it and return value 
A Lisp object that is intended for evaluation is called a form or expression1.
The fact that forms are data objects and not merely text is one of the
fundamental differences between Lisp-like languages and typical programming
languages. Any object can be evaluated,
but in practice only numbers, symbols, lists and strings are evaluated very often.

In subsequent sections, we will describe the details of what evaluation means for each kind of form.

It is very common to read a Lisp form and then evaluate the form, but reading and evaluation are separate activities, and either can be performed alone. Reading per se does not evaluate anything; it converts the printed representation of a Lisp object to the object itself. It is up to the caller of read to specify whether this object is a form to be evaluated, or serves some entirely different purpose. See Input Functions.

Evaluation is a recursive process, and evaluating a form often involves evaluating parts within that form. For instance, when you evaluate a function call form such as (car x), Emacs first evaluates the argument (the subform x). After evaluating the argument, Emacs executes the function (car), and if the function is written in Lisp, execution works by evaluating the body of the function (in this example, however, car is not a Lisp function; it is a primitive function implemented in C). See Functions, for more information about functions and function calls.
# 先读取arguments, 顺序, 此处为关键.

Evaluation takes place in a context called the environment, which consists of the current values and bindings of all Lisp variables (see Variables).2 Whenever a form refers to a variable without creating a new binding for it, the variable evaluates to the value given by the current environment. Evaluating a form may also temporarily alter the environment by binding variables (see Local Variables).

Evaluating a form may also make changes that persist; these changes are called side effects. An example of a form that produces a side effect is (setq foo 1).

Do not confuse evaluation with command key interpretation. The editor command loop translates keyboard input into a command (an interactively callable function) using the active keymaps, and then uses call-interactively to execute that command. Executing the command usually involves evaluation, if the command is written in Lisp; however, this step is not considered a part of command key interpretation. See Command Loop.

** 10.2 Kinds of Forms

A Lisp object that is intended to be evaluated is called a form (or an expression). How Emacs evaluates a form depends on its data type. Emacs has three different kinds of form that are evaluated differently: symbols, lists, and all other types. This section describes all three kinds, one by one, starting with the other types, which are self-evaluating forms.

*** 10.2.1 Self-Evaluating Forms

A self-evaluating form is any form that is not a list or symbol. Self-evaluating forms evaluate to themselves: the result of evaluation is the same object that was evaluated. Thus, the number 25 evaluates to 25, and the string "foo" evaluates to the string "foo". Likewise, evaluating a vector does not cause evaluation of the elements of the vector—it returns the same vector with its contents unchanged.

#+begin_src emacs-lisp :session sicp :lexical t
     '123               ; A number, shown without evaluation.
          ⇒ 123
     123                ; Evaluated as usual---result is the same.
          ⇒ 123
     (eval '123)        ; Evaluated "by hand"---result is the same.
          ⇒ 123
     (eval (eval '123)) ; Evaluating twice changes nothing.
          ⇒ 123
#+end_src

It is common to write numbers, characters, strings, and even vectors in Lisp code, taking advantage of the fact that they self-evaluate. However, it is quite unusual to do this for types that lack a read syntax, because there's no way to write them textually. It is possible to construct Lisp expressions containing these types by means of a Lisp program. Here is an example:
# 四种是self-evaluate
#+begin_src emacs-lisp :session sicp :lexical t
     ;; Build an expression containing a buffer object.
     (setq print-exp (list 'print (current-buffer)))
          ⇒ (print #<buffer eval.texi>)
     ;; Evaluate it.
     (eval print-exp)
          -| #<buffer eval.texi>
          ⇒ #<buffer eval.texi>
#+end_src

*** 10.2.2 Symbol Forms

When a symbol is evaluated, it is treated as a variable. The result is the variable's value, if it has one. If the symbol has no value as a variable, the Lisp interpreter signals an error. For more information on the use of variables, see Variables.

In the following example, we set the value of a symbol with setq. Then we evaluate the symbol, and get back the value that setq stored.
# 此处记住了, symbol是variable

:      (setq a 123)
:           ⇒ 123
:      (eval 'a)
:           ⇒ 123
:      a
:           ⇒ 123

The symbols nil and t are treated specially, so that the value of nil is always nil, and the value of t is always t; you cannot set or bind them to any other values. Thus, these two symbols act like self-evaluating forms, even though eval treats them like any other symbol. A symbol whose name starts with ‘:’ also self-evaluates in the same way; likewise, its value ordinarily cannot be changed. See Constant Variables.

*** 10.2.3 Classification of List Forms

A form that is a nonempty list is either a function call, a macro call, or a special form, according to its first element. These three kinds of forms are evaluated in different ways, described below. The remaining list elements constitute the arguments for the function, macro, or special form.

The first step in evaluating a nonempty list is to examine its first element. This element alone determines what kind of form the list is and how the rest of the list is to be processed. The first element is not evaluated, as it would be in some Lisp dialects such as Scheme.
# examine但是不evaluate, 我感觉elisp的模式比较好呢.

*** 10.2.4 Symbol Function Indirection

If the first element of the list is a symbol then evaluation examines the symbol's function cell, and uses its contents instead of the original symbol. If the contents are another symbol, this process, called symbol function indirection, is repeated until it obtains a non-symbol. See Function Names, for more information about symbol function indirection.

One possible consequence of this process is an infinite loop, in the event that a symbol's function cell refers to the same symbol. Otherwise, we eventually obtain a non-symbol, which ought to be a function or other suitable object.

More precisely, we should now have a Lisp function (a lambda expression), a byte-code function, a primitive function, a Lisp macro, a special form, or an autoload object. Each of these types is a case described in one of the following sections. If the object is not one of these types, Emacs signals an invalid-function error.

The following example illustrates the symbol indirection process. We use fset to set the function cell of a symbol and symbol-function to get the function cell contents (see Function Cells). Specifically, we store the symbol car into the function cell of first, and the symbol first into the function cell of erste.

     ;; Build this function cell linkage:
     ;;   -------------       -----        -------        -------
     ;;  | #<subr car> | <-- | car |  <-- | first |  <-- | erste |
     ;;   -------------       -----        -------        -------
     (symbol-function 'car)
          ⇒ #<subr car>
     (fset 'first 'car)
          ⇒ car
     (fset 'erste 'first)
          ⇒ first
     (erste '(1 2 3))   ; Call the function referenced by erste.
          ⇒ 1

By contrast, the following example calls a function without any symbol function indirection, because the first element is an anonymous Lisp function, not a symbol.

     ((lambda (arg) (erste arg))
      '(1 2 3))
          ⇒ 1

Executing the function itself evaluates its body; this does involve symbol function indirection when calling erste.

This form is rarely used and is now deprecated. Instead, you should write it as:

     (funcall (lambda (arg) (erste arg))
              '(1 2 3))

or just

     (let ((arg '(1 2 3))) (erste arg))

The built-in function indirect-function provides an easy way to perform symbol function indirection explicitly.
— Function: indirect-function function &optional noerror

    This function returns the meaning of function as a function. If function is a symbol, then it finds function's function definition and starts over with that value. If function is not a symbol, then it returns function itself.

    This function returns nil if the final symbol is unbound. It signals a cyclic-function-indirection error if there is a loop in the chain of symbols.

    The optional argument noerror is obsolete, kept for backward compatibility, and has no effect.

    Here is how you could define indirect-function in Lisp:

              (defun indirect-function (function)
                (if (symbolp function)
                    (indirect-function (symbol-function function))
                  function))

* 11 Control Structures
** Pre

A Lisp program consists of a set of expressions, or forms (see Forms). We control the order of execution of these forms by enclosing them in control structures. Control structures are special forms which control when, whether, or how many times to execute the forms they contain.

The simplest order of execution is sequential execution: first form a, then form b, and so on. This is what happens when you write several forms in succession in the body of a function, or at top level in a file of Lisp code—the forms are executed in the order written. We call this textual order. For example, if a function body consists of two forms a and b, evaluation of the function evaluates first a and then b. The result of evaluating b becomes the value of the function.

Explicit control structures make possible an order of execution other than sequential.

Emacs Lisp provides several kinds of control structure, including other varieties of sequencing, conditionals, iteration, and (controlled) jumps—all discussed below. The built-in control structures are special forms since their subforms are not necessarily evaluated or not evaluated sequentially. You can use macros to define your own control structure constructs (see Macros).

** 1. Sequencing: Evaluation in textual order.

Evaluating forms in the order they appear is the most common way control passes from one form to another. In some contexts, such as in a function body, this happens automatically. Elsewhere you must use a control structure construct to do this: progn, the simplest control construct of Lisp.

A progn special form looks like this:

:    (progn a b c ...)

and it says to execute the forms a, b, c, and so on, in that order. These forms are called the body of the progn form. The value of the last form in the body becomes the value of the entire progn. (progn) returns nil.

In the early days of Lisp, progn was the only way to execute two or more forms in succession and use the value of the last of them. But programmers found they often needed to use a progn in the body of a function, where (at that time) only one form was allowed. So the body of a function was made into an implicit progn: several forms are allowed just as in the body of an actual progn. Many other control structures likewise contain an implicit progn. As a result, progn is not used as much as it was many years ago. It is needed now most often inside an unwind-protect, and, or, or in the then-part of an if.

— Special Form: progn forms...

    This special form evaluates all of the forms, in textual order, returning the result of the final form. 

   #+BEGIN_SRC elisp
          (progn (print "The first form")
                 (print "The second form")
                 (print "The third form"))
   #+END_SRC

   #+RESULTS:
   : The third form

Two other constructs likewise evaluate a series of forms but return different values:
— Special Form: prog1 form1 forms...

    This special form evaluates form1 and all of the forms, in textual order, returning the result of form1.

#+BEGIN_SRC elisp
          (prog1 (print "The first form")
                 (print "The second form")
                 (print "The third form"))
#+END_SRC
Here is a way to remove the first element from a list in the variable x, then return the value of that former element:

: (prog1 (car x) (setq x (cdr x)))

— Special Form: prog2 form1 form2 forms...

    This special form evaluates form1, form2, and all of the following forms, in textual order, returning the result of form2.

              (prog2 (print "The first form")
                     (print "The second form")
                     (print "The third form"))
                   -| "The first form"
                   -| "The second form"
                   -| "The third form"
              ⇒ "The second form"



#+RESULTS:
: The first form

** 2. Conditionals: if, cond, when, unless.
#+BEGIN_COMMENT
原来cond是conditional(条件句)
但condition是名词也可为动词, 因此选择condition
: Condition:(conditional
:        if(这一段)predicate,(condition, expression)
:        consequences
又回头查看了python tutorial, 上来就是if statement, 确非好教材.
曾经试图将statement翻译成"命令", 动词化.
#+END_COMMENT


Conditional control structures choose among alternatives. Emacs Lisp has five conditional forms: if, which is much the same as in other languages; when and unless, which are variants of if; cond, which is a generalized case statement; and pcase, which is a generalization of cond (see Pattern-Matching Conditional).

— Special Form: if condition then-form else-forms...

    if chooses between the then-form and the else-forms based on the value of condition. If the evaluated condition is non-nil, then-form is evaluated and the result returned. Otherwise, the else-forms are evaluated in textual order, and the value of the last one is returned. (The else part of if is an example of an implicit progn. See Sequencing.)

    If condition has the value nil, and no else-forms are given, if returns nil.

    if is a special form because the branch that is not selected is never evaluated—it is ignored. Thus, in this example, true is not printed because print is never called:

              (if nil
                  (print 'true)
                'very-false)
              ⇒ very-false

— Macro: when condition then-forms...

    This is a variant of if where there are no else-forms, and possibly several then-forms. In particular,

              (when condition a b c)

    is entirely equivalent to

              (if condition (progn a b c) nil)

— Macro: unless condition forms...

    This is a variant of if where there is no then-form:

              (unless condition a b c)

    is entirely equivalent to

              (if condition nil
                 a b c)

— Special Form: cond clause...

    cond chooses among an arbitrary number of alternatives. Each clause in the cond must be a list. The car of this list is the condition; the remaining elements, if any, the body-forms. Thus, a clause looks like this:

              (condition body-forms...)

    cond tries the clauses in textual order, by evaluating the condition of each clause. If the value of condition is non-nil, the clause succeeds; then cond evaluates its body-forms, and returns the value of the last of body-forms. Any remaining clauses are ignored.

    If the value of condition is nil, the clause fails, so the cond moves on to the following clause, trying its condition.

    A clause may also look like this:

              (condition)

    Then, if condition is non-nil when tested, the cond form returns the value of condition.

    If every condition evaluates to nil, so that every clause fails, cond returns nil.

    The following example has four clauses, which test for the cases where the value of x is a number, string, buffer and symbol, respectively:

              (cond ((numberp x) x)
                    ((stringp x) x)
                    ((bufferp x)
                     (setq temporary-hack x) ; multiple body-forms
                     (buffer-name x))        ; in one clause
                    ((symbolp x) (symbol-value x)))

    Often we want to execute the last clause whenever none of the previous clauses was successful. To do this, we use t as the condition of the last clause, like this: (t body-forms). The form t evaluates to t, which is never nil, so this clause never fails, provided the cond gets to it at all. For example:

              (setq a 5)
              (cond ((eq a 'hack) 'foo)
                    (t "default"))
              ⇒ "default"

    This cond expression returns foo if the value of a is hack, and returns the string "default" otherwise.

Any conditional construct can be expressed with cond or with if. Therefore, the choice between them is a matter of style. For example:

     (if a b c)
     ==
     (cond (a b) (t c))

** 3. Combining Conditions: and, or, not.
4. Pattern-Matching Conditional: How to use pcase and friends.
5. Iteration: while loops.
6. Generators: Generic sequences and coroutines.
   #+BEGIN_SRC elisp
     (require 'generator)
     (iter-defun my-iter (x)
       (iter-yield (1+ (iter-yield (1+ x))))
        ;; Return normally
       -1)

     (let* ((iter (my-iter 5))
            (iter2 (my-iter 0)))
       ;; Prints 6
       (print (iter-next iter))
       ;; Prints 9
       (print (iter-next iter 8))
       ;; Prints 1; iter and iter2 have distinct states
       (print (iter-next iter2 nil))

       ;; We expect the iter sequence to end now
       (condition-case x
           (iter-next iter)
         (iter-end-of-sequence
           ;; Prints -1, which my-iter returned normally
           (print (cdr x)))))
   #+END_SRC
# 所以iteration, 可以是一个函数．
7. Nonlocal Exits: Jumping out of a sequence.

* 12 Variables

A variable is a name used in a program to stand for a value. In Lisp, each variable is represented by a Lisp symbol (see Symbols). The variable name is simply the symbol's name, and the variable's value is stored in the symbol's value cell1. See Symbol Components. In Emacs Lisp, the use of a symbol as a variable is independent of its use as a function name.

As previously noted in this manual, a Lisp program is represented primarily by Lisp objects, and only secondarily as text. The textual form of a Lisp program is given by the read syntax of the Lisp objects that constitute the program. Hence, the textual form of a variable in a Lisp program is written using the read syntax for the symbol representing the variable.

    1) Global Variables: Variable values that exist permanently, everywhere.
    2) Constant Variables: Variables that never change.
    3) Local Variables: Variable values that exist only temporarily.
    4) Void Variables: Symbols that lack values.
    5) Defining Variables: A definition says a symbol is used as a variable.
    6) Tips for Defining: Things you should think about when you define a variable.
    7) Accessing Variables: Examining values of variables whose names are known only at run time.
    8) Setting Variables: Storing new values in variables.
    9) Watching Variables: Running a function when a variable is changed.
    10) Variable Scoping: How Lisp chooses among local and global values.
    11) Buffer-Local Variables: Variable values in effect only in one buffer.
    12) File Local Variables: Handling local variable lists in files.
    13) Directory Local Variables: Local variables common to all files in a directory.
    14) Connection Local Variables: Local variables common for remote connections.
    15) Variable Aliases: Variables that are aliases for other variables.
    16) Variables with Restricted Values: Non-constant variables whose value can not be an arbitrary Lisp object.
    17) Generalized Variables: Extending the concept of variables.

** 12.3 Local Variables

Global variables have values that last until explicitly superseded with new values. Sometimes it is useful to give a variable a local value—a value that takes effect only within a certain part of a Lisp program. When a variable has a local value, we say that it is locally bound to that value, and that it is a local variable.

For example, when a function is called, its argument variables receive local values, which are the actual arguments supplied to the function call; these local bindings take effect within the body of the function. To take another example, the let special form explicitly establishes local bindings for specific variables, which take effect only within the body of the let form.

We also speak of the global binding, which is where (conceptually) the global value is kept.

Establishing a local binding saves away the variable's previous value (or lack of one). We say that the previous value is shadowed. Both global and local values may be shadowed. If a local binding is in effect, using setq on the local variable stores the specified value in the local binding. When that local binding is no longer in effect, the previously shadowed value (or lack of one) comes back.

A variable can have more than one local binding at a time (e.g., if there are nested let forms that bind the variable). The current binding is the local binding that is actually in effect. It determines the value returned by evaluating the variable symbol, and it is the binding acted on by setq.

For most purposes, you can think of the current binding as the innermost local binding, or the global binding if there is no local binding. To be more precise, a rule called the scoping rule determines where in a program a local binding takes effect. The default scoping rule in Emacs Lisp is called dynamic scoping, which simply states that the current binding at any given point in the execution of a program is the most recently-created binding for that variable that still exists. For details about dynamic scoping, and an alternative scoping rule called lexical scoping, See Variable Scoping.

The special forms let and let* exist to create local bindings:
— Special Form: let (bindings...) forms...

    This special form sets up local bindings for a certain set of variables, as specified by bindings, and then evaluates all of the forms in textual order. Its return value is the value of the last form in forms. The local bindings set up by let will be in effect only within the body of forms.

    Each of the bindings is either (i) a symbol, in which case that symbol is locally bound to nil; or (ii) a list of the form (symbol value-form), in which case symbol is locally bound to the result of evaluating value-form. If value-form is omitted, nil is used.

    All of the value-forms in bindings are evaluated in the order they appear and before binding any of the symbols to them. Here is an example of this: z is bound to the old value of y, which is 2, not the new value of y, which is 1.

:               (setq y 2)
:                    ⇒ 2
:
:               (let ((y 1)
:                     (z y))
:                 (list y z))
:                    ⇒ (1 2)
# 关键点便是let有两个()
    On the other hand, the order of bindings is unspecified: in the following example, either 1 or 2 might be printed.

              (let ((x 1)
                    (x 2))
                (print x))

    Therefore, avoid binding a variable more than once in a single let form.

— Special Form: let* (bindings...) forms...

    This special form is like let, but it binds each variable right after computing its local value, before computing the local value for the next variable. Therefore, an expression in bindings can refer to the preceding symbols bound in this let* form. Compare the following example with the example above for let.

              (setq y 2)
                   ⇒ 2

              (let* ((y 1)
                     (z y))    ; Use the just-established value of y.
                (list y z))
                   ⇒ (1 1)

Here is a complete list of the other facilities that create local bindings:

    Function calls (see Functions).
    Macro calls (see Macros).
    condition-case (see Errors).

Variables can also have buffer-local bindings (see Buffer-Local Variables); a few variables have terminal-local bindings (see Multiple Terminals). These kinds of bindings work somewhat like ordinary local bindings, but they are localized depending on where you are in Emacs.
— User Option: max-specpdl-size

    This variable defines the limit on the total number of local variable bindings and unwind-protect cleanups (see Cleaning Up from Nonlocal Exits) that are allowed before Emacs signals an error (with data "Variable binding depth exceeds max-specpdl-size").

    This limit, with the associated error when it is exceeded, is one way that Lisp avoids infinite recursion on an ill-defined function. max-lisp-eval-depth provides another limit on depth of nesting. See Eval.

    The default value is 1300. Entry to the Lisp debugger increases the value, if there is little room left, to make sure the debugger itself has room to execute. 

** 12.10 Scoping Rules for Variable Bindings

 When you create a local binding for a variable, that binding takes effect only within a limited portion of the program (see Local Variables). This section describes exactly what this means.

 Each local binding has a certain scope and extent. Scope refers to where in the textual source code the binding can be accessed. Extent refers to when, as the program is executing, the binding exists.

 By default, the local bindings that Emacs creates are dynamic bindings. Such a binding has dynamic scope, meaning that any part of the program can potentially access the variable binding. It also has dynamic extent, meaning that the binding lasts only while the binding construct (such as the body of a let form) is being executed.

 Emacs can optionally create lexical bindings. A lexical binding has lexical scope, meaning that any reference to the variable must be located textually within the binding construct1. It also has indefinite extent, meaning that under some circumstances the binding can live on even after the binding construct has finished executing, by means of special objects called closures.

 The following subsections describe dynamic binding and lexical binding in greater detail, and how to enable lexical binding in Emacs Lisp programs.

     1. Dynamic Binding: The default for binding local variables in Emacs.
     2. Dynamic Binding Tips: Avoiding problems with dynamic binding.
     3. Lexical Binding: A different type of local variable binding.
     4. Using Lexical Binding: How to enable lexical binding.

*** 12.10.1 Dynamic Binding

By default, the local variable bindings made by Emacs are dynamic bindings. When a variable is dynamically bound, its current binding at any point in the execution of the Lisp program is simply the most recently-created dynamic local binding for that symbol, or the global binding if there is no such local binding.

Dynamic bindings have dynamic scope and extent, as shown by the following example:

:     (defvar x -99)  ; x receives an initial value of −99.

:     (defun getx ()
       x)            ; x is used free in this function.

:     (let ((x 1))    ; x is dynamically bound.
:       (getx))
          ⇒ 1

     ;; After the let form finishes, x reverts to its
     ;; previous value, which is −99.

:     (getx)
          ⇒ -99

:The function getx refers to x. This is a free reference, in the sense that there is no binding for x within that defun construct itself. When we call getx from within a let form in which x is (dynamically) bound, it retrieves the local value (i.e., 1). But when we call getx outside the let form, it retrieves the global value (i.e., −99).

Here is another example, which illustrates setting a dynamically bound variable using setq:

:     (defvar x -99)      ; x receives an initial value of −99.

:     (defun addx ()
:       (setq x (1+ x)))  ; Add 1 to x and return its new value.

:     (let ((x 1))
:       (addx)
:       (addx))
          ⇒ 3           ; The two addx calls add to x twice.

     ;; After the let form finishes, x reverts to its
     ;; previous value, which is −99.

:     (addx)
          ⇒ -98
# 这不就是普通的dynamic binding的实现吗?
Dynamic binding is implemented in Emacs Lisp in a simple way. Each symbol has a value cell, which specifies its current dynamic value (or absence of value). See Symbol Components. When a symbol is given a dynamic local binding, Emacs records the contents of the value cell (or absence thereof) in a stack, and stores the new local value in the value cell. When the binding construct finishes executing, Emacs pops the old value off the stack, and puts it in the value cell.

*** 12.10.2 Proper Use of Dynamic Binding

Dynamic binding is a powerful feature, as it allows programs to refer to variables that are not defined within their local textual scope. However, if used without restraint, this can also make programs hard to understand. There are two clean ways to use this technique:

    If a variable has no global definition, use it as a local variable only within a binding construct, such as the body of the let form where the variable was bound. If this convention is followed consistently throughout a program, the value of the variable will not affect, nor be affected by, any uses of the same variable symbol elsewhere in the program.
    Otherwise, define the variable with defvar, defconst (see Defining Variables), or defcustom (see Variable Definitions). Usually, the definition should be at top-level in an Emacs Lisp file. As far as possible, it should include a documentation string which explains the meaning and purpose of the variable. You should also choose the variable's name to avoid name conflicts (see Coding Conventions).

    Then you can bind the variable anywhere in a program, knowing reliably what the effect will be. Wherever you encounter the variable, it will be easy to refer back to the definition, e.g., via the C-h v command (provided the variable definition has been loaded into Emacs). See Name Help.

    For example, it is common to use local bindings for customizable variables like case-fold-search:

    #+begin_src emacs-lisp :tangle yes
              (defun search-for-abc ()
                "Search for the string \"abc\", ignoring case differences."
                (let ((case-fold-search t))
                  (re-search-forward "abc")))
    #+end_src

*** 12.10.3 Lexical Binding

Lexical binding was introduced to Emacs, as an optional feature, in version 24.1. We expect its importance to increase with time. Lexical binding opens up many more opportunities for optimization, so programs using it are likely to run faster in future Emacs versions. Lexical binding is also more compatible with concurrency, which was added to Emacs in version 26.1.

A lexically-bound variable has lexical scope, meaning that any reference to the variable must be located textually within the binding construct. Here is an example (see Using Lexical Binding, for how to actually enable lexical binding):
# 将lexical修改为t与nil, 观察报错.
#+begin_src emacs-lisp :session sicp :lexical t
     (let ((x 1))    ; x is lexically bound.
       (+ x 3))
     (defun getx ()
       x)            ; x is used free in this function.

     (let ((x 1))    ; x is lexically bound.
       (getx))
#+end_src

#+RESULTS:
: 1

Here, the variable x has no global value. When it is lexically bound within a let form, it can be used in the textual confines of that let form. But it can not be used from within a getx function called from the let form, since the function definition of getx occurs outside the let form itself.

Here is how lexical binding works. Each binding construct defines a lexical environment, specifying the variables that are bound within the construct and their local values. When the Lisp evaluator wants the current value of a variable, it looks first in the lexical environment; if the variable is not specified in there, it looks in the symbol's value cell, where the dynamic value is stored.

(Internally, the lexical environment is an alist of symbol-value pairs, with the final element in the alist being the symbol t rather than a cons cell. Such an alist can be passed as the second argument to the eval function, in order to specify a lexical environment in which to evaluate a form. See Eval. Most Emacs Lisp programs, however, should not interact directly with lexical environments in this way; only specialized programs like debuggers.)

Lexical bindings have indefinite extent. Even after a binding construct has finished executing, its lexical environment can be “kept around” in Lisp objects called closures. A closure is created when you define a named or anonymous function with lexical binding enabled. See Closures, for details.

When a closure is called as a function, any lexical variable references within its definition use the retained lexical environment. Here is an example:

#+begin_src emacs-lisp :session sicp :lexical t
     (defvar my-ticker nil)   ; We will use this dynamically bound
                              ; variable to store a closure.

     (let ((x 0))             ; x is lexically bound.
       (setq my-ticker (lambda ()
                         (setq x (1+ x)))))
     ;    ⇒ (closure ((x . 0) t) ()
     ;         (setq x (1+ x)))
     ;(my-ticker)

     (funcall my-ticker)
     ;   ⇒ 1

     (funcall my-ticker)
     ;    ⇒ 2

     (funcall my-ticker)
     ;    ⇒ 3

    ;x                        ; Note that x has no global value.
    ; error--> Symbol's value as variable is void: x
#+end_src

#+RESULTS:
: 3

The let binding defines a lexical environment in which the variable x is locally bound to 0. Within this binding construct, we define a lambda expression which increments x by one and returns the incremented value. This lambda expression is automatically turned into a closure, in which the lexical environment lives on even after the let binding construct has exited. Each time we evaluate the closure, it increments x, using the binding of x in that lexical environment.

Note that unlike dynamic variables which are tied to the symbol object itself, the relationship between lexical variables and symbols is only present in the interpreter (or compiler). Therefore, functions which take a symbol argument (like symbol-value, boundp, and set) can only retrieve or modify a variable's dynamic binding (i.e., the contents of its symbol's value cell). 

*** 12.10.4 Using Lexical Binding

When loading an Emacs Lisp file or evaluating a Lisp buffer, lexical binding is enabled if the buffer-local variable lexical-binding is non-nil:
— Variable: lexical-binding

    If this buffer-local variable is non-nil, Emacs Lisp files and buffers are evaluated using lexical binding instead of dynamic binding. (However, special variables are still dynamically bound; see below.) If nil, dynamic binding is used for all local variables. This variable is typically set for a whole Emacs Lisp file, as a file local variable (see File Local Variables). Note that unlike other such variables, this one must be set in the first line of a file.

When evaluating Emacs Lisp code directly using an eval call, lexical binding is enabled if the lexical argument to eval is non-nil. See Eval.

Even when lexical binding is enabled, certain variables will continue to be dynamically bound. These are called special variables. Every variable that has been defined with defvar, defcustom or defconst is a special variable (see Defining Variables). All other variables are subject to lexical binding.

Using defvar without a value, it is possible to bind a variable dynamically just in one file, or in just one part of a file while still binding it lexically elsewhere. For example:

#+begin_src emacs-lisp :session sicp :lexical t
     (let (_)
       (defvar x)      ; Let-bindings of x will be dynamic within this let.
       (let ((x -99))  ; This is a dynamic binding of x.
         (defun get-dynamic-x ()
           x)))

     (let ((x 'lexical)) ; This is a lexical binding of x.
       (defun get-lexical-x ()
         x))

     (let (_)
       (defvar x)
       (let ((x 'dynamic))
         (list (get-lexical-x)
               (get-dynamic-x))))
         ⇒ (lexical dynamic)
#+end_src

— Function: special-variable-p symbol

    This function returns non-nil if symbol is a special variable (i.e., it has a defvar, defcustom, or defconst variable definition). Otherwise, the return value is nil.

The use of a special variable as a formal argument in a function is discouraged. Doing so gives rise to unspecified behavior when lexical binding mode is enabled (it may use lexical binding sometimes, and dynamic binding other times).

Converting an Emacs Lisp program to lexical binding is easy. First, add a file-local variable setting of lexical-binding to t in the header line of the Emacs Lisp source file (see File Local Variables). Second, check that every variable in the program which needs to be dynamically bound has a variable definition, so that it is not inadvertently bound lexically.

A simple way to find out which variables need a variable definition is to byte-compile the source file. See Byte Compilation. If a non-special variable is used outside of a let form, the byte-compiler will warn about reference or assignment to a free variable. If a non-special variable is bound but not used within a let form, the byte-compiler will warn about an unused lexical variable. The byte-compiler will also issue a warning if you use a special variable as a function argument.

(To silence byte-compiler warnings about unused variables, just use a variable name that starts with an underscore. The byte-compiler interprets this as an indication that this is a variable known not to be used.) 

* 13 Functions
   :PROPERTIES:
   :CUSTOM_ID: functions
   :END:

A Lisp program is composed mainly of Lisp functions. This chapter explains what functions are, how they accept arguments, and how to define them.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.1 What Is a Function?
    :PROPERTIES:
    :CUSTOM_ID: what-is-a-function
    :END:

In a general sense, a function is a rule for carrying out a computation given input values called arguments. The result of the computation is called the value or return value of the function. The computation can also have side effects, such as lasting changes in the values of variables or the contents of data structures (see [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-side-effect][Definition of side effect]]). A pure function is a function which, in addition to having no side effects, always returns the same value for the same combination of arguments, regardless of external factors such as machine type or system state.

In most computer languages, every function has a name. But in Lisp, a function in the strictest sense has no name: it is an object which can /optionally/ be associated with a symbol (e.g., =car=) that serves as the function name. See [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]]. When a function has been given a name, we usually also refer to that symbol as a "function" (e.g., we refer to "the function =car="). In this manual, the distinction between a function name and the function object itself is usually unimportant, but we will take note wherever it is relevant.

Certain function-like objects, called special forms and macros, also accept arguments to carry out computations. However, as explained below, these are not considered functions in Emacs Lisp.

Here are important terms for functions and function-like objects:

- lambda expression

  A function (in the strict sense, i.e., a function object) which is written in Lisp. These are described in the following section. See [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]].

- primitive

  A function which is callable from Lisp but is actually written in C. Primitives are also called built-in functions, or subrs. Examples include functions like =car= and =append=. In addition, all special forms (see below) are also considered primitives. Usually, a function is implemented as a primitive because it is a fundamental part of Lisp (e.g., =car=), or because it provides a low-level interface to operating system services, or because it needs to run fast. Unlike functions defined in Lisp, primitives can be modified or added only by changing the C sources and recompiling Emacs. See [[file:///home/gaowei/Desktop/elisp-manual.html#Writing-Emacs-Primitives][Writing Emacs Primitives]].

- special form

  A primitive that is like a function but does not evaluate all of its arguments in the usual way. It may evaluate only some of the arguments, or may evaluate them in an unusual order, or several times. Examples include =if=, =and=, and =while=. See [[file:///home/gaowei/Desktop/elisp-manual.html#Special-Forms][Special Forms]].

- macro

  A construct defined in Lisp, which differs from a function in that it translates a Lisp expression into another expression which is to be evaluated instead of the original expression. Macros enable Lisp programmers to do the sorts of things that special forms can do. See [[file:///home/gaowei/Desktop/elisp-manual.html#Macros][Macros]].

- command

  An object which can be invoked via the =command-execute= primitive, usually due to the user typing in a key sequence bound to that command. See [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]]. A command is usually a function; if the function is written in Lisp, it is made into a command by an =interactive= form in the function definition (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Commands][Defining Commands]]). Commands that are functions can also be called from Lisp expressions, just like other functions. Keyboard macros (strings and vectors) are commands also, even though they are not functions. See [[file:///home/gaowei/Desktop/elisp-manual.html#Keyboard-Macros][Keyboard Macros]]. We say that a symbol is a command if its function cell contains a command (see [[file:///home/gaowei/Desktop/elisp-manual.html#Symbol-Components][Symbol Components]]); such a named command can be invoked with M-x.

- closure

  A function object that is much like a lambda expression, except that it also encloses an environment of lexical variable bindings. See [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]].

- byte-code function

  A function that has been compiled by the byte compiler. See [[file:///home/gaowei/Desktop/elisp-manual.html#Byte_002dCode-Type][Byte-Code Type]].

- autoload object

  A place-holder for a real function. If the autoload object is called, Emacs loads the file containing the definition of the real function, and then calls the real function. See [[file:///home/gaowei/Desktop/elisp-manual.html#Autoload][Autoload]].

You can use the function =functionp= to test if an object is a function:

--- Function: *functionp* object

#+BEGIN_QUOTE
  This function returns =t= if object is any kind of function, i.e., can be passed to =funcall=. Note that =functionp= returns =t= for symbols that are function names, and returns =nil= for special forms.
#+END_QUOTE

It is also possible to find out how many arguments an arbitrary function expects:

--- Function: *func-arity* function

#+BEGIN_QUOTE
  This function provides information about the argument list of the specified function. The returned value is a cons cell of the form =(=min=.=max=)=, where min is the minimum number of arguments, and max is either the maximum number of arguments, or the symbol =many= for functions with =&rest= arguments, or the symbol =unevalled= if function is a special form.

  Note that this function might return inaccurate results in some situations, such as the following:

  - Functions defined using =apply-partially= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][apply-partially]]).\\
  - Functions that are advised using =advice-add= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Named-Functions][Advising Named Functions]]).\\
  - Functions that determine the argument list dynamically, as part of their code.
#+END_QUOTE

Unlike =functionp=, the next three functions do /not/ treat a symbol as its function definition.

--- Function: *subrp* object

#+BEGIN_QUOTE
  This function returns =t= if object is a built-in function (i.e., a Lisp primitive).

  #+BEGIN_EXAMPLE
                (subrp 'message)            ; message is a symbol,
                     ⇒ nil                 ;   not a subr object.
                (subrp (symbol-function 'message))
                     ⇒ t
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *byte-code-function-p* object

#+BEGIN_QUOTE
  This function returns =t= if object is a byte-code function. For example:

  #+BEGIN_EXAMPLE
                (byte-code-function-p (symbol-function 'next-line))
                     ⇒ t
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *subr-arity* subr

#+BEGIN_QUOTE
  This works like =func-arity=, but only for built-in functions and without symbol indirection. It signals an error for non-built-in functions. We recommend to use =func-arity= instead.
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#What-Is-a-Function][What Is a Function]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.2 Lambda Expressions
    :PROPERTIES:
    :CUSTOM_ID: lambda-expressions
    :END:

A lambda expression is a function object written in Lisp. Here is an example:

#+BEGIN_EXAMPLE
         (lambda (x)
           "Return the hyperbolic cosine of X."
           (* 0.5 (+ (exp x) (exp (- x)))))
#+END_EXAMPLE

In Emacs Lisp, such a list is a valid expression which evaluates to a function object.

A lambda expression, by itself, has no name; it is an anonymous function. Although lambda expressions can be used this way (see [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]]), they are more commonly associated with symbols to make named functions (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]]). Before going into these details, the following subsections describe the components of a lambda expression and what they do.

- [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Components][Lambda Components]]: The parts of a lambda expression.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Simple-Lambda][Simple Lambda]]: A simple example.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Argument-List][Argument List]]: Details and special features of argument lists.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]]: How to put documentation in a function.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Simple-Lambda][Simple Lambda]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]]

*** 13.2.1 Components of a Lambda Expression
     :PROPERTIES:
     :CUSTOM_ID: components-of-a-lambda-expression
     :END:

A lambda expression is a list that looks like this:

#+BEGIN_EXAMPLE
         (lambda (arg-variables...)
           [documentation-string]
           [interactive-declaration]
           body-forms...)
#+END_EXAMPLE

The first element of a lambda expression is always the symbol =lambda=. This indicates that the list represents a function. The reason functions are defined to start with =lambda= is so that other lists, intended for other uses, will not accidentally be valid as functions.

The second element is a list of symbols---the argument variable names. This is called the lambda list. When a Lisp function is called, the argument values are matched up against the variables in the lambda list, which are given local bindings with the values provided. See [[file:///home/gaowei/Desktop/elisp-manual.html#Local-Variables][Local Variables]].

The documentation string is a Lisp string object placed within the function definition to describe the function for the Emacs help facilities. See [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]].

The interactive declaration is a list of the form =(interactive=code-string=)=. This declares how to provide arguments if the function is used interactively. Functions with this declaration are called commands; they can be called using M-x or bound to a key. Functions not intended to be called in this way should not have interactive declarations. See [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Commands][Defining Commands]], for how to write an interactive declaration.

The rest of the elements are the body of the function: the Lisp code to do the work of the function (or, as a Lisp programmer would say, "a list of Lisp forms to evaluate"). The value returned by the function is the value returned by the last element of the body.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Argument-List][Argument List]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Components][Lambda Components]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]]

*** 13.2.2 A Simple Lambda Expression Example
     :PROPERTIES:
     :CUSTOM_ID: a-simple-lambda-expression-example
     :END:

Consider the following example:

#+BEGIN_EXAMPLE
         (lambda (a b c) (+ a b c))
#+END_EXAMPLE

We can call this function by passing it to =funcall=, like this:

#+BEGIN_EXAMPLE
         (funcall (lambda (a b c) (+ a b c))
                  1 2 3)
#+END_EXAMPLE

This call evaluates the body of the lambda expression with the variable =a= bound to 1, =b= bound to 2, and =c= bound to 3. Evaluation of the body adds these three numbers, producing the result 6; therefore, this call to the function returns the value 6.

Note that the arguments can be the results of other function calls, as in this example:

#+BEGIN_EXAMPLE
         (funcall (lambda (a b c) (+ a b c))
                  1 (* 2 3) (- 5 4))
#+END_EXAMPLE

This evaluates the arguments =1=, =(* 2 3)=, and =(- 5 4)= from left to right. Then it applies the lambda expression to the argument values 1, 6 and 1 to produce the value 8.

As these examples show, you can use a form with a lambda expression as its car to make local variables and give them values. In the old days of Lisp, this technique was the only way to bind and initialize local variables. But nowadays, it is clearer to use the special form =let= for this purpose (see [[file:///home/gaowei/Desktop/elisp-manual.html#Local-Variables][Local Variables]]). Lambda expressions are mainly used as anonymous functions for passing as arguments to other functions (see [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]]), or stored as symbol function definitions to produce named functions (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]]).

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Simple-Lambda][Simple Lambda]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]]

*** 13.2.3 Other Features of Argument Lists
     :PROPERTIES:
     :CUSTOM_ID: other-features-of-argument-lists
     :END:

Our simple sample function, =(lambda (a b c) (+ a b c))=, specifies three argument variables, so it must be called with three arguments: if you try to call it with only two arguments or four arguments, you get a =wrong-number-of-arguments= error (see [[file:///home/gaowei/Desktop/elisp-manual.html#Errors][Errors]]).

It is often convenient to write a function that allows certain arguments to be omitted. For example, the function =substring= accepts three arguments---a string, the start index and the end index---but the third argument defaults to the length of the string if you omit it. It is also convenient for certain functions to accept an indefinite number of arguments, as the functions =list= and =+= do.

To specify optional arguments that may be omitted when a function is called, simply include the keyword =&optional= before the optional arguments. To specify a list of zero or more extra arguments, include the keyword =&rest= before one final argument.

Thus, the complete syntax for an argument list is as follows:

#+BEGIN_EXAMPLE
         (required-vars...
          [&optional optional-vars...]
          [&rest rest-var])
#+END_EXAMPLE

The square brackets indicate that the =&optional= and =&rest= clauses, and the variables that follow them, are optional.

A call to the function requires one actual argument for each of the required-vars. There may be actual arguments for zero or more of the optional-vars, and there cannot be any actual arguments beyond that unless the lambda list uses =&rest=. In that case, there may be any number of extra actual arguments.

If actual arguments for the optional and rest variables are omitted, then they always default to =nil=. There is no way for the function to distinguish between an explicit argument of =nil= and an omitted argument. However, the body of the function is free to consider =nil= an abbreviation for some other meaningful value. This is what =substring= does; =nil= as the third argument to =substring= means to use the length of the string supplied.

#+BEGIN_QUOTE
  *Common Lisp note:* Common Lisp allows the function to specify what default value to use when an optional argument is omitted; Emacs Lisp always uses =nil=. Emacs Lisp does not support =supplied-p= variables that tell you whether an argument was explicitly passed.
#+END_QUOTE

For example, an argument list that looks like this:

#+BEGIN_EXAMPLE
         (a b &optional c d &rest e)
#+END_EXAMPLE

binds =a= and =b= to the first two actual arguments, which are required. If one or two more arguments are provided, =c= and =d= are bound to them respectively; any arguments after the first four are collected into a list and =e= is bound to that list. Thus, if there are only two arguments, =c=, =d= and =e= are =nil=; if two or three arguments, =d= and =e= are =nil=; if four arguments or fewer, =e= is =nil=. Note that exactly five arguments with an explicit =nil= argument provided for =e= will cause that =nil= argument to be passed as a list with one element, =(nil)=, as with any other single value for =e=.

There is no way to have required arguments following optional ones---it would not make sense. To see why this must be so, suppose that =c= in the example were optional and =d= were required. Suppose three actual arguments are given; which variable would the third argument be for? Would it be used for the c, or for d? One can argue for both possibilities. Similarly, it makes no sense to have any more arguments (either required or optional) after a =&rest= argument.

Here are some examples of argument lists and proper calls:

#+BEGIN_EXAMPLE
         (funcall (lambda (n) (1+ n))        ; One required:
                  1)                         ; requires exactly one argument.
              ⇒ 2
         (funcall (lambda (n &optional n1)   ; One required and one optional:
                    (if n1 (+ n n1) (1+ n))) ; 1 or 2 arguments.
                  1 2)
              ⇒ 3
         (funcall (lambda (n &rest ns)       ; One required and one rest:
                    (+ n (apply '+ ns)))     ; 1 or more arguments.
                  1 2 3 4 5)
              ⇒ 15
#+END_EXAMPLE

Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Argument-List][Argument List]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]]

*** 13.2.4 Documentation Strings of Functions
     :PROPERTIES:
     :CUSTOM_ID: documentation-strings-of-functions
     :END:

A lambda expression may optionally have a documentation string just after the lambda list. This string does not affect execution of the function; it is a kind of comment, but a systematized comment which actually appears inside the Lisp world and can be used by the Emacs help facilities. See [[file:///home/gaowei/Desktop/elisp-manual.html#Documentation][Documentation]], for how the documentation string is accessed.

It is a good idea to provide documentation strings for all the functions in your program, even those that are called only from within your program. Documentation strings are like comments, except that they are easier to access.

The first line of the documentation string should stand on its own, because =apropos= displays just this first line. It should consist of one or two complete sentences that summarize the function's purpose.

The start of the documentation string is usually indented in the source file, but since these spaces come before the starting double-quote, they are not part of the string. Some people make a practice of indenting any additional lines of the string so that the text lines up in the program source. /That is a mistake./ The indentation of the following lines is inside the string; what looks nice in the source code will look ugly when displayed by the help commands.

You may wonder how the documentation string could be optional, since there are required components of the function that follow it (the body). Since evaluation of a string returns that string, without any side effects, it has no effect if it is not the last form in the body. Thus, in practice, there is no confusion between the first form of the body and the documentation string; if the only body form is a string then it serves both as the return value and as the documentation.

The last line of the documentation string can specify calling conventions different from the actual function arguments. Write text like this:

#+BEGIN_EXAMPLE
         \(fn arglist)
#+END_EXAMPLE

following a blank line, at the beginning of the line, with no newline following it inside the documentation string. (The ‘' is used to avoid confusing the Emacs motion commands.) The calling convention specified in this way appears in help messages in place of the one derived from the actual arguments of the function.

This feature is particularly useful for macro definitions, since the arguments written in a macro definition often do not correspond to the way users think of the parts of the macro call.

Do not use this feature if you want to deprecate the calling convention and favor the one you advertise by the above specification. Instead, use the =advertised-calling-convention= declaration (see [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]]) or =set-advertised-calling-convention= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]]), because these two will cause the byte compiler emit a warning message when it compiles Lisp programs which use the deprecated calling convention.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Lambda-Expressions][Lambda Expressions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.3 Naming a Function
    :PROPERTIES:
    :CUSTOM_ID: naming-a-function
    :END:

A symbol can serve as the name of a function. This happens when the symbol's function cell (see [[file:///home/gaowei/Desktop/elisp-manual.html#Symbol-Components][Symbol Components]]) contains a function object (e.g., a lambda expression). Then the symbol itself becomes a valid, callable function, equivalent to the function object in its function cell.

The contents of the function cell are also called the symbol's function definition. The procedure of using a symbol's function definition in place of the symbol is called symbol function indirection; see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Indirection][Function Indirection]]. If you have not given a symbol a function definition, its function cell is said to be void, and it cannot be used as a function.

In practice, nearly all functions have names, and are referred to by their names. You can create a named Lisp function by defining a lambda expression and putting it in a function cell (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Cells][Function Cells]]). However, it is more common to use the =defun= special form, described in the next section. See [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]].

We give functions names because it is convenient to refer to them by their names in Lisp expressions. Also, a named Lisp function can easily refer to itself---it can be recursive. Furthermore, primitives can only be referred to textually by their names, since primitive function objects (see [[file:///home/gaowei/Desktop/elisp-manual.html#Primitive-Function-Type][Primitive Function Type]]) have no read syntax.

A function need not have a unique name. A given function object /usually/ appears in the function cell of only one symbol, but this is just a convention. It is easy to store it in several symbols using =fset=; then each of the symbols is a valid name for the same function.

Note that a symbol used as a function name may also be used as a variable; these two uses of a symbol are independent and do not conflict. (This is not the case in some dialects of Lisp, like Scheme.)

By convention, if a function's symbol consists of two names separated by '--', the function is intended for internal use and the first part names the file defining the function. For example, a function named =vc-git--rev-parse= is an internal function defined in vc-git.el. Internal-use functions written in C have names ending in '-internal', e.g., =bury-buffer-internal=. Emacs code contributed before 2018 may follow other internal-use naming conventions, which are being phased out.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Names][Function Names]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.4 Defining Functions
    :PROPERTIES:
    :CUSTOM_ID: defining-functions
    :END:

We usually give a name to a function when it is first created. This is called defining a function, and it is done with the =defun= macro.

--- Macro: *defun* name args [doc] [declare] [interactive] body...

#+BEGIN_QUOTE
  =defun= is the usual way to define new Lisp functions. It defines the symbol name as a function with argument list args and body forms given by body. Neither name nor args should be quoted.

  doc, if present, should be a string specifying the function's documentation string (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]]). declare, if present, should be a =declare= form specifying function metadata (see [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]]). interactive, if present, should be an =interactive= form specifying how the function is to be called interactively (see [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]]).

  The return value of =defun= is undefined.

  Here are some examples:

  #+BEGIN_EXAMPLE
                (defun foo () 5)
                (foo)
                     ⇒ 5

                (defun bar (a &optional b &rest c)
                    (list a b c))
                (bar 1 2 3 4 5)
                     ⇒ (1 2 (3 4 5))
                (bar 1)
                     ⇒ (1 nil nil)
                (bar)
                error--> Wrong number of arguments.

                (defun capitalize-backwards ()
                  "Upcase the last letter of the word at point."
                  (interactive)
                  (backward-word 1)
                  (forward-word 1)
                  (backward-char 1)
                  (capitalize-word 1))
  #+END_EXAMPLE

  Be careful not to redefine existing functions unintentionally. =defun= redefines even primitive functions such as =car= without any hesitation or notification. Emacs does not prevent you from doing this, because redefining a function is sometimes done deliberately, and there is no way to distinguish deliberate redefinition from unintentional redefinition.
#+END_QUOTE

--- Function: *defalias* name definition &optional doc

#+BEGIN_QUOTE
  This function defines the symbol name as a function, with definition definition (which can be any valid Lisp function). Its return value is /undefined/.

  If doc is non-=nil=, it becomes the function documentation of name. Otherwise, any documentation provided by definition is used.

  Internally, =defalias= normally uses =fset= to set the definition. If name has a =defalias-fset-function= property, however, the associated value is used as a function to call in place of =fset=.

  The proper place to use =defalias= is where a specific function name is being defined---especially where that name appears explicitly in the source file being loaded. This is because =defalias= records which file defined the function, just like =defun= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Unloading][Unloading]]).

  By contrast, in programs that manipulate function definitions for other purposes, it is better to use =fset=, which does not keep such records. See [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Cells][Function Cells]].
#+END_QUOTE

You cannot create a new primitive function with =defun= or =defalias=, but you can use them to change the function definition of any symbol, even one such as =car= or =x-popup-menu= whose normal definition is a primitive. However, this is risky: for instance, it is next to impossible to redefine =car= without breaking Lisp completely. Redefining an obscure function such as =x-popup-menu= is less dangerous, but it still may not work as you expect. If there are calls to the primitive from C code, they call the primitive's C definition directly, so changing the symbol's definition will have no effect on them.

See also =defsubst=, which defines a function like =defun= and tells the Lisp compiler to perform inline expansion on it. See [[file:///home/gaowei/Desktop/elisp-manual.html#Inline-Functions][Inline Functions]].

Alternatively, you can define a function by providing the code which will inline it as a compiler macro. The following macros make this possible.

--- Macro: *define-inline* name args [doc] [declare] body...

#+BEGIN_QUOTE
  Define a function name by providing code that does its inlining, as a compiler macro. The function will accept the argument list args and will have the specified body.

  If present, doc should be the function's documentation string (see [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Documentation][Function Documentation]]); declare, if present, should be a =declare= form (see [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]]) specifying the function's metadata.
#+END_QUOTE

Functions defined via =define-inline= have several advantages with respect to macros defined by =defsubst= or =defmacro=:

- They can be passed to =mapcar= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]]).\\
- They are more efficient.\\
- They can be used as place forms to store values (see [[file:///home/gaowei/Desktop/elisp-manual.html#Generalized-Variables][Generalized Variables]]).\\
- They behave in a more predictable way than =cl-defsubst= (see [[https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Argument-Lists][Argument Lists]]).

Like =defmacro=, a function inlined with =define-inline= inherits the scoping rules, either dynamic or lexical, from the call site. See [[file:///home/gaowei/Desktop/elisp-manual.html#Variable-Scoping][Variable Scoping]].

The following macros should be used in the body of a function defined by =define-inline=.

--- Macro: *inline-quote* expression

#+BEGIN_QUOTE
  Quote expression for =define-inline=. This is similar to the backquote (see [[file:///home/gaowei/Desktop/elisp-manual.html#Backquote][Backquote]]), but quotes code and accepts only =,=, not =,@=.
#+END_QUOTE

--- Macro: *inline-letevals* (bindings...) body...

#+BEGIN_QUOTE
  This is similar to =let= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Local-Variables][Local Variables]]): it sets up local variables as specified by bindings, and then evaluates body with those bindings in effect. Each element of bindings should be either a symbol or a list of the form =(=var==expr=)=; the result is to evaluate expr and bind var to the result. The tail of bindings can be either =nil= or a symbol which should hold a list of arguments, in which case each argument is evaluated, and the symbol is bound to the resulting list.
#+END_QUOTE

--- Macro: *inline-const-p* expression

#+BEGIN_QUOTE
  Return non-=nil= if the value of expression is already known.
#+END_QUOTE

--- Macro: *inline-const-val* expression

#+BEGIN_QUOTE
  Return the value of expression.
#+END_QUOTE

--- Macro: *inline-error* format &rest args

#+BEGIN_QUOTE
  Signal an error, formatting args according to format.
#+END_QUOTE

Here's an example of using =define-inline=:

#+BEGIN_EXAMPLE
         (define-inline myaccessor (obj)
           (inline-letevals (obj)
             (inline-quote (if (foo-p ,obj) (aref (cdr ,obj) 3) (aref ,obj 2)))))
#+END_EXAMPLE

This is equivalent to

#+BEGIN_EXAMPLE
         (defsubst myaccessor (obj)
           (if (foo-p obj) (aref (cdr obj) 3) (aref obj 2)))
#+END_EXAMPLE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.5 Calling Functions
    :PROPERTIES:
    :CUSTOM_ID: calling-functions
    :END:

Defining functions is only half the battle. Functions don't do anything until you call them, i.e., tell them to run. Calling a function is also known as invocation.

The most common way of invoking a function is by evaluating a list. For example, evaluating the list =(concat "a" "b")= calls the function =concat= with arguments ="a"= and ="b"=. See [[file:///home/gaowei/Desktop/elisp-manual.html#Evaluation][Evaluation]], for a description of evaluation.

When you write a list as an expression in your program, you specify which function to call, and how many arguments to give it, in the text of the program. Usually that's just what you want. Occasionally you need to compute at run time which function to call. To do that, use the function =funcall=. When you also need to determine at run time how many arguments to pass, use =apply=.

--- Function: *funcall* function &rest arguments

#+BEGIN_QUOTE
  =funcall= calls function with arguments, and returns whatever function returns.

  Since =funcall= is a function, all of its arguments, including function, are evaluated before =funcall= is called. This means that you can use any expression to obtain the function to be called. It also means that =funcall= does not see the expressions you write for the arguments, only their values. These values are /not/ evaluated a second time in the act of calling function; the operation of =funcall= is like the normal procedure for calling a function, once its arguments have already been evaluated.

  The argument function must be either a Lisp function or a primitive function. Special forms and macros are not allowed, because they make sense only when given the unevaluated argument expressions. =funcall= cannot provide these because, as we saw above, it never knows them in the first place.

  If you need to use =funcall= to call a command and make it behave as if invoked interactively, use =funcall-interactively= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]]).

  #+BEGIN_EXAMPLE
                (setq f 'list)
                     ⇒ list
                (funcall f 'x 'y 'z)
                     ⇒ (x y z)
                (funcall f 'x 'y '(z))
                     ⇒ (x y (z))
                (funcall 'and t nil)
                error--> Invalid function: #<subr and>
  #+END_EXAMPLE

  Compare these examples with the examples of =apply=.
#+END_QUOTE

--- Function: *apply* function &rest arguments

#+BEGIN_QUOTE
  =apply= calls function with arguments, just like =funcall= but with one difference: the last of arguments is a list of objects, which are passed to function as separate arguments, rather than a single list. We say that =apply= spreads this list so that each individual element becomes an argument.

  =apply= returns the result of calling function. As with =funcall=, function must either be a Lisp function or a primitive function; special forms and macros do not make sense in =apply=.

  #+BEGIN_EXAMPLE
                (setq f 'list)
                     ⇒ list
                (apply f 'x 'y 'z)
                error--> Wrong type argument: listp, z
                (apply '+ 1 2 '(3 4))
                     ⇒ 10
                (apply '+ '(1 2 3 4))
                     ⇒ 10

                (apply 'append '((a b c) nil (x y z) nil))
                     ⇒ (a b c x y z)
  #+END_EXAMPLE

  For an interesting example of using =apply=, see [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-mapcar][Definition of mapcar]].
#+END_QUOTE

Sometimes it is useful to fix some of the function's arguments at certain values, and leave the rest of arguments for when the function is actually called. The act of fixing some of the function's arguments is called partial application of the function[[file:///home/gaowei/Desktop/elisp-manual.html#fn-10][10]]. The result is a new function that accepts the rest of arguments and calls the original function with all the arguments combined.

Here's how to do partial application in Emacs Lisp:

--- Function: *apply-partially* func &rest args

#+BEGIN_QUOTE
  This function returns a new function which, when called, will call func with the list of arguments composed from args and additional arguments specified at the time of the call. If func accepts n arguments, then a call to =apply-partially= with m=<=n arguments will produce a new function of n=-=m arguments.

  Here's how we could define the built-in function =1+=, if it didn't exist, using =apply-partially= and =+=, another built-in function:

  #+BEGIN_EXAMPLE
                (defalias '1+ (apply-partially '+ 1)
                  "Increment argument by one.")
                (1+ 10)
                     ⇒ 11
  #+END_EXAMPLE
#+END_QUOTE

It is common for Lisp functions to accept functions as arguments or find them in data structures (especially in hook variables and property lists) and call them using =funcall= or =apply=. Functions that accept function arguments are often called functionals.

Sometimes, when you call a functional, it is useful to supply a no-op function as the argument. Here are two different kinds of no-op function:

--- Function: *identity* arg

#+BEGIN_QUOTE
  This function returns arg and has no side effects.
#+END_QUOTE

--- Function: *ignore* &rest args

#+BEGIN_QUOTE
  This function ignores any arguments and returns =nil=.
#+END_QUOTE

Some functions are user-visible commands, which can be called interactively (usually by a key sequence). It is possible to invoke such a command exactly as though it was called interactively, by using the =call-interactively= function. See [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]].

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.6 Mapping Functions
    :PROPERTIES:
    :CUSTOM_ID: mapping-functions
    :END:

A mapping function applies a given function (/not/ a special form or macro) to each element of a list or other collection. Emacs Lisp has several such functions; this section describes =mapcar=, =mapc=, =mapconcat=, and =mapcan=, which map over a list. See [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-mapatoms][Definition of mapatoms]], for the function =mapatoms= which maps over the symbols in an obarray. See [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-maphash][Definition of maphash]], for the function =maphash= which maps over key/value associations in a hash table.

These mapping functions do not allow char-tables because a char-table is a sparse array whose nominal range of indices is very large. To map over a char-table in a way that deals properly with its sparse nature, use the function =map-char-table= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Char_002dTables][Char-Tables]]).

--- Function: *mapcar* function sequence

#+BEGIN_QUOTE
  =mapcar= applies function to each element of sequence in turn, and returns a list of the results.

  The argument sequence can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string. The result is always a list. The length of the result is the same as the length of sequence. For example:

  #+BEGIN_EXAMPLE
                (mapcar 'car '((a b) (c d) (e f)))
                     ⇒ (a c e)
                (mapcar '1+ [1 2 3])
                     ⇒ (2 3 4)
                (mapcar 'string "abc")
                     ⇒ ("a" "b" "c")

                ;; Call each function in my-hooks.
                (mapcar 'funcall my-hooks)

                (defun mapcar* (function &rest args)
                  "Apply FUNCTION to successive cars of all ARGS.
                Return the list of results."
                  ;; If no list is exhausted,
                  (if (not (memq nil args))
                      ;; apply function to cars.
                      (cons (apply function (mapcar 'car args))
                            (apply 'mapcar* function
                                   ;; Recurse for rest of elements.
                                   (mapcar 'cdr args)))))

                (mapcar* 'cons '(a b c) '(1 2 3 4))
                     ⇒ ((a . 1) (b . 2) (c . 3))
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *mapcan* function sequence

#+BEGIN_QUOTE
  This function applies function to each element of sequence, like =mapcar=, but instead of collecting the results into a list, it returns a single list with all the elements of the results (which must be lists), by altering the results (using =nconc=; see [[file:///home/gaowei/Desktop/elisp-manual.html#Rearrangement][Rearrangement]]). Like with =mapcar=, sequence can be of any type except a char-table.

  #+BEGIN_EXAMPLE
                ;; Contrast this:
                (mapcar 'list '(a b c d))
                     ⇒ ((a) (b) (c) (d))
                ;; with this:
                (mapcan 'list '(a b c d))
                     ⇒ (a b c d)
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *mapc* function sequence

#+BEGIN_QUOTE
  =mapc= is like =mapcar= except that function is used for side-effects only---the values it returns are ignored, not collected into a list. =mapc= always returns sequence.
#+END_QUOTE

--- Function: *mapconcat* function sequence separator

#+BEGIN_QUOTE
  =mapconcat= applies function to each element of sequence; the results, which must be sequences of characters (strings, vectors, or lists), are concatenated into a single string return value. Between each pair of result sequences, =mapconcat= inserts the characters from separator, which also must be a string, or a vector or list of characters. See [[file:///home/gaowei/Desktop/elisp-manual.html#Sequences-Arrays-Vectors][Sequences Arrays Vectors]].

  The argument function must be a function that can take one argument and returns a sequence of characters: a string, a vector, or a list. The argument sequence can be any kind of sequence except a char-table; that is, a list, a vector, a bool-vector, or a string.

  #+BEGIN_EXAMPLE
                (mapconcat 'symbol-name
                           '(The cat in the hat)
                           " ")
                     ⇒ "The cat in the hat"

                (mapconcat (function (lambda (x) (format "%c" (1+ x))))
                           "HAL-8000"
                           "")
                     ⇒ "IBM.9111"
  #+END_EXAMPLE
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Generic-Functions][Generic Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.7 Anonymous Functions
    :PROPERTIES:
    :CUSTOM_ID: anonymous-functions
    :END:

Although functions are usually defined with =defun= and given names at the same time, it is sometimes convenient to use an explicit lambda expression---an anonymous function. Anonymous functions are valid wherever function names are. They are often assigned as variable values, or as arguments to functions; for instance, you might pass one as the function argument to =mapcar=, which applies that function to each element of a list (see [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]]). See [[file:///home/gaowei/Desktop/elisp-manual.html#describe_002dsymbols-example][describe-symbols example]], for a realistic example of this.

When defining a lambda expression that is to be used as an anonymous function, you can in principle use any method to construct the list. But typically you should use the =lambda= macro, or the =function= special form, or the =#'= read syntax:

--- Macro: *lambda* args [doc] [interactive] body...

#+BEGIN_QUOTE
  This macro returns an anonymous function with argument list args, documentation string doc (if any), interactive spec interactive (if any), and body forms given by body.

  Under dynamic binding, this macro effectively makes =lambda= forms self-quoting: evaluating a form whose car is =lambda= yields the form itself:

  #+BEGIN_EXAMPLE
                (lambda (x) (* x x))
                     ⇒ (lambda (x) (* x x))
  #+END_EXAMPLE

  Note that when evaluating under lexical binding the result is a closure object (see [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]]).

  The =lambda= form has one other effect: it tells the Emacs evaluator and byte-compiler that its argument is a function, by using =function= as a subroutine (see below).
#+END_QUOTE

--- Special Form: *function* function-object

#+BEGIN_QUOTE
  This special form returns function-object without evaluating it. In this, it is similar to =quote= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Quoting][Quoting]]). But unlike =quote=, it also serves as a note to the Emacs evaluator and byte-compiler that function-object is intended to be used as a function. Assuming function-object is a valid lambda expression, this has two effects:

  - When the code is byte-compiled, function-object is compiled into a byte-code function object (see [[file:///home/gaowei/Desktop/elisp-manual.html#Byte-Compilation][Byte Compilation]]).\\
  - When lexical binding is enabled, function-object is converted into a closure. See [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]].
#+END_QUOTE

The read syntax =#'= is a short-hand for using =function=. The following forms are all equivalent:

#+BEGIN_EXAMPLE
         (lambda (x) (* x x))
         (function (lambda (x) (* x x)))
         #'(lambda (x) (* x x))
#+END_EXAMPLE

In the following example, we define a =change-property= function that takes a function as its third argument, followed by a =double-property= function that makes use of =change-property= by passing it an anonymous function:

#+BEGIN_EXAMPLE
         (defun change-property (symbol prop function)
           (let ((value (get symbol prop)))
             (put symbol prop (funcall function value))))

         (defun double-property (symbol prop)
           (change-property symbol prop (lambda (x) (* 2 x))))
#+END_EXAMPLE

Note that we do not quote the =lambda= form.

If you compile the above code, the anonymous function is also compiled. This would not happen if, say, you had constructed the anonymous function by quoting it as a list:

#+BEGIN_EXAMPLE
         (defun double-property (symbol prop)
           (change-property symbol prop '(lambda (x) (* 2 x))))
#+END_EXAMPLE

In that case, the anonymous function is kept as a lambda expression in the compiled code. The byte-compiler cannot assume this list is a function, even though it looks like one, since it does not know that =change-property= intends to use it as a function.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Cells][Function Cells]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.8 Generic Functions
    :PROPERTIES:
    :CUSTOM_ID: generic-functions
    :END:

Functions defined using =defun= have a hard-coded set of assumptions about the types and expected values of their arguments. For example, a function that was designed to handle values of its argument that are either numbers or lists of numbers will fail or signal an error if called with a value of any other type, such as a vector or a string. This happens because the implementation of the function is not prepared to deal with types other than those assumed during the design.

By contrast, object-oriented programs use polymorphic functions: a set of specialized functions having the same name, each one of which was written for a certain specific set of argument types. Which of the functions is actually called is decided at run time based on the types of the actual arguments.

Emacs provides support for polymorphism. Like other Lisp environments, notably Common Lisp and its Common Lisp Object System (CLOS), this support is based on generic functions. The Emacs generic functions closely follow CLOS, including use of similar names, so if you have experience with CLOS, the rest of this section will sound very familiar.

A generic function specifies an abstract operation, by defining its name and list of arguments, but (usually) no implementation. The actual implementation for several specific classes of arguments is provided by methods, which should be defined separately. Each method that implements a generic function has the same name as the generic function, but the method's definition indicates what kinds of arguments it can handle by specializing the arguments defined by the generic function. These argument specializers can be more or less specific; for example, a =string= type is more specific than a more general type, such as =sequence=.

Note that, unlike in message-based OO languages, such as C=++= and Simula, methods that implement generic functions don't belong to a class, they belong to the generic function they implement.

When a generic function is invoked, it selects the applicable methods by comparing the actual arguments passed by the caller with the argument specializers of each method. A method is applicable if the actual arguments of the call are compatible with the method's specializers. If more than one method is applicable, they are combined using certain rules, described below, and the combination then handles the call.

--- Macro: *cl-defgeneric* name arguments [documentation] [options-and-methods...] &rest body

#+BEGIN_QUOTE
  This macro defines a generic function with the specified name and arguments. If body is present, it provides the default implementation. If documentation is present (it should always be), it specifies the documentation string for the generic function, in the form =(:documentation=docstring=)=. The optional options-and-methods can be one of the following forms:

  - =(declare=declarations=)=

    A declare form, as described in [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]].

  - =(:argument-precedence-order &rest=args=)=

    This form affects the sorting order for combining applicable methods. Normally, when two methods are compared during combination, method arguments are examined left to right, and the first method whose argument specializer is more specific will come before the other one. The order defined by this form overrides that, and the arguments are examined according to their order in this form, and not left to right.

  - =(:method [=qualifiers=...] args &rest body)=

    This form defines a method like =cl-defmethod= does.

#+END_QUOTE

--- Macro: *cl-defmethod* name [qualifier] arguments &rest [docstring] body

#+BEGIN_QUOTE
  This macro defines a particular implementation for the generic function called name. The implementation code is given by body. If present, docstring is the documentation string for the method. The arguments list, which must be identical in all the methods that implement a generic function, and must match the argument list of that function, provides argument specializers of the form =(=arg spec=)=, where arg is the argument name as specified in the =cl-defgeneric= call, and spec is one of the following specializer forms:

  - type

    This specializer requires the argument to be of the given type, one of the types from the type hierarchy described below.

  - =(eql=object=)=

    This specializer requires the argument be =eql= to the given object.

  - =(head=object=)=

    The argument must be a cons cell whose =car= is =eql= to object.

  - struct-type

    The argument must be an instance of a class named struct-type defined with =cl-defstruct= (see [[https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Structures][Structures]]), or of one of its child classes.

  Alternatively, the argument specializer can be of the form =&context (=expr spec=)=, in which case the value of expr must be compatible with the specializer provided by spec; spec can be any of the forms described above. In other words, this form of specializer uses the value of expr instead of arguments for the decision whether the method is applicable. For example, =&context (overwrite-mode (eql t))= will make the method compatible only when =overwrite-mode= is turned on.

  The type specializer, =(=arg type=)=, can specify one of the system types in the following list. When a parent type is specified, an argument whose type is any of its more specific child types, as well as grand-children, grand-grand-children, etc. will also be compatible.

  - =integer=

    Parent type: =number=.

  - =number=

  - =null=

    Parent type: =symbol=

  - =symbol=

  - =string=

    Parent type: =array=.

  - =array=

    Parent type: =sequence=.

  - =cons=

    Parent type: =list=.

  - =list=

    Parent type: =sequence=.

  - =marker=

  - =overlay=

  - =float=

    Parent type: =number=.

  - =window-configuration=

  - =process=

  - =window=

  - =subr=

  - =compiled-function=

  - =buffer=

  - =char-table=

    Parent type: =array=.

  - =bool-vector=

    Parent type: =array=.

  - =vector=

    Parent type: =array=.

  - =frame=

  - =hash-table=

  - =font-spec=

  - =font-entity=

  - =font-object=

  The optional qualifier allows combining several applicable methods. If it is not present, the defined method is a primary method, responsible for providing the primary implementation of the generic function for the specialized arguments. You can also define auxiliary methods, by using one of the following values as qualifier:

  - =:before=

    This auxiliary method will run before the primary method. More accurately, all the =:before= methods will run before the primary, in the most-specific-first order.

  - =:after=

    This auxiliary method will run after the primary method. More accurately, all such methods will run after the primary, in the most-specific-last order.

  - =:around=

    This auxiliary method will run /instead/ of the primary method. The most specific of such methods will be run before any other method. Such methods normally use =cl-call-next-method=, described below, to invoke the other auxiliary or primary methods.

  - =:extra=string

    This allows you to add more methods, distinguished by string, for the same specializers and qualifiers.

  Functions defined using =cl-defmethod= cannot be made interactive, i.e. commands (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Commands][Defining Commands]]), by adding the =interactive= form to them. If you need a polymorphic command, we recommend defining a normal command that calls a polymorphic function defined via =cl-defgeneric= and =cl-defmethod=.
#+END_QUOTE

Each time a generic function is called, it builds the effective method which will handle this invocation by combining the applicable methods defined for the function. The process of finding the applicable methods and producing the effective method is called dispatch. The applicable methods are those all of whose specializers are compatible with the actual arguments of the call. Since all of the arguments must be compatible with the specializers, they all determine whether a method is applicable. Methods that explicitly specialize more than one argument are called multiple-dispatch methods.

The applicable methods are sorted into the order in which they will be combined. The method whose left-most argument specializer is the most specific one will come first in the order. (Specifying =:argument-precedence-order= as part of =cl-defmethod= overrides that, as described above.) If the method body calls =cl-call-next-method=, the next most-specific method will run. If there are applicable =:around= methods, the most-specific of them will run first; it should call =cl-call-next-method= to run any of the less specific =:around= methods. Next, the =:before= methods run in the order of their specificity, followed by the primary method, and lastly the =:after= methods in the reverse order of their specificity.

--- Function: *cl-call-next-method* &rest args

#+BEGIN_QUOTE
  When invoked from within the lexical body of a primary or an =:around= auxiliary method, call the next applicable method for the same generic function. Normally, it is called with no arguments, which means to call the next applicable method with the same arguments that the calling method was invoked. Otherwise, the specified arguments are used instead.
#+END_QUOTE

--- Function: *cl-next-method-p*

#+BEGIN_QUOTE
  This function, when called from within the lexical body of a primary or an =:around= auxiliary method, returns non-=nil= if there is a next method to call.
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Generic-Functions][Generic Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.9 Accessing Function Cell Contents
    :PROPERTIES:
    :CUSTOM_ID: accessing-function-cell-contents
    :END:

The function definition of a symbol is the object stored in the function cell of the symbol. The functions described here access, test, and set the function cell of symbols.

See also the function =indirect-function=. See [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-indirect_002dfunction][Definition of indirect-function]].

--- Function: *symbol-function* symbol

#+BEGIN_QUOTE
  This returns the object in the function cell of symbol. It does not check that the returned object is a legitimate function.

  If the function cell is void, the return value is =nil=. To distinguish between a function cell that is void and one set to =nil=, use =fboundp= (see below).

  #+BEGIN_EXAMPLE
                (defun bar (n) (+ n 2))
                (symbol-function 'bar)
                     ⇒ (lambda (n) (+ n 2))
                (fset 'baz 'bar)
                     ⇒ bar
                (symbol-function 'baz)
                     ⇒ bar
  #+END_EXAMPLE
#+END_QUOTE

If you have never given a symbol any function definition, we say that that symbol's function cell is void. In other words, the function cell does not have any Lisp object in it. If you try to call the symbol as a function, Emacs signals a =void-function= error.

Note that void is not the same as =nil= or the symbol =void=. The symbols =nil= and =void= are Lisp objects, and can be stored into a function cell just as any other object can be (and they can be valid functions if you define them in turn with =defun=). A void function cell contains no object whatsoever.

You can test the voidness of a symbol's function definition with =fboundp=. After you have given a symbol a function definition, you can make it void once more using =fmakunbound=.

--- Function: *fboundp* symbol

#+BEGIN_QUOTE
  This function returns =t= if the symbol has an object in its function cell, =nil= otherwise. It does not check that the object is a legitimate function.
#+END_QUOTE

--- Function: *fmakunbound* symbol

#+BEGIN_QUOTE
  This function makes symbol's function cell void, so that a subsequent attempt to access this cell will cause a =void-function= error. It returns symbol. (See also =makunbound=, in [[file:///home/gaowei/Desktop/elisp-manual.html#Void-Variables][Void Variables]].)

  #+BEGIN_EXAMPLE
                (defun foo (x) x)
                (foo 1)
                     ⇒1
                (fmakunbound 'foo)
                     ⇒ foo
                (foo 1)
                error--> Symbol's function definition is void: foo
  #+END_EXAMPLE
#+END_QUOTE

--- Function: *fset* symbol definition

#+BEGIN_QUOTE
  This function stores definition in the function cell of symbol. The result is definition. Normally definition should be a function or the name of a function, but this is not checked. The argument symbol is an ordinary evaluated argument.

  The primary use of this function is as a subroutine by constructs that define or alter functions, like =defun= or =advice-add= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]). You can also use it to give a symbol a function definition that is not a function, e.g., a keyboard macro (see [[file:///home/gaowei/Desktop/elisp-manual.html#Keyboard-Macros][Keyboard Macros]]):

  #+BEGIN_EXAMPLE
                ;; Define a named keyboard macro.
                (fset 'kill-two-lines "\^u2\^k")
                     ⇒ "\^u2\^k"
  #+END_EXAMPLE

  It you wish to use =fset= to make an alternate name for a function, consider using =defalias= instead. See [[file:///home/gaowei/Desktop/elisp-manual.html#Definition-of-defalias][Definition of defalias]].
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Cells][Function Cells]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.10 Closures
    :PROPERTIES:
    :CUSTOM_ID: closures
    :END:

As explained in [[file:///home/gaowei/Desktop/elisp-manual.html#Variable-Scoping][Variable Scoping]], Emacs can optionally enable lexical binding of variables. When lexical binding is enabled, any named function that you create (e.g., with =defun=), as well as any anonymous function that you create using the =lambda= macro or the =function= special form or the =#'= syntax (see [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]]), is automatically converted into a closure.

A closure is a function that also carries a record of the lexical environment that existed when the function was defined. When it is invoked, any lexical variable references within its definition use the retained lexical environment. In all other respects, closures behave much like ordinary functions; in particular, they can be called in the same way as ordinary functions.

See [[file:///home/gaowei/Desktop/elisp-manual.html#Lexical-Binding][Lexical Binding]], for an example of using a closure.

Currently, an Emacs Lisp closure object is represented by a list with the symbol =closure= as the first element, a list representing the lexical environment as the second element, and the argument list and body forms as the remaining elements:

#+BEGIN_EXAMPLE
         ;; lexical binding is enabled.
         (lambda (x) (* x x))
              ⇒ (closure (t) (x) (* x x))
#+END_EXAMPLE

However, the fact that the internal structure of a closure is exposed to the rest of the Lisp world is considered an internal implementation detail. For this reason, we recommend against directly examining or altering the structure of closure objects.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Closures][Closures]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.11 Advising Emacs Lisp Functions
    :PROPERTIES:
    :CUSTOM_ID: advising-emacs-lisp-functions
    :END:

When you need to modify a function defined in another library, or when you need to modify a hook like foo=-function=, a process filter, or basically any variable or object field which holds a function value, you can use the appropriate setter function, such as =fset= or =defun= for named functions, =setq= for hook variables, or =set-process-filter= for process filters, but those are often too blunt, completely throwing away the previous value.

The advice feature lets you add to the existing definition of a function, by advising the function. This is a cleaner method than redefining the whole function.

Emacs's advice system provides two sets of primitives for that: the core set, for function values held in variables and object fields (with the corresponding primitives being =add-function= and =remove-function=) and another set layered on top of it for named functions (with the main primitives being =advice-add= and =advice-remove=).

For example, in order to trace the calls to the process filter of a process proc, you could use:

#+BEGIN_EXAMPLE
         (defun my-tracing-function (proc string)
           (message "Proc %S received %S" proc string))

         (add-function :before (process-filter proc) #'my-tracing-function)
#+END_EXAMPLE

This will cause the process's output to be passed to =my-tracing-function= before being passed to the original process filter. =my-tracing-function= receives the same arguments as the original function. When you're done with it, you can revert to the untraced behavior with:

#+BEGIN_EXAMPLE
         (remove-function (process-filter proc) #'my-tracing-function)
#+END_EXAMPLE

Similarly, if you want to trace the execution of the function named =display-buffer=, you could use:

#+BEGIN_EXAMPLE
         (defun his-tracing-function (orig-fun &rest args)
           (message "display-buffer called with args %S" args)
           (let ((res (apply orig-fun args)))
             (message "display-buffer returned %S" res)
             res))

         (advice-add 'display-buffer :around #'his-tracing-function)
#+END_EXAMPLE

Here, =his-tracing-function= is called instead of the original function and receives the original function (additionally to that function's arguments) as argument, so it can call it if and when it needs to. When you're tired of seeing this output, you can revert to the untraced behavior with:

#+BEGIN_EXAMPLE
         (advice-remove 'display-buffer #'his-tracing-function)
#+END_EXAMPLE

The arguments =:before= and =:around= used in the above examples specify how the two functions are composed, since there are many different ways to do it. The added function is also called a piece of /advice/.

- [[file:///home/gaowei/Desktop/elisp-manual.html#Core-Advising-Primitives][Core Advising Primitives]]: Primitives to manipulate advice.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Named-Functions][Advising Named Functions]]: Advising named functions.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Advice-combinators][Advice combinators]]: Ways to compose advice.
- [[file:///home/gaowei/Desktop/elisp-manual.html#Porting-old-advice][Porting old advice]]: Adapting code using the old defadvice.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Named-Functions][Advising Named Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]

*** 13.11.1 Primitives to manipulate advices
     :PROPERTIES:
     :CUSTOM_ID: primitives-to-manipulate-advices
     :END:

--- Macro: *add-function* where place function &optional props

#+BEGIN_QUOTE
  This macro is the handy way to add the advice function to the function stored in place (see [[file:///home/gaowei/Desktop/elisp-manual.html#Generalized-Variables][Generalized Variables]]).

  where determines how function is composed with the existing function, e.g., whether function should be called before, or after the original function. See [[file:///home/gaowei/Desktop/elisp-manual.html#Advice-combinators][Advice combinators]], for the list of available ways to compose the two functions.

  When modifying a variable (whose name will usually end with =-function=), you can choose whether function is used globally or only in the current buffer: if place is just a symbol, then function is added to the global value of place. Whereas if place is of the form =(local=symbol=)=, where symbol is an expression which returns the variable name, then function will only be added in the current buffer. Finally, if you want to modify a lexical variable, you will have to use =(var=variable=)=.

  Every function added with =add-function= can be accompanied by an association list of properties props. Currently only two of those properties have a special meaning:

  - =name=

    This gives a name to the advice, which =remove-function= can use to identify which function to remove. Typically used when function is an anonymous function.

  - =depth=

    This specifies how to order the advice, should several pieces of advice be present. By default, the depth is 0. A depth of 100 indicates that this piece of advice should be kept as deep as possible, whereas a depth of −100 indicates that it should stay as the outermost piece. When two pieces of advice specify the same depth, the most recently added one will be outermost. For =:before= advice, being outermost means that this advice will be run first, before any other advice, whereas being innermost means that it will run right before the original function, with no other advice run between itself and the original function. Similarly, for =:after= advice innermost means that it will run right after the original function, with no other advice run in between, whereas outermost means that it will be run right at the end after all other advice. An innermost =:override= piece of advice will only override the original function and other pieces of advice will apply to it, whereas an outermost =:override= piece of advice will override not only the original function but all other advice applied to it as well.

  If function is not interactive, then the combined function will inherit the interactive spec, if any, of the original function. Else, the combined function will be interactive and will use the interactive spec of function. One exception: if the interactive spec of function is a function (rather than an expression or a string), then the interactive spec of the combined function will be a call to that function with as sole argument the interactive spec of the original function. To interpret the spec received as argument, use =advice-eval-interactive-spec=.

  Note: The interactive spec of function will apply to the combined function and should hence obey the calling convention of the combined function rather than that of function. In many cases, it makes no difference since they are identical, but it does matter for =:around=, =:filter-args=, and =:filter-return=, where function receives different arguments than the original function stored in place.
#+END_QUOTE

--- Macro: *remove-function* place function

#+BEGIN_QUOTE
  This macro removes function from the function stored in place. This only works if function was added to place using =add-function=.

  function is compared with functions added to place using =equal=, to try and make it work also with lambda expressions. It is additionally compared also with the =name= property of the functions added to place, which can be more reliable than comparing lambda expressions using =equal=.
#+END_QUOTE

--- Function: *advice-function-member-p* advice function-def

#+BEGIN_QUOTE
  Return non-=nil= if advice is already in function-def. Like for =remove-function= above, instead of advice being the actual function, it can also be the =name= of the piece of advice.
#+END_QUOTE

--- Function: *advice-function-mapc* f function-def

#+BEGIN_QUOTE
  Call the function f for every piece of advice that was added to function-def. f is called with two arguments: the advice function and its properties.
#+END_QUOTE

--- Function: *advice-eval-interactive-spec* spec

#+BEGIN_QUOTE
  Evaluate the interactive spec just like an interactive call to a function with such a spec would, and then return the corresponding list of arguments that was built. E.g., =(advice-eval-interactive-spec "r\nP")= will return a list of three elements, containing the boundaries of the region and the current prefix argument.
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Advice-combinators][Advice combinators]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Core-Advising-Primitives][Core Advising Primitives]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]

*** 13.11.2 Advising Named Functions
     :PROPERTIES:
     :CUSTOM_ID: advising-named-functions
     :END:

A common use of advice is for named functions and macros. You could just use =add-function= as in:

#+BEGIN_EXAMPLE
         (add-function :around (symbol-function 'fun) #'his-tracing-function)
#+END_EXAMPLE

But you should use =advice-add= and =advice-remove= for that instead. This separate set of functions to manipulate pieces of advice applied to named functions, offers the following extra features compared to =add-function=: they know how to deal with macros and autoloaded functions, they let =describe-function= preserve the original docstring as well as document the added advice, and they let you add and remove advice before a function is even defined.

=advice-add= can be useful for altering the behavior of existing calls to an existing function without having to redefine the whole function. However, it can be a source of bugs, since existing callers to the function may assume the old behavior, and work incorrectly when the behavior is changed by advice. Advice can also cause confusion in debugging, if the person doing the debugging does not notice or remember that the function has been modified by advice.

For these reasons, advice should be reserved for the cases where you cannot modify a function's behavior in any other way. If it is possible to do the same thing via a hook, that is preferable (see [[file:///home/gaowei/Desktop/elisp-manual.html#Hooks][Hooks]]). If you simply want to change what a particular key does, it may be better to write a new command, and remap the old command's key bindings to the new one (see [[file:///home/gaowei/Desktop/elisp-manual.html#Remapping-Commands][Remapping Commands]]). In particular, Emacs's own source files should not put advice on functions in Emacs. (There are currently a few exceptions to this convention, but we aim to correct them.)

Special forms (see [[file:///home/gaowei/Desktop/elisp-manual.html#Special-Forms][Special Forms]]) cannot be advised, however macros can be advised, in much the same way as functions. Of course, this will not affect code that has already been macro-expanded, so you need to make sure the advice is installed before the macro is expanded.

It is possible to advise a primitive (see [[file:///home/gaowei/Desktop/elisp-manual.html#What-Is-a-Function][What Is a Function]]), but one should typically /not/ do so, for two reasons. Firstly, some primitives are used by the advice mechanism, and advising them could cause an infinite recursion. Secondly, many primitives are called directly from C, and such calls ignore advice; hence, one ends up in a confusing situation where some calls (occurring from Lisp code) obey the advice and other calls (from C code) do not.

--- Macro: *define-advice* symbol (where lambda-list &optional name depth) &rest body

#+BEGIN_QUOTE
  This macro defines a piece of advice and adds it to the function named symbol. The advice is an anonymous function if name is =nil= or a function named =symbol@name=. See =advice-add= for explanation of other arguments.
#+END_QUOTE

--- Function: *advice-add* symbol where function &optional props

#+BEGIN_QUOTE
  Add the advice function to the named function symbol. where and props have the same meaning as for =add-function= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Core-Advising-Primitives][Core Advising Primitives]]).
#+END_QUOTE

--- Function: *advice-remove* symbol function

#+BEGIN_QUOTE
  Remove the advice function from the named function symbol. function can also be the =name= of a piece of advice.
#+END_QUOTE

--- Function: *advice-member-p* function symbol

#+BEGIN_QUOTE
  Return non-=nil= if the advice function is already in the named function symbol. function can also be the =name= of a piece of advice.
#+END_QUOTE

--- Function: *advice-mapc* function symbol

#+BEGIN_QUOTE
  Call function for every piece of advice that was added to the named function symbol. function is called with two arguments: the advice function and its properties.
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Porting-old-advice][Porting old advice]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Named-Functions][Advising Named Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]

*** 13.11.3 Ways to compose advice
     :PROPERTIES:
     :CUSTOM_ID: ways-to-compose-advice
     :END:

Here are the different possible values for the where argument of =add-function= and =advice-add=, specifying how the advice function and the original function should be composed.

- =:before=

  Call function before the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (apply function r) (apply oldfun r))= =(add-function :before=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function=)= for normal hooks.

- =:after=

  Call function after the old function. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (prog1 (apply oldfun r) (apply function r)))= =(add-function :after=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function='append)= for normal hooks.

- =:override=

  This completely replaces the old function with the new one. The old function can of course be recovered if you later call =remove-function=.

- =:around=

  Call function instead of the old function, but provide the old function as an extra argument to function. This is the most flexible composition. For example, it lets you call the old function with different arguments, or many times, or within a let-binding, or you can sometimes delegate the work to the old function and sometimes override it completely. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (apply function oldfun r))=

- =:before-while=

  Call function before the old function and don't call the old function if function returns =nil=. Both functions receive the same arguments, and the return value of the composition is the return value of the old function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (and (apply function r) (apply oldfun r)))= =(add-function :before-while=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function=)= when hookvar is run via =run-hook-with-args-until-failure=.

- =:before-until=

  Call function before the old function and only call the old function if function returns =nil=. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (or (apply function r) (apply oldfun r)))= =(add-function :before-until=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function=)= when hookvar is run via =run-hook-with-args-until-success=.

- =:after-while=

  Call function after the old function and only if the old function returned non-=nil=. Both functions receive the same arguments, and the return value of the composition is the return value of function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (and (apply oldfun r) (apply function r)))= =(add-function :after-while=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function='append)= when hookvar is run via =run-hook-with-args-until-failure=.

- =:after-until=

  Call function after the old function and only if the old function returned =nil=. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (or  (apply oldfun r) (apply function r)))= =(add-function :after-until=funvar function=)= is comparable for single-function hooks to =(add-hook '=hookvar function='append)= when hookvar is run via =run-hook-with-args-until-success=.

- =:filter-args=

  Call function first and use the result (which should be a list) as the new arguments to pass to the old function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (apply oldfun (funcall function r)))=

- =:filter-return=

  Call the old function first and pass the result to function. More specifically, the composition of the two functions behaves like: =(lambda (&rest r) (funcall function (apply oldfun r)))=

Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Advice-combinators][Advice combinators]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]

*** 13.11.4 Adapting code using the old defadvice
     :PROPERTIES:
     :CUSTOM_ID: adapting-code-using-the-old-defadvice
     :END:

A lot of code uses the old =defadvice= mechanism, which is largely made obsolete by the new =advice-add=, whose implementation and semantics is significantly simpler.

An old piece of advice such as:

#+BEGIN_EXAMPLE
         (defadvice previous-line (before next-line-at-end
                                          (&optional arg try-vscroll))
           "Insert an empty line when moving up from the top line."
           (if (and next-line-add-newlines (= arg 1)
                    (save-excursion (beginning-of-line) (bobp)))
               (progn
                 (beginning-of-line)
                 (newline))))
#+END_EXAMPLE

could be translated in the new advice mechanism into a plain function:

#+BEGIN_EXAMPLE
         (defun previous-line--next-line-at-end (&optional arg try-vscroll)
           "Insert an empty line when moving up from the top line."
           (if (and next-line-add-newlines (= arg 1)
                    (save-excursion (beginning-of-line) (bobp)))
               (progn
                 (beginning-of-line)
                 (newline))))
#+END_EXAMPLE

Obviously, this does not actually modify =previous-line=. For that the old advice needed:

#+BEGIN_EXAMPLE
         (ad-activate 'previous-line)
#+END_EXAMPLE

whereas the new advice mechanism needs:

#+BEGIN_EXAMPLE
         (advice-add 'previous-line :before #'previous-line--next-line-at-end)
#+END_EXAMPLE

Note that =ad-activate= had a global effect: it activated all pieces of advice enabled for that specified function. If you wanted to only activate or deactivate a particular piece, you needed to /enable/ or /disable/ it with =ad-enable-advice= and =ad-disable-advice=. The new mechanism does away with this distinction.

Around advice such as:

#+BEGIN_EXAMPLE
         (defadvice foo (around foo-around)
           "Ignore case in `foo'."
           (let ((case-fold-search t))
             ad-do-it))
         (ad-activate 'foo)
#+END_EXAMPLE

could translate into:

#+BEGIN_EXAMPLE
         (defun foo--foo-around (orig-fun &rest args)
           "Ignore case in `foo'."
           (let ((case-fold-search t))
             (apply orig-fun args)))
         (advice-add 'foo :around #'foo--foo-around)
#+END_EXAMPLE

Regarding the advice's /class/, note that the new =:before= is not quite equivalent to the old =before=, because in the old advice you could modify the function's arguments (e.g., with =ad-set-arg=), and that would affect the argument values seen by the original function, whereas in the new =:before=, modifying an argument via =setq= in the advice has no effect on the arguments seen by the original function. When porting =before= advice which relied on this behavior, you'll need to turn it into new =:around= or =:filter-args= advice instead.

Similarly old =after= advice could modify the returned value by changing =ad-return-value=, whereas new =:after= advice cannot, so when porting such old =after= advice, you'll need to turn it into new =:around= or =:filter-return= advice instead.

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Inline-Functions][Inline Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.12 Declaring Functions Obsolete
    :PROPERTIES:
    :CUSTOM_ID: declaring-functions-obsolete
    :END:

You can mark a named function as obsolete, meaning that it may be removed at some point in the future. This causes Emacs to warn that the function is obsolete whenever it byte-compiles code containing that function, and whenever it displays the documentation for that function. In all other respects, an obsolete function behaves like any other function.

The easiest way to mark a function as obsolete is to put a =(declare (obsolete ...))= form in the function's =defun= definition. See [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]]. Alternatively, you can use the =make-obsolete= function, described below.

A macro (see [[file:///home/gaowei/Desktop/elisp-manual.html#Macros][Macros]]) can also be marked obsolete with =make-obsolete=; this has the same effects as for a function. An alias for a function or macro can also be marked as obsolete; this makes the alias itself obsolete, not the function or macro which it resolves to.

--- Function: *make-obsolete* obsolete-name current-name &optional when

#+BEGIN_QUOTE
  This function marks obsolete-name as obsolete. obsolete-name should be a symbol naming a function or macro, or an alias for a function or macro.

  If current-name is a symbol, the warning message says to use current-name instead of obsolete-name. current-name does not need to be an alias for obsolete-name; it can be a different function with similar functionality. current-name can also be a string, which serves as the warning message. The message should begin in lower case, and end with a period. It can also be =nil=, in which case the warning message provides no additional details.

  If provided, when should be a string indicating when the function was first made obsolete---for example, a date or a release number.
#+END_QUOTE

--- Macro: *define-obsolete-function-alias* obsolete-name current-name &optional when doc

#+BEGIN_QUOTE
  This convenience macro marks the function obsolete-name obsolete and also defines it as an alias for the function current-name. It is equivalent to the following:

  #+BEGIN_EXAMPLE
                (defalias obsolete-name current-name doc)
                (make-obsolete obsolete-name current-name when)
  #+END_EXAMPLE
#+END_QUOTE

In addition, you can mark a particular calling convention for a function as obsolete:

--- Function: *set-advertised-calling-convention* function signature when

#+BEGIN_QUOTE
  This function specifies the argument list signature as the correct way to call function. This causes the Emacs byte compiler to issue a warning whenever it comes across an Emacs Lisp program that calls function any other way (however, it will still allow the code to be byte compiled). when should be a string indicating when the variable was first made obsolete (usually a version number string).

  For instance, in old versions of Emacs the =sit-for= function accepted three arguments, like this

  #+BEGIN_EXAMPLE
                  (sit-for seconds milliseconds nodisp)
  #+END_EXAMPLE

  However, calling =sit-for= this way is considered obsolete (see [[file:///home/gaowei/Desktop/elisp-manual.html#Waiting][Waiting]]). The old calling convention is deprecated like this:

  #+BEGIN_EXAMPLE
                (set-advertised-calling-convention
                  'sit-for '(seconds &optional nodisp) "22.1")
  #+END_EXAMPLE
#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.13 Inline Functions
    :PROPERTIES:
    :CUSTOM_ID: inline-functions
    :END:

An inline function is a function that works just like an ordinary function, except for one thing: when you byte-compile a call to the function (see [[file:///home/gaowei/Desktop/elisp-manual.html#Byte-Compilation][Byte Compilation]]), the function's definition is expanded into the caller. To define an inline function, use =defsubst= instead of =defun=.

--- Macro: *defsubst* name args [doc] [declare] [interactive] body...

#+BEGIN_QUOTE
  This macro defines an inline function. Its syntax is exactly the same as =defun= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]]).
#+END_QUOTE

Making a function inline often makes its function calls run faster. But it also has disadvantages. For one thing, it reduces flexibility; if you change the definition of the function, calls already inlined still use the old definition until you recompile them.

Another disadvantage is that making a large function inline can increase the size of compiled code both in files and in memory. Since the speed advantage of inline functions is greatest for small functions, you generally should not make large functions inline.

Also, inline functions do not behave well with respect to debugging, tracing, and advising (see [[file:///home/gaowei/Desktop/elisp-manual.html#Advising-Functions][Advising Functions]]). Since ease of debugging and the flexibility of redefining functions are important features of Emacs, you should not make a function inline, even if it's small, unless its speed is really crucial, and you've timed the code to verify that using =defun= actually has performance problems.

After an inline function is defined, its inline expansion can be performed later on in the same file, just like macros.

It's possible to use =defmacro= to define a macro to expand into the same code that an inline function would execute (see [[file:///home/gaowei/Desktop/elisp-manual.html#Macros][Macros]]). But the macro would be limited to direct use in expressions---a macro cannot be called with =apply=, =mapcar= and so on. Also, it takes some work to convert an ordinary function into a macro. To convert it into an inline function is easy; just replace =defun= with =defsubst=. Since each argument of an inline function is evaluated exactly once, you needn't worry about how many times the body uses the arguments, as you do for macros.

As an alternative to =defsubst=, you can use =define-inline= to define functions via their exhaustive compiler macro. See [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][define-inline]].

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Declaring-Functions][Declaring Functions]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Inline-Functions][Inline Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.14 The =declare= Form
    :PROPERTIES:
    :CUSTOM_ID: the-declare-form
    :END:

=declare= is a special macro which can be used to add meta properties to a function or macro: for example, marking it as obsolete, or giving its forms a special indentation convention in Emacs Lisp mode.

--- Macro: *declare* specs...

#+BEGIN_QUOTE
  This macro ignores its arguments and evaluates to =nil=; it has no run-time effect. However, when a =declare= form occurs in the declare argument of a =defun= or =defsubst= function definition (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Functions][Defining Functions]]) or a =defmacro= macro definition (see [[file:///home/gaowei/Desktop/elisp-manual.html#Defining-Macros][Defining Macros]]), it appends the properties specified by specs to the function or macro. This work is specially performed by =defun=, =defsubst=, and =defmacro=.

  Each element in specs should have the form =(=property args=...)=, which should not be quoted. These have the following effects:

  - =(advertised-calling-convention=signature when=)=

    This acts like a call to =set-advertised-calling-convention= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]]); signature specifies the correct argument list for calling the function or macro, and when should be a string indicating when the old argument list was first made obsolete.

  - =(debug=edebug-form-spec=)=

    This is valid for macros only. When stepping through the macro with Edebug, use edebug-form-spec. See [[file:///home/gaowei/Desktop/elisp-manual.html#Instrumenting-Macro-Calls][Instrumenting Macro Calls]].

  - =(doc-string=n=)=

    This is used when defining a function or macro which itself will be used to define entities like functions, macros, or variables. It indicates that the nth argument, if any, should be considered as a documentation string.

  - =(indent=indent-spec=)=

    Indent calls to this function or macro according to indent-spec. This is typically used for macros, though it works for functions too. See [[file:///home/gaowei/Desktop/elisp-manual.html#Indenting-Macros][Indenting Macros]].

  - =(interactive-only=value=)=

    Set the function's =interactive-only= property to value. See [[file:///home/gaowei/Desktop/elisp-manual.html#The-interactive_002donly-property][The interactive-only property]].

  - =(obsolete=current-name when=)=

    Mark the function or macro as obsolete, similar to a call to =make-obsolete= (see [[file:///home/gaowei/Desktop/elisp-manual.html#Obsolete-Functions][Obsolete Functions]]). current-name should be a symbol (in which case the warning message says to use that instead), a string (specifying the warning message), or =nil= (in which case the warning message gives no extra details). when should be a string indicating when the function or macro was first made obsolete.

  - =(compiler-macro=expander=)=

    This can only be used for functions, and tells the compiler to use expander as an optimization function. When encountering a call to the function, of the form =(=function args=...)=, the macro expander will call expander with that form as well as with args..., and expander can either return a new expression to use instead of the function call, or it can return just the form unchanged, to indicate that the function call should be left alone. expander can be a symbol, or it can be a form =(lambda (=arg=)=body=)= in which case arg will hold the original function call expression, and the (unevaluated) arguments to the function can be accessed using the function's formal arguments.

  - =(gv-expander=expander=)=

    Declare expander to be the function to handle calls to the macro (or function) as a generalized variable, similarly to =gv-define-expander=. expander can be a symbol or it can be of the form =(lambda (=arg=)=body=)= in which case that function will additionally have access to the macro (or function)'s arguments.

  - =(gv-setter=setter=)=

    Declare setter to be the function to handle calls to the macro (or function) as a generalized variable. setter can be a symbol in which case it will be passed to =gv-define-simple-setter=, or it can be of the form =(lambda (=arg=)=body=)= in which case that function will additionally have access to the macro (or function)'s arguments and it will passed to =gv-define-setter=.

#+END_QUOTE

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Safety][Function Safety]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Declare-Form][Declare Form]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.15 Telling the Compiler that a Function is Defined
    :PROPERTIES:
    :CUSTOM_ID: telling-the-compiler-that-a-function-is-defined
    :END:

Byte-compiling a file often produces warnings about functions that the compiler doesn't know about (see [[file:///home/gaowei/Desktop/elisp-manual.html#Compiler-Errors][Compiler Errors]]). Sometimes this indicates a real problem, but usually the functions in question are defined in other files which would be loaded if that code is run. For example, byte-compiling simple.el used to warn:

#+BEGIN_EXAMPLE
         simple.el:8727:1:Warning: the function ‘shell-mode’ is not known to be
             defined.
#+END_EXAMPLE

In fact, =shell-mode= is used only in a function that executes =(require 'shell)= before calling =shell-mode=, so =shell-mode= will be defined properly at run-time. When you know that such a warning does not indicate a real problem, it is good to suppress the warning. That makes new warnings which might mean real problems more visible. You do that with =declare-function=.

All you need to do is add a =declare-function= statement before the first use of the function in question:

#+BEGIN_EXAMPLE
         (declare-function shell-mode "shell" ())
#+END_EXAMPLE

This says that =shell-mode= is defined in shell.el (the '.el' can be omitted). The compiler takes for granted that that file really defines the function, and does not check.

The optional third argument specifies the argument list of =shell-mode=. In this case, it takes no arguments (=nil= is different from not specifying a value). In other cases, this might be something like =(file &optional overwrite)=. You don't have to specify the argument list, but if you do the byte compiler can check that the calls match the declaration.

--- Macro: *declare-function* function file &optional arglist fileonly

#+BEGIN_QUOTE
  Tell the byte compiler to assume that function is defined in the file file. The optional third argument arglist is either =t=, meaning the argument list is unspecified, or a list of formal parameters in the same style as =defun=. An omitted arglist defaults to =t=, not =nil=; this is atypical behavior for omitted arguments, and it means that to supply a fourth but not third argument one must specify =t= for the third-argument placeholder instead of the usual =nil=. The optional fourth argument fileonly non-=nil= means check only that file exists, not that it actually defines function.
#+END_QUOTE

To verify that these functions really are declared where =declare-function= says they are, use =check-declare-file= to check all =declare-function= calls in one source file, or use =check-declare-directory= check all the files in and under a certain directory.

These commands find the file that ought to contain a function's definition using =locate-library=; if that finds no file, they expand the definition file name relative to the directory of the file that contains the =declare-function= call.

You can also say that a function is a primitive by specifying a file name ending in '.c' or '.m'. This is useful only when you call a primitive that is defined only on certain systems. Most primitives are always defined, so they will never give you a warning.

Sometimes a file will optionally use functions from an external package. If you prefix the filename in the =declare-function= statement with 'ext:', then it will be checked if it is found, otherwise skipped without error.

There are some function definitions that 'check-declare' does not understand (e.g., =defstruct= and some other macros). In such cases, you can pass a non-=nil= fileonly argument to =declare-function=, meaning to only check that the file exists, not that it actually defines the function. Note that to do this without having to specify an argument list, you should set the arglist argument to =t= (because =nil= means an empty argument list, as opposed to an unspecified one).

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Related-Topics][Related Topics]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Declaring-Functions][Declaring Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.16 Determining whether a Function is Safe to Call
    :PROPERTIES:
    :CUSTOM_ID: determining-whether-a-function-is-safe-to-call
    :END:

Some major modes, such as SES, call functions that are stored in user files. (see [[https://www.gnu.org/software/emacs/manual/html_mono/ses.html#Top][Top]], for more information on SES.) User files sometimes have poor pedigrees---you can get a spreadsheet from someone you've just met, or you can get one through email from someone you've never met. So it is risky to call a function whose source code is stored in a user file until you have determined that it is safe.

--- Function: *unsafep* form &optional unsafep-vars

#+BEGIN_QUOTE
  Returns =nil= if form is a safe Lisp expression, or returns a list that describes why it might be unsafe. The argument unsafep-vars is a list of symbols known to have temporary bindings at this point; it is mainly used for internal recursive calls. The current buffer is an implicit argument, which provides a list of buffer-local bindings.
#+END_QUOTE

Being quick and simple, =unsafep= does a very light analysis and rejects many Lisp expressions that are actually safe. There are no known cases where =unsafep= returns =nil= for an unsafe expression. However, a safe Lisp expression can return a string with a =display= property, containing an associated Lisp expression to be executed after the string is inserted into a buffer. This associated expression can be a virus. In order to be safe, you must delete properties from all strings calculated by user code before inserting them into buffers.

Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Safety][Function Safety]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]]

** 13.17 Other Topics Related to Functions
    :PROPERTIES:
    :CUSTOM_ID: other-topics-related-to-functions
    :END:

Here is a table of several functions that do things related to function calling and function definitions. They are documented elsewhere, but we provide cross references here.

- =apply=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]].

- =autoload=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Autoload][Autoload]].

- =call-interactively=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]].

- =called-interactively-p=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Distinguish-Interactive][Distinguish Interactive]].

- =commandp=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Interactive-Call][Interactive Call]].

- =documentation=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Accessing-Documentation][Accessing Documentation]].

- =eval=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Eval][Eval]].

- =funcall=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]].

- =function=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Anonymous-Functions][Anonymous Functions]].

- =ignore=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Calling-Functions][Calling Functions]].

- =indirect-function=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Function-Indirection][Function Indirection]].

- =interactive=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Using-Interactive][Using Interactive]].

- =interactive-p=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Distinguish-Interactive][Distinguish Interactive]].

- =mapatoms=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Creating-Symbols][Creating Symbols]].

- =mapcar=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]].

- =map-char-table=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Char_002dTables][Char-Tables]].

- =mapconcat=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Mapping-Functions][Mapping Functions]].

- =undefined=

  See [[file:///home/gaowei/Desktop/elisp-manual.html#Functions-for-Key-Lookup][Functions for Key Lookup]].

Next: [[file:///home/gaowei/Desktop/elisp-manual.html#Customization][Customization]], Previous: [[file:///home/gaowei/Desktop/elisp-manual.html#Functions][Functions]], Up: [[file:///home/gaowei/Desktop/elisp-manual.html#Top][Top]]

* 14 Macros
Macros enable you to define new control constructs and other language features. A macro is defined much like a function, but instead of telling how to compute a value, it tells how to compute another Lisp expression which will in turn compute the value. We call this expression the expansion of the macro.

Macros can do this because they operate on the unevaluated expressions for the arguments, not on the argument values as functions do. They can therefore construct an expansion containing these argument expressions or parts of them.

If you are using a macro to do something an ordinary function could do, just for the sake of speed, consider using an inline function instead. See Inline Functions.

1. Simple Macro: A basic example.
2. Expansion: How, when and why macros are expanded.
3. Compiling Macros: How macros are expanded by the compiler.
4. Defining Macros: How to write a macro definition.
5. Problems with Macros: Don't evaluate the macro arguments too many times. Don't hide the user's variables.
6. Indenting Macros: Specifying how to indent macro calls.


* 15 Customization Settings
Users of Emacs can customize variables and faces without writing Lisp code, by using the Customize interface. See Easy Customization. This chapter describes how to define customization items that users can interact with through the Customize interface.

Customization items include customizable variables, which are defined with the defcustom macro; customizable faces, which are defined with defface (described separately in Defining Faces); and customization groups, defined with defgroup, which act as containers for groups of related customization items.

1. Common Keywords: Common keyword arguments for all kinds of customization declarations.
2. Group Definitions: Writing customization group definitions.
3. Variable Definitions: Declaring user options.
4. Customization Types: Specifying the type of a user option.
5. Applying Customizations: Functions to apply customization settings.
6. Custom Themes: Writing Custom themes.

* 16 Loading
Loading a file of Lisp code means bringing its contents into the Lisp environment in the form of Lisp objects. Emacs finds and opens the file, reads the text, evaluates each form, and then closes the file. Such a file is also called a Lisp library.

The load functions evaluate all the expressions in a file just as the eval-buffer function evaluates all the expressions in a buffer. The difference is that the load functions read and evaluate the text in the file as found on disk, not the text in an Emacs buffer.

The loaded file must contain Lisp expressions, either as source code or as byte-compiled code. Each form in the file is called a top-level form. There is no special format for the forms in a loadable file; any form in a file may equally well be typed directly into a buffer and evaluated there. (Indeed, most code is tested this way.) Most often, the forms are function definitions and variable definitions.

Emacs can also load compiled dynamic modules: shared libraries that provide additional functionality for use in Emacs Lisp programs, just like a package written in Emacs Lisp would. When a dynamic module is loaded, Emacs calls a specially-named initialization function which the module needs to implement, and which exposes the additional functions and variables to Emacs Lisp programs.

For on-demand loading of external libraries which are known in advance to be required by certain Emacs primitives, see Dynamic Libraries.

1. How Programs Do Loading: The load function and others.
2. Load Suffixes: Details about the suffixes that load tries.
3. Library Search: Finding a library to load.
4. Loading Non-ASCII: Non-ASCII characters in Emacs Lisp files.
5. Autoload: Setting up a function to autoload.
6. Repeated Loading: Precautions about loading a file twice.
7. Named Features: Loading a library if it isn't already loaded.
8. Where Defined: Finding which file defined a certain symbol.
9. Unloading: How to unload a library that was loaded.
10. Hooks for Loading: Providing code to be run when particular libraries are loaded.
11. Dynamic Modules: Modules provide additional Lisp primitives.
* 17 Byte Compilation
Emacs Lisp has a compiler that translates functions written in Lisp into a special representation called byte-code that can be executed more efficiently. The compiler replaces Lisp function definitions with byte-code. When a byte-code function is called, its definition is evaluated by the byte-code interpreter.

Because the byte-compiled code is evaluated by the byte-code interpreter, instead of being executed directly by the machine's hardware (as true compiled code is), byte-code is completely transportable from machine to machine without recompilation. It is not, however, as fast as true compiled code.

In general, any version of Emacs can run byte-compiled code produced by recent earlier versions of Emacs, but the reverse is not true.

If you do not want a Lisp file to be compiled, ever, put a file-local variable binding for no-byte-compile into it, like this:

     ;; -*-no-byte-compile: t; -*-

1. Speed of Byte-Code: An example of speedup from byte compilation.
2. Compilation Functions: Byte compilation functions.
3. Docs and Compilation: Dynamic loading of documentation strings.
4. Dynamic Loading: Dynamic loading of individual functions.
5. Eval During Compile: Code to be evaluated when you compile.
6. Compiler Errors: Handling compiler error messages.
7. Byte-Code Objects: The data type used for byte-compiled functions.
8. Disassembly: Disassembling byte-code; how to read byte-code.
* 18 Debugging Lisp Programs
There are several ways to find and investigate problems in an Emacs Lisp program.

1) If a problem occurs when you run the program, you can use the built-in Emacs Lisp debugger to suspend the Lisp evaluator, and examine and/or alter its internal state.
2) You can use Edebug, a source-level debugger for Emacs Lisp.
3) You can trace the execution of functions involved in the problem using the tracing facilities provided by the trace.el package. This package provides the functions trace-function-foreground and trace-function-background for tracing function calls, and trace-values for adding values of select variables to the trace. For the details, see the documentation of these facilities in trace.el.
4) If a syntactic problem is preventing Lisp from even reading the program, you can locate it using Lisp editing commands.
5) You can look at the error and warning messages produced by the byte compiler when it compiles the program. See Compiler Errors.
6) You can use the Testcover package to perform coverage testing on the program.
7) You can use the ERT package to write regression tests for the program. See the ERT manual.
8) You can profile the program to get hints about how to make it more efficient.
Other useful tools for debugging input and output problems are the dribble file (see Terminal Input) and the open-termscript function (see Terminal Output).

1. Debugger: A debugger for the Emacs Lisp evaluator.
2. Edebug: A source-level Emacs Lisp debugger.
3. Syntax Errors: How to find syntax errors.
4. Test Coverage: Ensuring you have tested all branches in your code.
5. Profiling: Measuring the resources that your code uses.
* 19 Reading and Printing Lisp Objects
Printing and reading are the operations of converting Lisp objects to textual form and vice versa. They use the printed representations and read syntax described in Lisp Data Types.

This chapter describes the Lisp functions for reading and printing. It also describes streams, which specify where to get the text (if reading) or where to put it (if printing).

** 1. Streams Intro: Overview of streams, reading and printing.
Reading a Lisp object means parsing a Lisp expression in textual form and producing a corresponding Lisp object. This is how Lisp programs get into Lisp from files of Lisp code. We call the text the read syntax of the object. For example, the text ‘(a . 5)’ is the read syntax for a cons cell whose car is a and whose cdr is the number 5.

Printing a Lisp object means producing text that represents that object—converting the object to its printed representation (see Printed Representation). Printing the cons cell described above produces the text ‘(a . 5)’.

Reading and printing are more or less inverse operations: printing the object that results from reading a given piece of text often produces the same text, and reading the text that results from printing an object usually produces a similar-looking object. For example, printing the symbol foo produces the text ‘foo’, and reading that text returns the symbol foo. Printing a list whose elements are a and b produces the text ‘(a b)’, and reading that text produces a list (but not the same list) with elements a and b.

However, these two operations are not precisely inverse to each other. There are three kinds of exceptions:

Printing can produce text that cannot be read. For example, buffers, windows, frames, subprocesses and markers print as text that starts with ‘#’; if you try to read this text, you get an error. There is no way to read those data types.
One object can have multiple textual representations. For example, ‘1’ and ‘01’ represent the same integer, and ‘(a b)’ and ‘(a . (b))’ represent the same list. Reading will accept any of the alternatives, but printing must choose one of them.
Comments can appear at certain points in the middle of an object's read sequence without affecting the result of reading it.
** 2. Input Streams: Various data types that can be used as input streams.
19.2 Input Streams
Most of the Lisp functions for reading text take an input stream as an argument. The input stream specifies where or how to get the characters of the text to be read. Here are the possible types of input stream:

buffer
The input characters are read from buffer, starting with the character directly after point. Point advances as characters are read.
marker
The input characters are read from the buffer that marker is in, starting with the character directly after the marker. The marker position advances as characters are read. The value of point in the buffer has no effect when the stream is a marker.
string
The input characters are taken from string, starting at the first character in the string and using as many characters as required.
function
The input characters are generated by function, which must support two kinds of calls:
When it is called with no arguments, it should return the next character.
When it is called with one argument (always a character), function should save the argument and arrange to return it on the next call. This is called unreading the character; it happens when the Lisp reader reads one character too many and wants to put it back where it came from. In this case, it makes no difference what value function returns.

t
t used as a stream means that the input is read from the minibuffer. In fact, the minibuffer is invoked once and the text given by the user is made into a string that is then used as the input stream. If Emacs is running in batch mode, standard input is used instead of the minibuffer. For example,
          (message "%s" (read t))
will read a Lisp expression from standard input and print the result to standard output.

nil
nil supplied as an input stream means to use the value of standard-input instead; that value is the default input stream, and must be a non-nil input stream.
symbol
A symbol as input stream is equivalent to the symbol's function definition (if any).
Here is an example of reading from a stream that is a buffer, showing where point is located before and after:

     ---------- Buffer: foo ----------
     This-!- is the contents of foo.
     ---------- Buffer: foo ----------

     (read (get-buffer "foo"))
          ⇒ is
     (read (get-buffer "foo"))
          ⇒ the

     ---------- Buffer: foo ----------
     This is the-!- contents of foo.
     ---------- Buffer: foo ----------
Note that the first read skips a space. Reading skips any amount of whitespace preceding the significant text.

Here is an example of reading from a stream that is a marker, initially positioned at the beginning of the buffer shown. The value read is the symbol This.


     ---------- Buffer: foo ----------
     This is the contents of foo.
     ---------- Buffer: foo ----------

     (setq m (set-marker (make-marker) 1 (get-buffer "foo")))
          ⇒ #<marker at 1 in foo>
     (read m)
          ⇒ This
     m
          ⇒ #<marker at 5 in foo>   ;; Before the first space.
Here we read from the contents of a string:

     (read "(When in) the course")
          ⇒ (When in)
The following example reads from the minibuffer. The prompt is: ‘Lisp expression: ’. (That is always the prompt used when you read from the stream t.) The user's input is shown following the prompt.

     (read t)
          ⇒ 23
     ---------- Buffer: Minibuffer ----------
     Lisp expression: 23 <RET>
     ---------- Buffer: Minibuffer ----------
Finally, here is an example of a stream that is a function, named useless-stream. Before we use the stream, we initialize the variable useless-list to a list of characters. Then each call to the function useless-stream obtains the next character in the list or unreads a character by adding it to the front of the list.

     (setq useless-list (append "XY()" nil))
          ⇒ (88 89 40 41)

     (defun useless-stream (&optional unread)
       (if unread
           (setq useless-list (cons unread useless-list))
         (prog1 (car useless-list)
                (setq useless-list (cdr useless-list)))))
          ⇒ useless-stream
Now we read using the stream thus constructed:

     (read 'useless-stream)
          ⇒ XY

     useless-list
          ⇒ (40 41)
Note that the open and close parentheses remain in the list. The Lisp reader encountered the open parenthesis, decided that it ended the input, and unread it. Another attempt to read from the stream at this point would read ‘()’ and return nil.
** 3. Input Functions: Functions to read Lisp objects from text.
This section describes the Lisp functions and variables that pertain to reading.

In the functions below, stream stands for an input stream (see the previous section). If stream is nil or omitted, it defaults to the value of standard-input.

An end-of-file error is signaled if reading encounters an unterminated list, vector, or string.

— Function: read &optional stream
This function reads one textual Lisp expression from stream, returning it as a Lisp object. This is the basic Lisp input function.

— Function: read-from-string string &optional start end
This function reads the first textual Lisp expression from the text in string. It returns a cons cell whose car is that expression, and whose cdr is an integer giving the position of the next remaining character in the string (i.e., the first one not read).

If start is supplied, then reading begins at index start in the string (where the first character is at index 0). If you specify end, then reading is forced to stop just before that index, as if the rest of the string were not there.

For example:

          (read-from-string "(setq x 55) (setq y 5)")
               ⇒ ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               ⇒ ("A short string" . 16)

          ;; Read starting at the first character.
          (read-from-string "(list 112)" 0)
               ⇒ ((list 112) . 10)
          ;; Read starting at the second character.
          (read-from-string "(list 112)" 1)
               ⇒ (list . 5)
          ;; Read starting at the seventh character,
          ;;   and stopping at the ninth.
          (read-from-string "(list 112)" 6 8)
               ⇒ (11 . 8)
— Variable: standard-input
This variable holds the default input stream—the stream that read uses when the stream argument is nil. The default is t, meaning use the minibuffer.

— Variable: read-circle
If non-nil, this variable enables the reading of circular and shared structures. See Circular Objects. Its default value is t.

When reading or writing from the standard input/output streams of the Emacs process in batch mode, it is sometimes required to make sure any arbitrary binary data will be read/written verbatim, and/or that no translation of newlines to or from CR-LF pairs is performed. This issue does not exist on POSIX hosts, only on MS-Windows and MS-DOS. The following function allows you to control the I/O mode of any standard stream of the Emacs process.

— Function: set-binary-mode stream mode
Switch stream into binary or text I/O mode. If mode is non-nil, switch to binary mode, otherwise switch to text mode. The value of stream can be one of stdin, stdout, or stderr. This function flushes any pending output data of stream as a side effect, and returns the previous value of I/O mode for stream. On POSIX hosts, it always returns a non-nil value and does nothing except flushing pending output.

** 4. Output Streams: Various data types that can be used as output streams.
19.3 Input Functions
This section describes the Lisp functions and variables that pertain to reading.

In the functions below, stream stands for an input stream (see the previous section). If stream is nil or omitted, it defaults to the value of standard-input.

An end-of-file error is signaled if reading encounters an unterminated list, vector, or string.

— Function: read &optional stream
This function reads one textual Lisp expression from stream, returning it as a Lisp object. This is the basic Lisp input function.

— Function: read-from-string string &optional start end
This function reads the first textual Lisp expression from the text in string. It returns a cons cell whose car is that expression, and whose cdr is an integer giving the position of the next remaining character in the string (i.e., the first one not read).

If start is supplied, then reading begins at index start in the string (where the first character is at index 0). If you specify end, then reading is forced to stop just before that index, as if the rest of the string were not there.

For example:

          (read-from-string "(setq x 55) (setq y 5)")
               ⇒ ((setq x 55) . 11)
          (read-from-string "\"A short string\"")
               ⇒ ("A short string" . 16)

          ;; Read starting at the first character.
          (read-from-string "(list 112)" 0)
               ⇒ ((list 112) . 10)
          ;; Read starting at the second character.
          (read-from-string "(list 112)" 1)
               ⇒ (list . 5)
          ;; Read starting at the seventh character,
          ;;   and stopping at the ninth.
          (read-from-string "(list 112)" 6 8)
               ⇒ (11 . 8)
— Variable: standard-input
This variable holds the default input stream—the stream that read uses when the stream argument is nil. The default is t, meaning use the minibuffer.

— Variable: read-circle
If non-nil, this variable enables the reading of circular and shared structures. See Circular Objects. Its default value is t.

When reading or writing from the standard input/output streams of the Emacs process in batch mode, it is sometimes required to make sure any arbitrary binary data will be read/written verbatim, and/or that no translation of newlines to or from CR-LF pairs is performed. This issue does not exist on POSIX hosts, only on MS-Windows and MS-DOS. The following function allows you to control the I/O mode of any standard stream of the Emacs process.

— Function: set-binary-mode stream mode
Switch stream into binary or text I/O mode. If mode is non-nil, switch to binary mode, otherwise switch to text mode. The value of stream can be one of stdin, stdout, or stderr. This function flushes any pending output data of stream as a side effect, and returns the previous value of I/O mode for stream. On POSIX hosts, it always returns a non-nil value and does nothing except flushing pending output.

Next: Output Functions, Previous: Input Functions, Up: Read and Print

19.4 Output Streams
An output stream specifies what to do with the characters produced by printing. Most print functions accept an output stream as an optional argument. Here are the possible types of output stream:

buffer
The output characters are inserted into buffer at point. Point advances as characters are inserted.
marker
The output characters are inserted into the buffer that marker points into, at the marker position. The marker position advances as characters are inserted. The value of point in the buffer has no effect on printing when the stream is a marker, and this kind of printing does not move point (except that if the marker points at or before the position of point, point advances with the surrounding text, as usual).
function
The output characters are passed to function, which is responsible for storing them away. It is called with a single character as argument, as many times as there are characters to be output, and is responsible for storing the characters wherever you want to put them.
t
The output characters are displayed in the echo area.
nil
nil specified as an output stream means to use the value of standard-output instead; that value is the default output stream, and must not be nil.
symbol
A symbol as output stream is equivalent to the symbol's function definition (if any).
Many of the valid output streams are also valid as input streams. The difference between input and output streams is therefore more a matter of how you use a Lisp object, than of different types of object.

Here is an example of a buffer used as an output stream. Point is initially located as shown immediately before the ‘h’ in ‘the’. At the end, point is located directly before that same ‘h’.


     ---------- Buffer: foo ----------
     This is t-!-he contents of foo.
     ---------- Buffer: foo ----------

     (print "This is the output" (get-buffer "foo"))
          ⇒ "This is the output"

     ---------- Buffer: foo ----------
     This is t
     "This is the output"
     -!-he contents of foo.
     ---------- Buffer: foo ----------
Now we show a use of a marker as an output stream. Initially, the marker is in buffer foo, between the ‘t’ and the ‘h’ in the word ‘the’. At the end, the marker has advanced over the inserted text so that it remains positioned before the same ‘h’. Note that the location of point, shown in the usual fashion, has no effect.

     ---------- Buffer: foo ----------
     This is the -!-output
     ---------- Buffer: foo ----------

     (setq m (copy-marker 10))
          ⇒ #<marker at 10 in foo>

     (print "More output for foo." m)
          ⇒ "More output for foo."

     ---------- Buffer: foo ----------
     This is t
     "More output for foo."
     he -!-output
     ---------- Buffer: foo ----------

     m
          ⇒ #<marker at 34 in foo>
The following example shows output to the echo area:

     (print "Echo Area output" t)
          ⇒ "Echo Area output"
     ---------- Echo Area ----------
     "Echo Area output"
     ---------- Echo Area ----------
Finally, we show the use of a function as an output stream. The function eat-output takes each character that it is given and conses it onto the front of the list last-output (see Building Lists). At the end, the list contains all the characters output, but in reverse order.

     (setq last-output nil)
          ⇒ nil

     (defun eat-output (c)
       (setq last-output (cons c last-output)))
          ⇒ eat-output

     (print "This is the output" #'eat-output)
          ⇒ "This is the output"

     last-output
          ⇒ (10 34 116 117 112 116 117 111 32 101 104
         116 32 115 105 32 115 105 104 84 34 10)
Now we can put the output in the proper order by reversing the list:

     (concat (nreverse last-output))
          ⇒ "
     \"This is the output\"
     "
Calling concat converts the list to a string so you can see its contents more clearly.


— Function: external-debugging-output character
This function can be useful as an output stream when debugging. It writes character to the standard error stream.

For example

          (print "This is the output" #'external-debugging-output)
          -| This is the output
          ⇒ "This is the output"

** 5. Output Functions: Functions to print Lisp objects as text.
This section describes the Lisp functions for printing Lisp objects—converting objects into their printed representation.

Some of the Emacs printing functions add quoting characters to the output when necessary so that it can be read properly. The quoting characters used are ‘"’ and ‘\’; they distinguish strings from symbols, and prevent punctuation characters in strings and symbols from being taken as delimiters when reading. See Printed Representation, for full details. You specify quoting or no quoting by the choice of printing function.

If the text is to be read back into Lisp, then you should print with quoting characters to avoid ambiguity. Likewise, if the purpose is to describe a Lisp object clearly for a Lisp programmer. However, if the purpose of the output is to look nice for humans, then it is usually better to print without quoting.

Lisp objects can refer to themselves. Printing a self-referential object in the normal way would require an infinite amount of text, and the attempt could cause infinite recursion. Emacs detects such recursion and prints ‘#level’ instead of recursively printing an object already being printed. For example, here ‘#0’ indicates a recursive reference to the object at level 0 of the current print operation:

     (setq foo (list nil))
          ⇒ (nil)
     (setcar foo foo)
          ⇒ (#0)
In the functions below, stream stands for an output stream. (See the previous section for a description of output streams. Also See external-debugging-output, a useful stream value for debugging.) If stream is nil or omitted, it defaults to the value of standard-output.

— Function: print object &optional stream
The print function is a convenient way of printing. It outputs the printed representation of object to stream, printing in addition one newline before object and another after it. Quoting characters are used. print returns object. For example:

          (progn (print 'The\ cat\ in)
                 (print "the hat")
                 (print " came back"))
               -|
               -| The\ cat\ in
               -|
               -| "the hat"
               -|
               -| " came back"
               ⇒ " came back"
— Function: prin1 object &optional stream
This function outputs the printed representation of object to stream. It does not print newlines to separate output as print does, but it does use quoting characters just like print. It returns object.

          (progn (prin1 'The\ cat\ in)
                 (prin1 "the hat")
                 (prin1 " came back"))
               -| The\ cat\ in"the hat"" came back"
               ⇒ " came back"
— Function: princ object &optional stream
This function outputs the printed representation of object to stream. It returns object.

This function is intended to produce output that is readable by people, not by read, so it doesn't insert quoting characters and doesn't put double-quotes around the contents of strings. It does not add any spacing between calls.

          (progn
            (princ 'The\ cat)
            (princ " in the \"hat\""))
               -| The cat in the "hat"
               ⇒ " in the \"hat\""
— Function: terpri &optional stream ensure
This function outputs a newline to stream. The name stands for “terminate print”. If ensure is non-nil no newline is printed if stream is already at the beginning of a line. Note in this case stream can not be a function and an error is signaled if it is. This function returns t if a newline is printed.

— Function: write-char character &optional stream
This function outputs character to stream. It returns character.

— Function: prin1-to-string object &optional noescape
This function returns a string containing the text that prin1 would have printed for the same argument.

          (prin1-to-string 'foo)
               ⇒ "foo"
          (prin1-to-string (mark-marker))
               ⇒ "#<marker at 2773 in strings.texi>"
If noescape is non-nil, that inhibits use of quoting characters in the output. (This argument is supported in Emacs versions 19 and later.)

          (prin1-to-string "foo")
               ⇒ "\"foo\""
          (prin1-to-string "foo" t)
               ⇒ "foo"
See format, in Formatting Strings, for other ways to obtain the printed representation of a Lisp object as a string.

— Macro: with-output-to-string body...
This macro executes the body forms with standard-output set up to feed output into a string. Then it returns that string.

For example, if the current buffer name is ‘foo’,

          (with-output-to-string
            (princ "The buffer is ")
            (princ (buffer-name)))
returns "The buffer is foo".

— Function: pp object &optional stream
This function outputs object to stream, just like prin1, but does it in a prettier way. That is, it'll indent and fill the object to make it more readable for humans.

If you need to use binary I/O in batch mode, e.g., use the functions described in this section to write out arbitrary binary data or avoid conversion of newlines on non-POSIX hosts, see set-binary-mode.

** 6. Output Variables: Variables that control what the printing functions do.
— Variable: standard-output
The value of this variable is the default output stream—the stream that print functions use when the stream argument is nil. The default is t, meaning display in the echo area.

— Variable: print-quoted
If this is non-nil, that means to print quoted forms using abbreviated reader syntax, e.g., (quote foo) prints as 'foo, and (function foo) as #'foo.

— Variable: print-escape-newlines
If this variable is non-nil, then newline characters in strings are printed as ‘\n’ and formfeeds are printed as ‘\f’. Normally these characters are printed as actual newlines and formfeeds.

This variable affects the print functions prin1 and print that print with quoting. It does not affect princ. Here is an example using prin1:

          (prin1 "a\nb")
               -| "a
               -| b"
               ⇒ "a
          b"

          (let ((print-escape-newlines t))
            (prin1 "a\nb"))
               -| "a\nb"
               ⇒ "a
          b"
In the second expression, the local binding of print-escape-newlines is in effect during the call to prin1, but not during the printing of the result.

— Variable: print-escape-control-characters
If this variable is non-nil, control characters in strings are printed as backslash sequences by the print functions prin1 and print that print with quoting. If this variable and print-escape-newlines are both non-nil, the latter takes precedences for newlines and formfeeds.

— Variable: print-escape-nonascii
If this variable is non-nil, then unibyte non-ASCII characters in strings are unconditionally printed as backslash sequences by the print functions prin1 and print that print with quoting.

Those functions also use backslash sequences for unibyte non-ASCII characters, regardless of the value of this variable, when the output stream is a multibyte buffer or a marker pointing into one.

— Variable: print-escape-multibyte
If this variable is non-nil, then multibyte non-ASCII characters in strings are unconditionally printed as backslash sequences by the print functions prin1 and print that print with quoting.

Those functions also use backslash sequences for multibyte non-ASCII characters, regardless of the value of this variable, when the output stream is a unibyte buffer or a marker pointing into one.

— Variable: print-length
The value of this variable is the maximum number of elements to print in any list, vector or bool-vector. If an object being printed has more than this many elements, it is abbreviated with an ellipsis.

If the value is nil (the default), then there is no limit.

          (setq print-length 2)
               ⇒ 2
          (print '(1 2 3 4 5))
               -| (1 2 ...)
               ⇒ (1 2 ...)
— Variable: print-level
The value of this variable is the maximum depth of nesting of parentheses and brackets when printed. Any list or vector at a depth exceeding this limit is abbreviated with an ellipsis. A value of nil (which is the default) means no limit.

— User Option: eval-expression-print-length
— User Option: eval-expression-print-level
These are the values for print-length and print-level used by eval-expression, and thus, indirectly, by many interactive evaluation commands (see Evaluating Emacs-Lisp Expressions).

These variables are used for detecting and reporting circular and shared structure:

— Variable: print-circle
If non-nil, this variable enables detection of circular and shared structure in printing. See Circular Objects.

— Variable: print-gensym
If non-nil, this variable enables detection of uninterned symbols (see Creating Symbols) in printing. When this is enabled, uninterned symbols print with the prefix ‘#:’, which tells the Lisp reader to produce an uninterned symbol.

— Variable: print-continuous-numbering
If non-nil, that means number continuously across print calls. This affects the numbers printed for ‘#n=’ labels and ‘#m#’ references. Don't set this variable with setq; you should only bind it temporarily to t with let. When you do that, you should also bind print-number-table to nil.

— Variable: print-number-table
This variable holds a vector used internally by printing to implement the print-circle feature. You should not use it except to bind it to nil when you bind print-continuous-numbering.

— Variable: float-output-format
This variable specifies how to print floating-point numbers. The default is nil, meaning use the shortest output that represents the number without losing information.

To control output format more precisely, you can put a string in this variable. The string should hold a ‘%’-specification to be used in the C function sprintf. For further restrictions on what you can use, see the variable's documentation string.
* 20.Minibuffer
Completion is a feature that fills in the rest of a name starting from an abbreviation for it. Completion works by comparing the user's input against a list of valid names and determining how much of the name is determined uniquely by what the user has typed. For example, when you type C-x b (switch-to-buffer) and then type the first few letters of the name of the buffer to which you wish to switch, and then type <TAB> (minibuffer-complete), Emacs extends the name as far as it can.

Standard Emacs commands offer completion for names of symbols, files, buffers, and processes; with the functions in this section, you can implement completion for other kinds of names.

The try-completion function is the basic primitive for completion: it returns the longest determined completion of a given initial string, with a given set of strings to match against.

The function completing-read provides a higher-level interface for completion. A call to completing-read specifies how to determine the list of valid names. The function then activates the minibuffer with a local keymap that binds a few keys to commands useful for completion. Other functions provide convenient simple interfaces for reading certain kinds of names with completion.

** 1. Basic Completion: Low-level functions for completing strings.
The following completion functions have nothing in themselves to do with minibuffers. We describe them here to keep them near the higher-level completion features that do use the minibuffer.

— Function: try-completion string collection &optional predicate
This function returns the longest common substring of all possible completions of string in collection.

collection is called the completion table. Its value must be a list of strings or cons cells, an obarray, a hash table, or a completion function.

try-completion compares string against each of the permissible completions specified by the completion table. If no permissible completions match, it returns nil. If there is just one matching completion, and the match is exact, it returns t. Otherwise, it returns the longest initial sequence common to all possible matching completions.

If collection is a list, the permissible completions are specified by the elements of the list, each of which should be either a string, or a cons cell whose car is either a string or a symbol (a symbol is converted to a string using symbol-name). If the list contains elements of any other type, those are ignored.

If collection is an obarray (see Creating Symbols), the names of all symbols in the obarray form the set of permissible completions.

If collection is a hash table, then the keys that are strings or symbols are the possible completions. Other keys are ignored.

You can also use a function as collection. Then the function is solely responsible for performing completion; try-completion returns whatever this function returns. The function is called with three arguments: string, predicate and nil (the third argument is so that the same function can be used in all-completions and do the appropriate thing in either case). See Programmed Completion.

If the argument predicate is non-nil, then it must be a function of one argument, unless collection is a hash table, in which case it should be a function of two arguments. It is used to test each possible match, and the match is accepted only if predicate returns non-nil. The argument given to predicate is either a string or a cons cell (the car of which is a string) from the alist, or a symbol (not a symbol name) from the obarray. If collection is a hash table, predicate is called with two arguments, the string key and the associated value.

In addition, to be acceptable, a completion must also match all the regular expressions in completion-regexp-list. (Unless collection is a function, in which case that function has to handle completion-regexp-list itself.)

In the first of the following examples, the string ‘foo’ is matched by three of the alist cars. All of the matches begin with the characters ‘fooba’, so that is the result. In the second example, there is only one possible match, and it is exact, so the return value is t.

          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4)))
               ⇒ "fooba"

          (try-completion "foo" '(("barfoo" 2) ("foo" 3)))
               ⇒ t
In the following example, numerous symbols begin with the characters ‘forw’, and all of them begin with the word ‘forward’. In most of the symbols, this is followed with a ‘-’, but not in all, so no more than ‘forward’ can be completed.

          (try-completion "forw" obarray)
               ⇒ "forward"
Finally, in the following example, only two of the three possible matches pass the predicate test (the string ‘foobaz’ is too short). Both of those begin with the string ‘foobar’.

          (defun test (s)
            (> (length (car s)) 6))
               ⇒ test
          (try-completion
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               ⇒ "foobar"
— Function: all-completions string collection &optional predicate
This function returns a list of all possible completions of string. The arguments to this function are the same as those of try-completion, and it uses completion-regexp-list in the same way that try-completion does.

If collection is a function, it is called with three arguments: string, predicate and t; then all-completions returns whatever the function returns. See Programmed Completion.

Here is an example, using the function test shown in the example for try-completion:

          (defun test (s)
            (> (length (car s)) 6))
               ⇒ test

          (all-completions
           "foo"
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           'test)
               ⇒ ("foobar1" "foobar2")
— Function: test-completion string collection &optional predicate
This function returns non-nil if string is a valid completion alternative specified by collection and predicate. The arguments are the same as in try-completion. For instance, if collection is a list of strings, this is true if string appears in the list and predicate is satisfied.

This function uses completion-regexp-list in the same way that try-completion does.

If predicate is non-nil and if collection contains several strings that are equal to each other, as determined by compare-strings according to completion-ignore-case, then predicate should accept either all or none of them. Otherwise, the return value of test-completion is essentially unpredictable.

If collection is a function, it is called with three arguments, the values string, predicate and lambda; whatever it returns, test-completion returns in turn.

— Function: completion-boundaries string collection predicate suffix
This function returns the boundaries of the field on which collection will operate, assuming that string holds the text before point and suffix holds the text after point.

Normally completion operates on the whole string, so for all normal collections, this will always return (0 . (length suffix)). But more complex completion such as completion on files is done one field at a time. For example, completion of "/usr/sh" will include "/usr/share/" but not "/usr/share/doc" even if "/usr/share/doc" exists. Also all-completions on "/usr/sh" will not include "/usr/share/" but only "share/". So if string is "/usr/sh" and suffix is "e/doc", completion-boundaries will return (5 . 1) which tells us that the collection will only return completion information that pertains to the area after "/usr/" and before "/doc".

If you store a completion alist in a variable, you should mark the variable as risky by giving it a non-nil risky-local-variable property. See File Local Variables.

— Variable: completion-ignore-case
If the value of this variable is non-nil, case is not considered significant in completion. Within read-file-name, this variable is overridden by read-file-name-completion-ignore-case (see Reading File Names); within read-buffer, it is overridden by read-buffer-completion-ignore-case (see High-Level Completion).

— Variable: completion-regexp-list
This is a list of regular expressions. The completion functions only consider a completion acceptable if it matches all regular expressions in this list, with case-fold-search (see Searching and Case) bound to the value of completion-ignore-case.

— Macro: lazy-completion-table var fun
This macro provides a way to initialize the variable var as a collection for completion in a lazy way, not computing its actual contents until they are first needed. You use this macro to produce a value that you store in var. The actual computation of the proper value is done the first time you do completion using var. It is done by calling fun with no arguments. The value fun returns becomes the permanent value of var.

Here is an example:

          (defvar foo (lazy-completion-table foo make-my-alist))
There are several functions that take an existing completion table and return a modified version. completion-table-case-fold returns a case-insensitive table. completion-table-in-turn and completion-table-merge combine multiple input tables in different ways. completion-table-subvert alters a table to use a different initial prefix. completion-table-with-quoting returns a table suitable for operating on quoted text. completion-table-with-predicate filters a table with a predicate function. completion-table-with-terminator adds a terminating string.

** 2. Minibuffer Completion: Invoking the minibuffer with completion.
This section describes the basic interface for reading from the minibuffer with completion.

— Function: completing-read prompt collection &optional predicate require-match initial history default inherit-input-method
This function reads a string in the minibuffer, assisting the user by providing completion. It activates the minibuffer with prompt prompt, which must be a string.

The actual completion is done by passing the completion table collection and the completion predicate predicate to the function try-completion (see Basic Completion). This happens in certain commands bound in the local keymaps used for completion. Some of these commands also call test-completion. Thus, if predicate is non-nil, it should be compatible with collection and completion-ignore-case. See Definition of test-completion.

See Programmed Completion, for detailed requirements when collection is a function.

The value of the optional argument require-match determines how the user may exit the minibuffer:

If nil, the usual minibuffer exit commands work regardless of the input in the minibuffer.
If t, the usual minibuffer exit commands won't exit unless the input completes to an element of collection.
If confirm, the user can exit with any input, but is asked for confirmation if the input is not an element of collection.
If confirm-after-completion, the user can exit with any input, but is asked for confirmation if the preceding command was a completion command (i.e., one of the commands in minibuffer-confirm-exit-commands) and the resulting input is not an element of collection. See Completion Commands.
Any other value of require-match behaves like t, except that the exit commands won't exit if it performs completion.
However, empty input is always permitted, regardless of the value of require-match; in that case, completing-read returns the first element of default, if it is a list; "", if default is nil; or default. The string or strings in default are also available to the user through the history commands.

The function completing-read uses minibuffer-local-completion-map as the keymap if require-match is nil, and uses minibuffer-local-must-match-map if require-match is non-nil. See Completion Commands.

The argument history specifies which history list variable to use for saving the input and for minibuffer history commands. It defaults to minibuffer-history. See Minibuffer History.

The argument initial is mostly deprecated; we recommend using a non-nil value only in conjunction with specifying a cons cell for history. See Initial Input. For default input, use default instead.

If the argument inherit-input-method is non-nil, then the minibuffer inherits the current input method (see Input Methods) and the setting of enable-multibyte-characters (see Text Representations) from whichever buffer was current before entering the minibuffer.

If the variable completion-ignore-case is non-nil, completion ignores case when comparing the input against the possible matches. See Basic Completion. In this mode of operation, predicate must also ignore case, or you will get surprising results.

Here's an example of using completing-read:

          (completing-read
           "Complete a foo: "
           '(("foobar1" 1) ("barfoo" 2) ("foobaz" 3) ("foobar2" 4))
           nil t "fo")

          ;; After evaluation of the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          Complete a foo: fo-!-
          ---------- Buffer: Minibuffer ----------
If the user then types <DEL> <DEL> b <RET>, completing-read returns barfoo.

The completing-read function binds variables to pass information to the commands that actually do completion. They are described in the following section.

— Variable: completing-read-function
The value of this variable must be a function, which is called by completing-read to actually do its work. It should accept the same arguments as completing-read. This can be bound to a different function to completely override the normal behavior of completing-read.

** 3. Completion Commands: Minibuffer commands that do completion.
This section describes the keymaps, commands and user options used in the minibuffer to do completion.

— Variable: minibuffer-completion-table
The value of this variable is the completion table (see Basic Completion) used for completion in the minibuffer. This is the global variable that contains what completing-read passes to try-completion. It is used by minibuffer completion commands such as minibuffer-complete-word.

— Variable: minibuffer-completion-predicate
This variable's value is the predicate that completing-read passes to try-completion. The variable is also used by the other minibuffer completion functions.

— Variable: minibuffer-completion-confirm
This variable determines whether Emacs asks for confirmation before exiting the minibuffer; completing-read binds this variable, and the function minibuffer-complete-and-exit checks the value before exiting. If the value is nil, confirmation is not required. If the value is confirm, the user may exit with an input that is not a valid completion alternative, but Emacs asks for confirmation. If the value is confirm-after-completion, the user may exit with an input that is not a valid completion alternative, but Emacs asks for confirmation if the user submitted the input right after any of the completion commands in minibuffer-confirm-exit-commands.

— Variable: minibuffer-confirm-exit-commands
This variable holds a list of commands that cause Emacs to ask for confirmation before exiting the minibuffer, if the require-match argument to completing-read is confirm-after-completion. The confirmation is requested if the user attempts to exit the minibuffer immediately after calling any command in this list.

— Command: minibuffer-complete-word
This function completes the minibuffer contents by at most a single word. Even if the minibuffer contents have only one completion, minibuffer-complete-word does not add any characters beyond the first character that is not a word constituent. See Syntax Tables.

— Command: minibuffer-complete
This function completes the minibuffer contents as far as possible.

— Command: minibuffer-complete-and-exit
This function completes the minibuffer contents, and exits if confirmation is not required, i.e., if minibuffer-completion-confirm is nil. If confirmation is required, it is given by repeating this command immediately—the command is programmed to work without confirmation when run twice in succession.

— Command: minibuffer-completion-help
This function creates a list of the possible completions of the current minibuffer contents. It works by calling all-completions using the value of the variable minibuffer-completion-table as the collection argument, and the value of minibuffer-completion-predicate as the predicate argument. The list of completions is displayed as text in a buffer named *Completions*.

— Function: display-completion-list completions
This function displays completions to the stream in standard-output, usually a buffer. (See Read and Print, for more information about streams.) The argument completions is normally a list of completions just returned by all-completions, but it does not have to be. Each element may be a symbol or a string, either of which is simply printed. It can also be a list of two strings, which is printed as if the strings were concatenated. The first of the two strings is the actual completion, the second string serves as annotation.

This function is called by minibuffer-completion-help. A common way to use it is together with with-output-to-temp-buffer, like this:

          (with-output-to-temp-buffer "*Completions*"
            (display-completion-list
              (all-completions (buffer-string) my-alist)))
— User Option: completion-auto-help
If this variable is non-nil, the completion commands automatically display a list of possible completions whenever nothing can be completed because the next character is not uniquely determined.

— Variable: minibuffer-local-completion-map
completing-read uses this value as the local keymap when an exact match of one of the completions is not required. By default, this keymap makes the following bindings:

?
minibuffer-completion-help
<SPC>
minibuffer-complete-word
<TAB>
minibuffer-complete
and uses minibuffer-local-map as its parent keymap (see Definition of minibuffer-local-map).

— Variable: minibuffer-local-must-match-map
completing-read uses this value as the local keymap when an exact match of one of the completions is required. Therefore, no keys are bound to exit-minibuffer, the command that exits the minibuffer unconditionally. By default, this keymap makes the following bindings:

C-j
minibuffer-complete-and-exit
<RET>
minibuffer-complete-and-exit
and uses minibuffer-local-completion-map as its parent keymap.

— Variable: minibuffer-local-filename-completion-map
This is a sparse keymap that simply unbinds <SPC>; because filenames can contain spaces. The function read-file-name combines this keymap with either minibuffer-local-completion-map or minibuffer-local-must-match-map.

** 4. High-Level Completion: Convenient special cases of completion (reading buffer names, variable names, etc.).
This section describes the higher-level convenience functions for reading certain sorts of names with completion.

In most cases, you should not call these functions in the middle of a Lisp function. When possible, do all minibuffer input as part of reading the arguments for a command, in the interactive specification. See Defining Commands.

— Function: read-buffer prompt &optional default require-match predicate
This function reads the name of a buffer and returns it as a string. It prompts with prompt. The argument default is the default name to use, the value to return if the user exits with an empty minibuffer. If non-nil, it should be a string, a list of strings, or a buffer. If it is a list, the default value is the first element of this list. It is mentioned in the prompt, but is not inserted in the minibuffer as initial input.

The argument prompt should be a string ending with a colon and a space. If default is non-nil, the function inserts it in prompt before the colon to follow the convention for reading from the minibuffer with a default value (see Programming Tips).

The optional argument require-match has the same meaning as in completing-read. See Minibuffer Completion.

The optional argument predicate, if non-nil, specifies a function to filter the buffers that should be considered: the function will be called with every potential candidate as its argument, and should return nil to reject the candidate, non-nil to accept it.

In the following example, the user enters ‘minibuffer.t’, and then types <RET>. The argument require-match is t, and the only buffer name starting with the given input is ‘minibuffer.texi’, so that name is the value.

          (read-buffer "Buffer name: " "foo" t)
          ;; After evaluation of the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: Minibuffer ----------
          Buffer name (default foo): -!-
          ---------- Buffer: Minibuffer ----------

          ;; The user types minibuffer.t <RET>.
               ⇒ "minibuffer.texi"
— User Option: read-buffer-function
This variable, if non-nil, specifies a function for reading buffer names. read-buffer calls this function instead of doing its usual work, with the same arguments passed to read-buffer.

— User Option: read-buffer-completion-ignore-case
If this variable is non-nil, read-buffer ignores case when performing completion while reading the buffer name.

— Function: read-command prompt &optional default
This function reads the name of a command and returns it as a Lisp symbol. The argument prompt is used as in read-from-minibuffer. Recall that a command is anything for which commandp returns t, and a command name is a symbol for which commandp returns t. See Interactive Call.

The argument default specifies what to return if the user enters null input. It can be a symbol, a string or a list of strings. If it is a string, read-command interns it before returning it. If it is a list, read-command interns the first element of this list. If default is nil, that means no default has been specified; then if the user enters null input, the return value is (intern ""), that is, a symbol whose name is an empty string, and whose printed representation is ## (see Symbol Type).

          (read-command "Command name? ")

          ;; After evaluation of the preceding expression,
          ;;   the following prompt appears with an empty minibuffer:

          ---------- Buffer: Minibuffer ----------
          Command name?
          ---------- Buffer: Minibuffer ----------
If the user types forward-c <RET>, then this function returns forward-char.

The read-command function is a simplified interface to completing-read. It uses the variable obarray so as to complete in the set of extant Lisp symbols, and it uses the commandp predicate so as to accept only command names:


          (read-command prompt)
          ==
          (intern (completing-read prompt obarray
                                   'commandp t nil))
— Function: read-variable prompt &optional default
This function reads the name of a customizable variable and returns it as a symbol. Its arguments have the same form as those of read-command. It behaves just like read-command, except that it uses the predicate custom-variable-p instead of commandp.

— Command: read-color &optional prompt convert allow-empty display
This function reads a string that is a color specification, either the color's name or an RGB hex value such as #RRRGGGBBB. It prompts with prompt (default: "Color (name or #RGB triplet):") and provides completion for color names, but not for hex RGB values. In addition to names of standard colors, completion candidates include the foreground and background colors at point.

Valid RGB values are described in Color Names.

The function's return value is the string typed by the user in the minibuffer. However, when called interactively or if the optional argument convert is non-nil, it converts any input color name into the corresponding RGB value string and instead returns that. This function requires a valid color specification to be input. Empty color names are allowed when allow-empty is non-nil and the user enters null input.

Interactively, or when display is non-nil, the return value is also displayed in the echo area.

See also the functions read-coding-system and read-non-nil-coding-system, in User-Chosen Coding Systems, and read-input-method-name, in Input Methods.

** 5. Reading File Names: Using completion to read file names and shell commands.
The high-level completion functions read-file-name, read-directory-name, and read-shell-command are designed to read file names, directory names, and shell commands, respectively. They provide special features, including automatic insertion of the default directory.

— Function: read-file-name prompt &optional directory default require-match initial predicate
This function reads a file name, prompting with prompt and providing completion.

As an exception, this function reads a file name using a graphical file dialog instead of the minibuffer, if all of the following are true:

It is invoked via a mouse command.
The selected frame is on a graphical display supporting such dialogs.
The variable use-dialog-box is non-nil. See Dialog Boxes.
The directory argument, described below, does not specify a remote file. See Remote Files.
The exact behavior when using a graphical file dialog is platform-dependent. Here, we simply document the behavior when using the minibuffer.

read-file-name does not automatically expand the returned file name. You can call expand-file-name yourself if an absolute file name is required.

The optional argument require-match has the same meaning as in completing-read. See Minibuffer Completion.

The argument directory specifies the directory to use for completing relative file names. It should be an absolute directory name. If the variable insert-default-directory is non-nil, directory is also inserted in the minibuffer as initial input. It defaults to the current buffer's value of default-directory.

If you specify initial, that is an initial file name to insert in the buffer (after directory, if that is inserted). In this case, point goes at the beginning of initial. The default for initial is nil—don't insert any file name. To see what initial does, try the command C-x C-v in a buffer visiting a file. Please note: we recommend using default rather than initial in most cases.

If default is non-nil, then the function returns default if the user exits the minibuffer with the same non-empty contents that read-file-name inserted initially. The initial minibuffer contents are always non-empty if insert-default-directory is non-nil, as it is by default. default is not checked for validity, regardless of the value of require-match. However, if require-match is non-nil, the initial minibuffer contents should be a valid file (or directory) name. Otherwise read-file-name attempts completion if the user exits without any editing, and does not return default. default is also available through the history commands.

If default is nil, read-file-name tries to find a substitute default to use in its place, which it treats in exactly the same way as if it had been specified explicitly. If default is nil, but initial is non-nil, then the default is the absolute file name obtained from directory and initial. If both default and initial are nil and the buffer is visiting a file, read-file-name uses the absolute file name of that file as default. If the buffer is not visiting a file, then there is no default. In that case, if the user types <RET> without any editing, read-file-name simply returns the pre-inserted contents of the minibuffer.

If the user types <RET> in an empty minibuffer, this function returns an empty string, regardless of the value of require-match. This is, for instance, how the user can make the current buffer visit no file using M-x set-visited-file-name.

If predicate is non-nil, it specifies a function of one argument that decides which file names are acceptable completion alternatives. A file name is an acceptable value if predicate returns non-nil for it.

Here is an example of using read-file-name:

          (read-file-name "The file is ")

          ;; After evaluation of the preceding expression,
          ;;   the following appears in the minibuffer:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/-!-
          ---------- Buffer: Minibuffer ----------
Typing manual <TAB> results in the following:

          ---------- Buffer: Minibuffer ----------
          The file is /gp/gnu/elisp/manual.texi-!-
          ---------- Buffer: Minibuffer ----------
If the user types <RET>, read-file-name returns the file name as the string "/gp/gnu/elisp/manual.texi".

— Variable: read-file-name-function
If non-nil, this should be a function that accepts the same arguments as read-file-name. When read-file-name is called, it calls this function with the supplied arguments instead of doing its usual work.

— User Option: read-file-name-completion-ignore-case
If this variable is non-nil, read-file-name ignores case when performing completion.

— Function: read-directory-name prompt &optional directory default require-match initial
This function is like read-file-name but allows only directory names as completion alternatives.

If default is nil and initial is non-nil, read-directory-name constructs a substitute default by combining directory (or the current buffer's default directory if directory is nil) and initial. If both default and initial are nil, this function uses directory as substitute default, or the current buffer's default directory if directory is nil.

— User Option: insert-default-directory
This variable is used by read-file-name, and thus, indirectly, by most commands reading file names. (This includes all commands that use the code letters ‘f’ or ‘F’ in their interactive form. See Code Characters for interactive.) Its value controls whether read-file-name starts by placing the name of the default directory in the minibuffer, plus the initial file name, if any. If the value of this variable is nil, then read-file-name does not place any initial input in the minibuffer (unless you specify initial input with the initial argument). In that case, the default directory is still used for completion of relative file names, but is not displayed.

If this variable is nil and the initial minibuffer contents are empty, the user may have to explicitly fetch the next history element to access a default value. If the variable is non-nil, the initial minibuffer contents are always non-empty and the user can always request a default value by immediately typing <RET> in an unedited minibuffer. (See above.)

For example:

          ;; Here the minibuffer starts out with the default directory.
          (let ((insert-default-directory t))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is ~lewis/manual/-!-
          ---------- Buffer: Minibuffer ----------

          ;; Here the minibuffer is empty and only the prompt
          ;;   appears on its line.
          (let ((insert-default-directory nil))
            (read-file-name "The file is "))

          ---------- Buffer: Minibuffer ----------
          The file is -!-
          ---------- Buffer: Minibuffer ----------
— Function: read-shell-command prompt &optional initial history &rest args
This function reads a shell command from the minibuffer, prompting with prompt and providing intelligent completion. It completes the first word of the command using candidates that are appropriate for command names, and the rest of the command words as file names.

This function uses minibuffer-local-shell-command-map as the keymap for minibuffer input. The history argument specifies the history list to use; if is omitted or nil, it defaults to shell-command-history (see shell-command-history). The optional argument initial specifies the initial content of the minibuffer (see Initial Input). The rest of args, if present, are used as the default and inherit-input-method arguments in read-from-minibuffer (see Text from Minibuffer).

— Variable: minibuffer-local-shell-command-map
This keymap is used by read-shell-command for completing command and file names that are part of a shell command. It uses minibuffer-local-map as its parent keymap, and binds <TAB> to completion-at-point.

** 6. Completion Variables: Variables controlling completion behavior.
Here are some variables that can be used to alter the default completion behavior.


— User Option: completion-styles
The value of this variable is a list of completion style (symbols) to use for performing completion. A completion style is a set of rules for generating completions. Each symbol occurring this list must have a corresponding entry in completion-styles-alist.

— Variable: completion-styles-alist
This variable stores a list of available completion styles. Each element in the list has the form

          (style try-completion all-completions doc)
Here, style is the name of the completion style (a symbol), which may be used in the completion-styles variable to refer to this style; try-completion is the function that does the completion; all-completions is the function that lists the completions; and doc is a string describing the completion style.

The try-completion and all-completions functions should each accept four arguments: string, collection, predicate, and point. The string, collection, and predicate arguments have the same meanings as in try-completion (see Basic Completion), and the point argument is the position of point within string. Each function should return a non-nil value if it performed its job, and nil if it did not (e.g., if there is no way to complete string according to the completion style).

When the user calls a completion command like minibuffer-complete (see Completion Commands), Emacs looks for the first style listed in completion-styles and calls its try-completion function. If this function returns nil, Emacs moves to the next listed completion style and calls its try-completion function, and so on until one of the try-completion functions successfully performs completion and returns a non-nil value. A similar procedure is used for listing completions, via the all-completions functions.

See Completion Styles, for a description of the available completion styles.

— User Option: completion-category-overrides
This variable specifies special completion styles and other completion behaviors to use when completing certain types of text. Its value should be an alist with elements of the form (category . alist). category is a symbol describing what is being completed; currently, the buffer, file, and unicode-name categories are defined, but others can be defined via specialized completion functions (see Programmed Completion). alist is an association list describing how completion should behave for the corresponding category. The following alist keys are supported:

styles
The value should be a list of completion styles (symbols).
cycle
The value should be a value for completion-cycle-threshold (see Completion Options) for this category.
Additional alist entries may be defined in the future.

— Variable: completion-extra-properties
This variable is used to specify extra properties of the current completion command. It is intended to be let-bound by specialized completion commands. Its value should be a list of property and value pairs. The following properties are supported:

:annotation-function
The value should be a function to add annotations in the completions buffer. This function must accept one argument, a completion, and should either return nil or a string to be displayed next to the completion.
:exit-function
The value should be a function to run after performing completion. The function should accept two arguments, string and status, where string is the text to which the field was completed, and status indicates what kind of operation happened: finished if text is now complete, sole if the text cannot be further completed but completion is not finished, or exact if the text is a valid completion but may be further completed.

** 7. Programmed Completion: Writing your own completion function.
This section describes functions used to ask the user a yes-or-no question. The function y-or-n-p can be answered with a single character; it is useful for questions where an inadvertent wrong answer will not have serious consequences. yes-or-no-p is suitable for more momentous questions, since it requires three or four characters to answer.

If either of these functions is called in a command that was invoked using the mouse—more precisely, if last-nonmenu-event (see Command Loop Info) is either nil or a list—then it uses a dialog box or pop-up menu to ask the question. Otherwise, it uses keyboard input. You can force use either of the mouse or of keyboard input by binding last-nonmenu-event to a suitable value around the call.

Strictly speaking, yes-or-no-p uses the minibuffer and y-or-n-p does not; but it seems best to describe them together.

— Function: y-or-n-p prompt
This function asks the user a question, expecting input in the echo area. It returns t if the user types y, nil if the user types n. This function also accepts <SPC> to mean yes and <DEL> to mean no. It accepts C-] to quit, like C-g, because the question might look like a minibuffer and for that reason the user might try to use C-] to get out. The answer is a single character, with no <RET> needed to terminate it. Upper and lower case are equivalent.

“Asking the question” means printing prompt in the echo area, followed by the string ‘(y or n) ’. If the input is not one of the expected answers (y, n, <SPC>, <DEL>, or something that quits), the function responds ‘Please answer y or n.’, and repeats the request.

This function does not actually use the minibuffer, since it does not allow editing of the answer. It actually uses the echo area (see The Echo Area), which uses the same screen space as the minibuffer. The cursor moves to the echo area while the question is being asked.

The answers and their meanings, even ‘y’ and ‘n’, are not hardwired, and are specified by the keymap query-replace-map (see Search and Replace). In particular, if the user enters the special responses recenter, scroll-up, scroll-down, scroll-other-window, or scroll-other-window-down (respectively bound to C-l, C-v, M-v, C-M-v and C-M-S-v in query-replace-map), this function performs the specified window recentering or scrolling operation, and poses the question again.

We show successive lines of echo area messages, but only one actually appears on the screen at a time.

— Function: y-or-n-p-with-timeout prompt seconds default
Like y-or-n-p, except that if the user fails to answer within seconds seconds, this function stops waiting and returns default. It works by setting up a timer; see Timers. The argument seconds should be a number.

— Function: yes-or-no-p prompt
This function asks the user a question, expecting input in the minibuffer. It returns t if the user enters ‘yes’, nil if the user types ‘no’. The user must type <RET> to finalize the response. Upper and lower case are equivalent.

yes-or-no-p starts by displaying prompt in the echo area, followed by ‘(yes or no) ’. The user must type one of the expected responses; otherwise, the function responds ‘Please answer yes or no.’, waits about two seconds and repeats the request.

yes-or-no-p requires more work from the user than y-or-n-p and is appropriate for more crucial decisions.

Here is an example:

          (yes-or-no-p "Do you really want to remove everything? ")

          ;; After evaluation of the preceding expression,
          ;;   the following prompt appears,
          ;;   with an empty minibuffer:

          ---------- Buffer: minibuffer ----------
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------
If the user first types y <RET>, which is invalid because this function demands the entire word ‘yes’, it responds by displaying these prompts, with a brief pause between them:

          ---------- Buffer: minibuffer ----------
          Please answer yes or no.
          Do you really want to remove everything? (yes or no)
          ---------- Buffer: minibuffer ----------

** 8. Completion in Buffers: Completing text in ordinary buffers.
This section describes facilities for asking the user more complex questions or several similar questions.

When you have a series of similar questions to ask, such as “Do you want to save this buffer?” for each buffer in turn, you should use map-y-or-n-p to ask the collection of questions, rather than asking each question individually. This gives the user certain convenient facilities such as the ability to answer the whole series at once.

— Function: map-y-or-n-p prompter actor list &optional help action-alist no-cursor-in-echo-area
This function asks the user a series of questions, reading a single-character answer in the echo area for each one.

The value of list specifies the objects to ask questions about. It should be either a list of objects or a generator function. If it is a function, it should expect no arguments, and should return either the next object to ask about, or nil, meaning to stop asking questions.

The argument prompter specifies how to ask each question. If prompter is a string, the question text is computed like this:

          (format prompter object)
where object is the next object to ask about (as obtained from list).

If not a string, prompter should be a function of one argument (the next object to ask about) and should return the question text. If the value is a string, that is the question to ask the user. The function can also return t, meaning do act on this object (and don't ask the user), or nil, meaning ignore this object (and don't ask the user).

The argument actor says how to act on the answers that the user gives. It should be a function of one argument, and it is called with each object that the user says yes for. Its argument is always an object obtained from list.

If the argument help is given, it should be a list of this form:

          (singular plural action)
where singular is a string containing a singular noun that describes the objects conceptually being acted on, plural is the corresponding plural noun, and action is a transitive verb describing what actor does.

If you don't specify help, the default is ("object" "objects" "act on").

Each time a question is asked, the user may enter y, Y, or <SPC> to act on that object; n, N, or <DEL> to skip that object; ! to act on all following objects; <ESC> or q to exit (skip all following objects); . (period) to act on the current object and then exit; or C-h to get help. These are the same answers that query-replace accepts. The keymap query-replace-map defines their meaning for map-y-or-n-p as well as for query-replace; see Search and Replace.

You can use action-alist to specify additional possible answers and what they mean. It is an alist of elements of the form (char function help), each of which defines one additional answer. In this element, char is a character (the answer); function is a function of one argument (an object from list); help is a string.

When the user responds with char, map-y-or-n-p calls function. If it returns non-nil, the object is considered acted upon, and map-y-or-n-p advances to the next object in list. If it returns nil, the prompt is repeated for the same object.

Normally, map-y-or-n-p binds cursor-in-echo-area while prompting. But if no-cursor-in-echo-area is non-nil, it does not do that.

If map-y-or-n-p is called in a command that was invoked using the mouse—more precisely, if last-nonmenu-event (see Command Loop Info) is either nil or a list—then it uses a dialog box or pop-up menu to ask the question. In this case, it does not use keyboard input or the echo area. You can force use either of the mouse or of keyboard input by binding last-nonmenu-event to a suitable value around the call.

The return value of map-y-or-n-p is the number of objects acted on.

If you need to ask the user a question that might have more than just 2 answers, use read-answer.

— Function: read-answer question answers
This function prompts the user with text in question, which should end in the ‘SPC’ character. The function includes in the prompt the possible responses in answers by appending them to the end of question. The possible responses are provided in answers as an alist whose elements are of the following form:

          (long-answer short-answer help-message)
where long-answer is the complete text of the user response, a string; short-answer is a short form of the same response, a single character; and help-message is the text that describes the meaning of the answer. If the variable read-answer-short is non-nil, the prompt will show the short variants of the possible answers and the user is expected to type the single characters shown in the prompt; otherwise the prompt will show the long variants of the answers, and the user is expected to type the full text of one of the answers and end by pressing <RET>. If use-dialog-box is non-nil, and this function was invoked by mouse events, the question and the answers will be displayed in a GUI dialog box.

The function returns the text of the long-answer selected by the user, regardless of whether long or short answers were shown in the prompt and typed by the user.

Here is an example of using this function:

          (let ((read-answer-short t))
            (read-answer "Foo "
               '(("yes"  ?y "perform the action")
                 ("no"   ?n "skip to the next")
                 ("all"  ?! "perform for the rest without more questions")
                 ("help" ?h "show help")
                 ("quit" ?q "exit"))))

** 20.9 Reading a Password
To read a password to pass to another program, you can use the function read-passwd.


— Function: read-passwd prompt &optional confirm default
This function reads a password, prompting with prompt. It does not echo the password as the user types it; instead, it echoes ‘.’ for each character in the password. If you want to apply another character to hide the password, let-bind the variable read-hide-char with that character.

The optional argument confirm, if non-nil, says to read the password twice and insist it must be the same both times. If it isn't the same, the user has to type it over and over until the last two times match.

The optional argument default specifies the default password to return if the user enters empty input. If default is nil, then read-passwd returns the null string in that case.

** 20.10 Minibuffer Commands
This section describes some commands meant for use in the minibuffer.

— Command: exit-minibuffer
This command exits the active minibuffer. It is normally bound to keys in minibuffer local keymaps.

— Command: self-insert-and-exit
This command exits the active minibuffer after inserting the last character typed on the keyboard (found in last-command-event; see Command Loop Info).

— Command: previous-history-element n
This command replaces the minibuffer contents with the value of the nth previous (older) history element.

— Command: next-history-element n
This command replaces the minibuffer contents with the value of the nth more recent history element.

— Command: previous-matching-history-element pattern n
This command replaces the minibuffer contents with the value of the nth previous (older) history element that matches pattern (a regular expression).

— Command: next-matching-history-element pattern n
This command replaces the minibuffer contents with the value of the nth next (newer) history element that matches pattern (a regular expression).

— Command: previous-complete-history-element n
This command replaces the minibuffer contents with the value of the nth previous (older) history element that completes the current contents of the minibuffer before the point.

— Command: next-complete-history-element n
This command replaces the minibuffer contents with the value of the nth next (newer) history element that completes the current contents of the minibuffer before the point.x


** 20.11 Minibuffer Windows
These functions access and select minibuffer windows, test whether they are active and control how they get resized.

— Function: minibuffer-window &optional frame
This function returns the minibuffer window used for frame frame. If frame is nil, that stands for the selected frame.

Note that the minibuffer window used by a frame need not be part of that frame—a frame that has no minibuffer of its own necessarily uses some other frame's minibuffer window. The minibuffer window of a minibuffer-less frame can be changed by setting that frame's minibuffer frame parameter (see Buffer Parameters).

— Function: set-minibuffer-window window
This function specifies window as the minibuffer window to use. This affects where the minibuffer is displayed if you put text in it without invoking the usual minibuffer commands. It has no effect on the usual minibuffer input functions because they all start by choosing the minibuffer window according to the selected frame.

— Function: window-minibuffer-p &optional window
This function returns non-nil if window is a minibuffer window. window defaults to the selected window.

The following function returns the window showing the currently active minibuffer.

— Function: active-minibuffer-window
This function returns the window of the currently active minibuffer, or nil if there is no active minibuffer.

It is not sufficient to determine whether a given window shows the currently active minibuffer by comparing it with the result of (minibuffer-window), because there can be more than one minibuffer window if there is more than one frame.

— Function: minibuffer-window-active-p window
This function returns non-nil if window shows the currently active minibuffer.

The following two options control whether minibuffer windows are resized automatically and how large they can get in the process.

— User Option: resize-mini-windows
This option specifies whether minibuffer windows are resized automatically. The default value is grow-only, which means that a minibuffer window by default expands automatically to accommodate the text it displays and shrinks back to one line as soon as the minibuffer gets empty. If the value is t, Emacs will always try to fit the height of a minibuffer window to the text it displays (with a minimum of one line). If the value is nil, a minibuffer window never changes size automatically. In that case the window resizing commands (see Resizing Windows) can be used to adjust its height.

— User Option: max-mini-window-height
This option provides a maximum height for resizing minibuffer windows automatically. A floating-point number specifies a fraction of the frame's height; an integer specifies the maximum number of lines. The default value is 0.25.

Note that the values of the above two variables take effect at display time, so let-binding them around code which produces echo-area messages will not work. If you want to prevent resizing of minibuffer windows when displaying long messages, bind the message-truncate-lines variable instead (see Echo Area Customization).

** 20.12 Minibuffer Contents
These functions access the minibuffer prompt and contents.

— Function: minibuffer-prompt
This function returns the prompt string of the currently active minibuffer. If no minibuffer is active, it returns nil.

— Function: minibuffer-prompt-end
This function returns the current position of the end of the minibuffer prompt, if a minibuffer is current. Otherwise, it returns the minimum valid buffer position.

— Function: minibuffer-prompt-width
This function returns the current display-width of the minibuffer prompt, if a minibuffer is current. Otherwise, it returns zero.

— Function: minibuffer-contents
This function returns the editable contents of the minibuffer (that is, everything except the prompt) as a string, if a minibuffer is current. Otherwise, it returns the entire contents of the current buffer.

— Function: minibuffer-contents-no-properties
This is like minibuffer-contents, except that it does not copy text properties, just the characters themselves. See Text Properties.

— Command: delete-minibuffer-contents
This command erases the editable contents of the minibuffer (that is, everything except the prompt), if a minibuffer is current. Otherwise, it erases the entire current buffer.

** 20.13 Recursive Minibuffers
These functions and variables deal with recursive minibuffers (see Recursive Editing):

— Function: minibuffer-depth
This function returns the current depth of activations of the minibuffer, a nonnegative integer. If no minibuffers are active, it returns zero.

— User Option: enable-recursive-minibuffers
If this variable is non-nil, you can invoke commands (such as find-file) that use minibuffers even while the minibuffer is active. Such invocation produces a recursive editing level for a new minibuffer. The outer-level minibuffer is invisible while you are editing the inner one.

If this variable is nil, you cannot invoke minibuffer commands when the minibuffer is active, not even if you switch to another window to do it.

If a command name has a property enable-recursive-minibuffers that is non-nil, then the command can use the minibuffer to read arguments even if it is invoked from the minibuffer. A command can also achieve this by binding enable-recursive-minibuffers to t in the interactive declaration (see Using Interactive). The minibuffer command next-matching-history-element (normally M-s in the minibuffer) does the latter.

** 20.14 Minibuffer Miscellany
— Function: minibufferp &optional buffer-or-name
This function returns non-nil if buffer-or-name is a minibuffer. If buffer-or-name is omitted, it tests the current buffer.

— Variable: minibuffer-setup-hook
This is a normal hook that is run whenever the minibuffer is entered. See Hooks.

— Macro: minibuffer-with-setup-hook function &rest body
This macro executes body after arranging for the specified function to be called via minibuffer-setup-hook. By default, function is called before the other functions in the minibuffer-setup-hook list, but if function is of the form (:append func), func will be called after the other hook functions.

The body forms should not use the minibuffer more than once. If the minibuffer is re-entered recursively, function will only be called once, for the outermost use of the minibuffer.

— Variable: minibuffer-exit-hook
This is a normal hook that is run whenever the minibuffer is exited. See Hooks.

— Variable: minibuffer-help-form
The current value of this variable is used to rebind help-form locally inside the minibuffer (see Help Functions).

— Variable: minibuffer-scroll-window
If the value of this variable is non-nil, it should be a window object. When the function scroll-other-window is called in the minibuffer, it scrolls this window.

— Function: minibuffer-selected-window
This function returns the window that was selected just before the minibuffer window was selected. If the selected window is not a minibuffer window, it returns nil.


— Function: minibuffer-message string &rest args
This function displays string temporarily at the end of the minibuffer text, for a few seconds, or until the next input event arrives, whichever comes first. The variable minibuffer-message-timeout specifies the number of seconds to wait in the absence of input. It defaults to 2. If args is non-nil, the actual message is obtained by passing string and args through format-message. See Formatting Strings.

— Command: minibuffer-inactive-mode
This is the major mode used in inactive minibuffers. It uses keymap minibuffer-inactive-mode-map. This can be useful if the minibuffer is in a separate frame. See Minibuffers and Frames.

* 21 Command Loop
When you run Emacs, it enters the editor command loop almost immediately. This loop reads key sequences, executes their definitions, and displays the results. In this chapter, we describe how these things are done, and the subroutines that allow Lisp programs to do them.

+ Command Overview: How the command loop reads commands.
+ Defining Commands: Specifying how a function should read arguments.
+ Interactive Call: Calling a command, so that it will read arguments.
+ Distinguish Interactive: Making a command distinguish interactive calls.
+ Command Loop Info: Variables set by the command loop for you to examine.
+ Adjusting Point: Adjustment of point after a command.
+ Input Events: What input looks like when you read it.
+ Reading Input: How to read input events from the keyboard or mouse.
+ Special Events: Events processed immediately and individually.
+ Waiting: Waiting for user input or elapsed time.
+ Quitting: How C-g works. How to catch or defer quitting.
+ Prefix Command Arguments: How the commands to set prefix args work.
+ Recursive Editing: Entering a recursive edit, and why you usually shouldn't.
+ Disabling Commands: How the command loop handles disabled commands.
+ Command History: How the command history is set up, and how accessed.
+ Keyboard Macros: How keyboard macros are implemented.
* 22 Keymaps
The command bindings of input events are recorded in data structures called keymaps. Each entry in a keymap associates (or binds) an individual event type, either to another keymap or to a command. When an event type is bound to a keymap, that keymap is used to look up the next input event; this continues until a command is found. The whole process is called key lookup.

 1. Key Sequences: Key sequences as Lisp objects.
 2. Keymap Basics: Basic concepts of keymaps.
 3. Format of Keymaps: What a keymap looks like as a Lisp object.
 4. Creating Keymaps: Functions to create and copy keymaps.
 5. Inheritance and Keymaps: How one keymap can inherit the bindings of another keymap.
 6. Prefix Keys: Defining a key with a keymap as its definition.
 7. Active Keymaps: How Emacs searches the active keymaps for a key binding.
 8. Searching Keymaps: A pseudo-Lisp summary of searching active maps.
 9. Controlling Active Maps: Each buffer has a local keymap to override the standard (global) bindings. A minor mode can also override them.
 10. Key Lookup: Finding a key's binding in one keymap.
 11. Functions for Key Lookup: How to request key lookup.
 12. Changing Key Bindings: Redefining a key in a keymap.
 13. Remapping Commands: A keymap can translate one command to another.
 14. Translation Keymaps: Keymaps for translating sequences of events.
 15. Key Binding Commands: Interactive interfaces for redefining keys.
 16. Scanning Keymaps: Looking through all keymaps, for printing help.
 17. Menu Keymaps: Defining a menu as a keymap.

* 23 Major and Minor Modes
A mode is a set of definitions that customize Emacs behavior in useful ways. There are two varieties of modes: minor modes, which provide features that users can turn on and off while editing; and major modes, which are used for editing or interacting with a particular kind of text. Each buffer has exactly one major mode at a time.

This chapter describes how to write both major and minor modes, how to indicate them in the mode line, and how they run hooks supplied by the user. For related topics such as keymaps and syntax tables, see Keymaps, and Syntax Tables.

1) Hooks: How to use hooks; how to write code that provides hooks.
2) Major Modes: Defining major modes.
3) Minor Modes: Defining minor modes.
4) Mode Line Format: Customizing the text that appears in the mode line.
5) Imenu: Providing a menu of definitions made in a buffer.
6) Font Lock Mode: How modes can highlight text according to syntax.
7) Auto-Indentation: How to teach Emacs to indent for a major mode.
8) Desktop Save Mode: How modes can have buffer state saved between Emacs
   sessions.

* 24 Documentation
GNU Emacs has convenient built-in help facilities, most of which derive their information from documentation strings associated with functions and variables. This chapter describes how to access documentation strings in Lisp programs.

The contents of a documentation string should follow certain conventions. In particular, its first line should be a complete sentence (or two complete sentences) that briefly describes what the function or variable does. See Documentation Tips, for how to write good documentation strings.

Note that the documentation strings for Emacs are not the same thing as the Emacs manual. Manuals have their own source files, written in the Texinfo language; documentation strings are specified in the definitions of the functions and variables they apply to. A collection of documentation strings is not sufficient as a manual because a good manual is not organized in that fashion; it is organized in terms of topics of discussion.

For commands to display documentation strings, see Help.

 1. Documentation Basics: Where doc strings are defined and stored.
 2. Accessing Documentation: How Lisp programs can access doc strings.
 3. Keys in Documentation: Substituting current key bindings.
 4. Text Quoting Style: Quotation marks in doc strings and messages.
 5. Describing Characters: Making printable descriptions of non-printing characters and key sequences.
 6. Help Functions: Subroutines used by Emacs help facilities.

* 25 Files
** intro
This chapter describes the Emacs Lisp functions and variables to find, create, view, save, and otherwise work with files and directories. A few other file-related functions are described in Buffers, and those related to backups and auto-saving are described in Backups and Auto-Saving.

Many of the file functions take one or more arguments that are file names. A file name is a string. Most of these functions expand file name arguments using the function expand-file-name, so that ~ is handled correctly, as are relative file names (including ../ and the empty string). See File Name Expansion.

In addition, certain magic file names are handled specially. For example, when a remote file name is specified, Emacs accesses the file over the network via an appropriate protocol. See Remote Files. This handling is done at a very low level, so you may assume that all the functions described in this chapter accept magic file names as file name arguments, except where noted. See Magic File Names, for details.

When file I/O functions signal Lisp errors, they usually use the condition file-error (see Handling Errors). The error message is in most cases obtained from the operating system, according to locale system-messages-locale, and decoded using coding system locale-coding-system (see Locales).

** 1. Visiting Files: Reading files into Emacs buffers for editing.
Visiting a file means reading a file into a buffer. Once this is done, we say that the buffer is visiting that file, and call the file the visited file of the buffer.

A file and a buffer are two different things. A file is information recorded permanently in the computer (unless you delete it). A buffer, on the other hand, is information inside of Emacs that will vanish at the end of the editing session (or when you kill the buffer). When a buffer is visiting a file, it contains information copied from the file. The copy in the buffer is what you modify with editing commands. Changes to the buffer do not change the file; to make the changes permanent, you must save the buffer, which means copying the altered buffer contents back into the file.

Despite the distinction between files and buffers, people often refer to a file when they mean a buffer and vice-versa. Indeed, we say, “I am editing a file”, rather than, “I am editing a buffer that I will soon save as a file of the same name”. Humans do not usually need to make the distinction explicit. When dealing with a computer program, however, it is good to keep the distinction in mind.

*** Visiting Functions: The usual interface functions for visiting.

This section describes the functions normally used to visit files. For historical reasons, these functions have names starting with ‘find-’ rather than ‘visit-’. See Buffer File Name, for functions and variables that access the visited file name of a buffer or that find an existing buffer by its visited file name.

In a Lisp program, if you want to look at the contents of a file but not alter it, the fastest way is to use insert-file-contents in a temporary buffer. Visiting the file is not necessary and takes longer. See Reading from Files.

— Command: find-file filename &optional wildcards
This command selects a buffer visiting the file filename, using an existing buffer if there is one, and otherwise creating a new buffer and reading the file into it. It also returns that buffer.

Aside from some technical details, the body of the find-file function is basically equivalent to:

          (switch-to-buffer (find-file-noselect filename nil nil wildcards))
(See switch-to-buffer in Switching Buffers.)

If wildcards is non-nil, which is always true in an interactive call, then find-file expands wildcard characters in filename and visits all the matching files.

When find-file is called interactively, it prompts for filename in the minibuffer.

— Command: find-file-literally filename
This command visits filename, like find-file does, but it does not perform any format conversions (see Format Conversion), character code conversions (see Coding Systems), or end-of-line conversions (see End of line conversion). The buffer visiting the file is made unibyte, and its major mode is Fundamental mode, regardless of the file name. File local variable specifications in the file (see File Local Variables) are ignored, and automatic decompression and adding a newline at the end of the file due to require-final-newline (see require-final-newline) are also disabled.

Note that if Emacs already has a buffer visiting the same file non-literally, it will not visit the same file literally, but instead just switch to the existing buffer. If you want to be sure of accessing a file's contents literally, you should create a temporary buffer and then read the file contents into it using insert-file-contents-literally (see Reading from Files).

— Function: find-file-noselect filename &optional nowarn rawfile wildcards
This function is the guts of all the file-visiting functions. It returns a buffer visiting the file filename. You may make the buffer current or display it in a window if you wish, but this function does not do so.

The function returns an existing buffer if there is one; otherwise it creates a new buffer and reads the file into it. When find-file-noselect uses an existing buffer, it first verifies that the file has not changed since it was last visited or saved in that buffer. If the file has changed, this function asks the user whether to reread the changed file. If the user says ‘yes’, any edits previously made in the buffer are lost.

Reading the file involves decoding the file's contents (see Coding Systems), including end-of-line conversion, and format conversion (see Format Conversion). If wildcards is non-nil, then find-file-noselect expands wildcard characters in filename and visits all the matching files.

This function displays warning or advisory messages in various peculiar cases, unless the optional argument nowarn is non-nil. For example, if it needs to create a buffer, and there is no file named filename, it displays the message ‘(New file)’ in the echo area, and leaves the buffer empty.

The find-file-noselect function normally calls after-find-file after reading the file (see Subroutines of Visiting). That function sets the buffer major mode, parses local variables, warns the user if there exists an auto-save file more recent than the file just visited, and finishes by running the functions in find-file-hook.

If the optional argument rawfile is non-nil, then after-find-file is not called, and the find-file-not-found-functions are not run in case of failure. What's more, a non-nil rawfile value suppresses coding system conversion and format conversion.

The find-file-noselect function usually returns the buffer that is visiting the file filename. But, if wildcards are actually used and expanded, it returns a list of buffers that are visiting the various files.

          (find-file-noselect "/etc/fstab")
               ⇒ #<buffer fstab>
— Command: find-file-other-window filename &optional wildcards
This command selects a buffer visiting the file filename, but does so in a window other than the selected window. It may use another existing window or split a window; see Switching Buffers.

When this command is called interactively, it prompts for filename.

— Command: find-file-read-only filename &optional wildcards
This command selects a buffer visiting the file filename, like find-file, but it marks the buffer as read-only. See Read Only Buffers, for related functions and variables.

When this command is called interactively, it prompts for filename.

— User Option: find-file-wildcards
If this variable is non-nil, then the various find-file commands check for wildcard characters and visit all the files that match them (when invoked interactively or when their wildcards argument is non-nil). If this option is nil, then the find-file commands ignore their wildcards argument and never treat wildcard characters specially.

— User Option: find-file-hook
The value of this variable is a list of functions to be called after a file is visited. The file's local-variables specification (if any) will have been processed before the hooks are run. The buffer visiting the file is current when the hook functions are run.

This variable is a normal hook. See Hooks.

— Variable: find-file-not-found-functions
The value of this variable is a list of functions to be called when find-file or find-file-noselect is passed a nonexistent file name. find-file-noselect calls these functions as soon as it detects a nonexistent file. It calls them in the order of the list, until one of them returns non-nil. buffer-file-name is already set up.

This is not a normal hook because the values of the functions are used, and in many cases only some of the functions are called.

— Variable: find-file-literally
This buffer-local variable, if set to a non-nil value, makes save-buffer behave as if the buffer were visiting its file literally, i.e., without conversions of any kind. The command find-file-literally sets this variable's local value, but other equivalent functions and commands can do that as well, e.g., to avoid automatic addition of a newline at the end of the file. This variable is permanent local, so it is unaffected by changes of major modes.


*** Subroutines of Visiting: Lower-level subroutines that they use.
The find-file-noselect function uses two important subroutines which are sometimes useful in user Lisp code: create-file-buffer and after-find-file. This section explains how to use them.
— Function: create-file-buffer filename
This function creates a suitably named buffer for visiting filename, and returns it. It uses filename (sans directory) as the name if that name is free; otherwise, it appends a string such as ‘<2>’ to get an unused name. See also Creating Buffers. Note that the uniquify library affects the result of this function. See Uniquify.

Please note: create-file-buffer does not associate the new buffer with a file and does not select the buffer. It also does not use the default major mode.

          (create-file-buffer "foo")
               ⇒ #<buffer foo>
          (create-file-buffer "foo")
               ⇒ #<buffer foo<2>>
          (create-file-buffer "foo")
               ⇒ #<buffer foo<3>>
This function is used by find-file-noselect. It uses generate-new-buffer (see Creating Buffers).

— Function: after-find-file &optional error warn noauto after-find-file-from-revert-buffer nomodes
This function sets the buffer major mode, and parses local variables (see Auto Major Mode). It is called by find-file-noselect and by the default revert function (see Reverting).

If reading the file got an error because the file does not exist, but its directory does exist, the caller should pass a non-nil value for error. In that case, after-find-file issues a warning: ‘(New file)’. For more serious errors, the caller should usually not call after-find-file.

If warn is non-nil, then this function issues a warning if an auto-save file exists and is more recent than the visited file.

If noauto is non-nil, that says not to enable or disable Auto-Save mode. The mode remains enabled if it was enabled before.

If after-find-file-from-revert-buffer is non-nil, that means this call was from revert-buffer. This has no direct effect, but some mode functions and hook functions check the value of this variable.

If nomodes is non-nil, that means don't alter the buffer's major mode, don't process local variables specifications in the file, and don't run find-file-hook. This feature is used by revert-buffer in some cases.

The last thing after-find-file does is call all the functions in the list find-file-hook.


** 2. Saving Buffers: Writing changed buffers back into files.
When you edit a file in Emacs, you are actually working on a buffer that is visiting that file—that is, the contents of the file are copied into the buffer and the copy is what you edit. Changes to the buffer do not change the file until you save the buffer, which means copying the contents of the buffer into the file. Buffers which are not visiting a file can still be “saved”, in a sense, using functions in the buffer-local write-contents-functions hook.

— Command: save-buffer &optional backup-option
This function saves the contents of the current buffer in its visited file if the buffer has been modified since it was last visited or saved. Otherwise it does nothing.

save-buffer is responsible for making backup files. Normally, backup-option is nil, and save-buffer makes a backup file only if this is the first save since visiting the file. Other values for backup-option request the making of backup files in other circumstances:

With an argument of 4 or 64, reflecting 1 or 3 C-u's, the save-buffer function marks this version of the file to be backed up when the buffer is next saved.
With an argument of 16 or 64, reflecting 2 or 3 C-u's, the save-buffer function unconditionally backs up the previous version of the file before saving it.
With an argument of 0, unconditionally do not make any backup file.
— Command: save-some-buffers &optional save-silently-p pred
This command saves some modified file-visiting buffers. Normally it asks the user about each buffer. But if save-silently-p is non-nil, it saves all the file-visiting buffers without querying the user.

The optional pred argument provides a predicate that controls which buffers to ask about (or to save silently if save-silently-p is non-nil). If pred is nil, that means to use the value of save-some-buffers-default-predicate instead of pred. If the result is nil, it means ask only about file-visiting buffers. If it is t, that means also offer to save certain other non-file buffers—those that have a non-nil buffer-local value of buffer-offer-save (see Killing Buffers). A user who says ‘yes’ to saving a non-file buffer is asked to specify the file name to use. The save-buffers-kill-emacs function passes the value t for pred.

If the predicate is neither t nor nil, then it should be a function of no arguments. It will be called in each buffer to decide whether to offer to save that buffer. If it returns a non-nil value in a certain buffer, that means do offer to save that buffer.

— Command: write-file filename &optional confirm
This function writes the current buffer into file filename, makes the buffer visit that file, and marks it not modified. Then it renames the buffer based on filename, appending a string like ‘<2>’ if necessary to make a unique buffer name. It does most of this work by calling set-visited-file-name (see Buffer File Name) and save-buffer.

If confirm is non-nil, that means to ask for confirmation before overwriting an existing file. Interactively, confirmation is required, unless the user supplies a prefix argument.

If filename is a directory name (see Directory Names), write-file uses the name of the visited file, in directory filename. If the buffer is not visiting a file, it uses the buffer name instead.

Saving a buffer runs several hooks. It also performs format conversion (see Format Conversion). Note that these hooks, described below, are only run by save-buffer, they are not run by other primitives and functions that write buffer text to files, and in particular auto-saving (see Auto-Saving) doesn't run these hooks.

— Variable: write-file-functions
The value of this variable is a list of functions to be called before writing out a buffer to its visited file. If one of them returns non-nil, the file is considered already written and the rest of the functions are not called, nor is the usual code for writing the file executed.

If a function in write-file-functions returns non-nil, it is responsible for making a backup file (if that is appropriate). To do so, execute the following code:

          (or buffer-backed-up (backup-buffer))
You might wish to save the file modes value returned by backup-buffer and use that (if non-nil) to set the mode bits of the file that you write. This is what save-buffer normally does. See Making Backup Files.

The hook functions in write-file-functions are also responsible for encoding the data (if desired): they must choose a suitable coding system and end-of-line conversion (see Lisp and Coding Systems), perform the encoding (see Explicit Encoding), and set last-coding-system-used to the coding system that was used (see Encoding and I/O).

If you set this hook locally in a buffer, it is assumed to be associated with the file or the way the contents of the buffer were obtained. Thus the variable is marked as a permanent local, so that changing the major mode does not alter a buffer-local value. On the other hand, calling set-visited-file-name will reset it. If this is not what you want, you might like to use write-contents-functions instead.

Even though this is not a normal hook, you can use add-hook and remove-hook to manipulate the list. See Hooks.

— Variable: write-contents-functions
This works just like write-file-functions, but it is intended for hooks that pertain to the buffer's contents, not to the particular visited file or its location, and can be used to create arbitrary save processes for buffers that aren't visiting files at all. Such hooks are usually set up by major modes, as buffer-local bindings for this variable. This variable automatically becomes buffer-local whenever it is set; switching to a new major mode always resets this variable, but calling set-visited-file-name does not.

If any of the functions in this hook returns non-nil, the file is considered already written and the rest are not called and neither are the functions in write-file-functions.

When using this hook to save buffers that are not visiting files (for instance, special-mode buffers), keep in mind that, if the function fails to save correctly and returns a nil value, save-buffer will go on to prompt the user for a file to save the buffer in. If this is undesirable, consider having the function fail by raising an error.

— User Option: before-save-hook
This normal hook runs before a buffer is saved in its visited file, regardless of whether that is done normally or by one of the hooks described above. For instance, the copyright.el program uses this hook to make sure the file you are saving has the current year in its copyright notice.

— User Option: after-save-hook
This normal hook runs after a buffer has been saved in its visited file. One use of this hook is in Fast Lock mode; it uses this hook to save the highlighting information in a cache file.

— User Option: file-precious-flag
If this variable is non-nil, then save-buffer protects against I/O errors while saving by writing the new file to a temporary name instead of the name it is supposed to have, and then renaming it to the intended name after it is clear there are no errors. This procedure prevents problems such as a lack of disk space from resulting in an invalid file.

As a side effect, backups are necessarily made by copying. See Rename or Copy. Yet, at the same time, saving a precious file always breaks all hard links between the file you save and other file names.

Some modes give this variable a non-nil buffer-local value in particular buffers.

— User Option: require-final-newline
This variable determines whether files may be written out that do not end with a newline. If the value of the variable is t, then save-buffer silently adds a newline at the end of the buffer whenever it does not already end in one. If the value is visit, Emacs adds a missing newline just after it visits the file. If the value is visit-save, Emacs adds a missing newline both on visiting and on saving. For any other non-nil value, save-buffer asks the user whether to add a newline each time the case arises.

If the value of the variable is nil, then save-buffer doesn't add newlines at all. nil is the default value, but a few major modes set it to t in particular buffers.

See also the function set-visited-file-name (see Buffer File Name).

** 3. Reading from Files: Reading files into buffers without visiting.
To copy the contents of a file into a buffer, use the function insert-file-contents. (Don't use the command insert-file in a Lisp program, as that sets the mark.)

— Function: insert-file-contents filename &optional visit beg end replace
This function inserts the contents of file filename into the current buffer after point. It returns a list of the absolute file name and the length of the data inserted. An error is signaled if filename is not the name of a file that can be read.

This function checks the file contents against the defined file formats, and converts the file contents if appropriate and also calls the functions in the list after-insert-file-functions. See Format Conversion. Normally, one of the functions in the after-insert-file-functions list determines the coding system (see Coding Systems) used for decoding the file's contents, including end-of-line conversion. However, if the file contains null bytes, it is by default visited without any code conversions. See inhibit-null-byte-detection.

If visit is non-nil, this function additionally marks the buffer as unmodified and sets up various fields in the buffer so that it is visiting the file filename: these include the buffer's visited file name and its last save file modtime. This feature is used by find-file-noselect and you probably should not use it yourself.

If beg and end are non-nil, they should be numbers that are byte offsets specifying the portion of the file to insert. In this case, visit must be nil. For example,

          (insert-file-contents filename nil 0 500)
inserts the first 500 characters of a file.

If the argument replace is non-nil, it means to replace the contents of the buffer (actually, just the accessible portion) with the contents of the file. This is better than simply deleting the buffer contents and inserting the whole file, because (1) it preserves some marker positions and (2) it puts less data in the undo list.

It is possible to read a special file (such as a FIFO or an I/O device) with insert-file-contents, as long as replace and visit are nil.

— Function: insert-file-contents-literally filename &optional visit beg end replace
This function works like insert-file-contents except that it does not run after-insert-file-functions, and does not do format decoding, character code conversion, automatic uncompression, and so on.

If you want to pass a file name to another process so that another program can read the file, use the function file-local-copy; see Magic File Names.

** 4. Writing to Files: Writing new files from parts of buffers.
You can write the contents of a buffer, or part of a buffer, directly to a file on disk using the append-to-file and write-region functions. Don't use these functions to write to files that are being visited; that could cause confusion in the mechanisms for visiting.

— Command: append-to-file start end filename
This function appends the contents of the region delimited by start and end in the current buffer to the end of file filename. If that file does not exist, it is created. This function returns nil.

An error is signaled if filename specifies a nonwritable file, or a nonexistent file in a directory where files cannot be created.

When called from Lisp, this function is completely equivalent to:

          (write-region start end filename t)
— Command: write-region start end filename &optional append visit lockname mustbenew
This function writes the region delimited by start and end in the current buffer into the file specified by filename.

If start is nil, then the command writes the entire buffer contents (not just the accessible portion) to the file and ignores end.
If start is a string, then write-region writes or appends that string, rather than text from the buffer. end is ignored in this case.

If append is non-nil, then the specified text is appended to the existing file contents (if any). If append is a number, write-region seeks to that byte offset from the start of the file and writes the data from there.

If mustbenew is non-nil, then write-region asks for confirmation if filename names an existing file. If mustbenew is the symbol excl, then write-region does not ask for confirmation, but instead it signals an error file-already-exists if the file already exists. Although write-region normally follows a symbolic link and creates the pointed-to file if the symbolic link is dangling, it does not follow symbolic links if mustbenew is excl.

The test for an existing file, when mustbenew is excl, uses a special system feature. At least for files on a local disk, there is no chance that some other program could create a file of the same name before Emacs does, without Emacs's noticing.

If visit is t, then Emacs establishes an association between the buffer and the file: the buffer is then visiting that file. It also sets the last file modification time for the current buffer to filename's modtime, and marks the buffer as not modified. This feature is used by save-buffer, but you probably should not use it yourself.
If visit is a string, it specifies the file name to visit. This way, you can write the data to one file (filename) while recording the buffer as visiting another file (visit). The argument visit is used in the echo area message and also for file locking; visit is stored in buffer-file-name. This feature is used to implement file-precious-flag; don't use it yourself unless you really know what you're doing.

The optional argument lockname, if non-nil, specifies the file name to use for purposes of locking and unlocking, overriding filename and visit for that purpose.

The function write-region converts the data which it writes to the appropriate file formats specified by buffer-file-format and also calls the functions in the list write-region-annotate-functions. See Format Conversion.

Normally, write-region displays the message ‘Wrote filename’ in the echo area. This message is inhibited if visit is neither t nor nil nor a string, or if Emacs is operating in batch mode (see Batch Mode). This feature is useful for programs that use files for internal purposes, files that the user does not need to know about.

— Variable: write-region-inhibit-fsync
If this variable's value is nil, write-region uses the fsync system call after writing a file. Although this slows Emacs down, it lessens the risk of data loss after power failure. If the value is t, Emacs does not use fsync. The default value is nil when Emacs is interactive, and t when Emacs runs in batch mode. See Files and Storage.

— Macro: with-temp-file file body...
The with-temp-file macro evaluates the body forms with a temporary buffer as the current buffer; then, at the end, it writes the buffer contents into file file. It kills the temporary buffer when finished, restoring the buffer that was current before the with-temp-file form. Then it returns the value of the last form in body.

The current buffer is restored even in case of an abnormal exit via throw or error (see Nonlocal Exits).

See also with-temp-buffer in The Current Buffer.

** 5. File Locks: Locking and unlocking files, to prevent simultaneous editing by two people.
When two users edit the same file at the same time, they are likely to interfere with each other. Emacs tries to prevent this situation from arising by recording a file lock when a file is being modified. Emacs can then detect the first attempt to modify a buffer visiting a file that is locked by another Emacs job, and ask the user what to do. The file lock is really a file, a symbolic link with a special name, stored in the same directory as the file you are editing. The name is constructed by prepending .# to the filename of the buffer. The target of the symbolic link will be of the form user@host.pid:boot, where user is replaced with the current username (from user-login-name), host with the name of the host where Emacs is running (from system-name), pid with Emacs's process id, and boot with the time since the last reboot. :boot is omitted if the boot time is unavailable. (On file systems that do not support symbolic links, a regular file is used instead, with contents of the form user@host.pid:boot.)

When you access files using NFS, there may be a small probability that you and another user will both lock the same file simultaneously. If this happens, it is possible for the two users to make changes simultaneously, but Emacs will still warn the user who saves second. Also, the detection of modification of a buffer visiting a file changed on disk catches some cases of simultaneous editing; see Modification Time.

— Function: file-locked-p filename
This function returns nil if the file filename is not locked. It returns t if it is locked by this Emacs process, and it returns the name of the user who has locked it if it is locked by some other job.

          (file-locked-p "foo")
               ⇒ nil
— Function: lock-buffer &optional filename
This function locks the file filename, if the current buffer is modified. The argument filename defaults to the current buffer's visited file. Nothing is done if the current buffer is not visiting a file, or is not modified, or if the option create-lockfiles is nil.

— Function: unlock-buffer
This function unlocks the file being visited in the current buffer, if the buffer is modified. If the buffer is not modified, then the file should not be locked, so this function does nothing. It also does nothing if the current buffer is not visiting a file, or is not locked.

— User Option: create-lockfiles
If this variable is nil, Emacs does not lock files.

— Function: ask-user-about-lock file other-user
This function is called when the user tries to modify file, but it is locked by another user named other-user. The default definition of this function asks the user to say what to do. The value this function returns determines what Emacs does next:

A value of t says to grab the lock on the file. Then this user may edit the file and other-user loses the lock.
A value of nil says to ignore the lock and let this user edit the file anyway.
This function may instead signal a file-locked error, in which case the change that the user was about to make does not take place.
The error message for this error looks like this:

               error--> File is locked: file other-user
where file is the name of the file and other-user is the name of the user who has locked the file.

If you wish, you can replace the ask-user-about-lock function with your own version that makes the decision in another way.

** 6. Information about Files: Testing existence, accessibility, size of files.
This section describes the functions for retrieving various types of information about files (or directories or symbolic links), such as whether a file is readable or writable, and its size. These functions all take arguments which are file names. Except where noted, these arguments need to specify existing files, or an error is signaled.

Be careful with file names that end in spaces. On some filesystems (notably, MS-Windows), trailing whitespace characters in file names are silently and automatically ignored.

*** 1. Testing Accessibility: Is a given file readable? Writable?
These functions test for permission to access a file for reading, writing, or execution. Unless explicitly stated otherwise, they follow symbolic links. See Kinds of Files.

On some operating systems, more complex sets of access permissions can be specified, via mechanisms such as Access Control Lists (ACLs). See Extended Attributes, for how to query and set those permissions.

— Function: file-exists-p filename
This function returns t if a file named filename appears to exist. This does not mean you can necessarily read the file, only that you can find out its attributes. (On GNU and other POSIX-like systems, this is true if the file exists and you have execute permission on the containing directories, regardless of the permissions of the file itself.)

If the file does not exist, or if access control policies prevent you from finding its attributes, this function returns nil.

Directories are files, so file-exists-p can return t when given a directory. However, because file-exists-p follows symbolic links, it returns t for a symbolic link name only if the target file exists.

— Function: file-readable-p filename
This function returns t if a file named filename exists and you can read it. It returns nil otherwise.

— Function: file-executable-p filename
This function returns t if a file named filename exists and you can execute it. It returns nil otherwise. On GNU and other POSIX-like systems, if the file is a directory, execute permission means you can check the existence and attributes of files inside the directory, and open those files if their modes permit.

— Function: file-writable-p filename
This function returns t if the file filename can be written or created by you, and nil otherwise. A file is writable if the file exists and you can write it. It is creatable if it does not exist, but the specified directory does exist and you can write in that directory.

In the example below, foo is not writable because the parent directory does not exist, even though the user could create such a directory.

          (file-writable-p "~/no-such-dir/foo")
               ⇒ nil
— Function: file-accessible-directory-p dirname
This function returns t if you have permission to open existing files in the directory whose name as a file is dirname; otherwise (or if there is no such directory), it returns nil. The value of dirname may be either a directory name (such as /foo/) or the file name of a file which is a directory (such as /foo, without the final slash).

For example, from the following we deduce that any attempt to read a file in /foo/ will give an error:

          (file-accessible-directory-p "/foo")
               ⇒ nil
— Function: access-file filename string
This function opens file filename for reading, then closes it and returns nil. However, if the open fails, it signals an error using string as the error message text.

— Function: file-ownership-preserved-p filename &optional group
This function returns t if deleting the file filename and then creating it anew would keep the file's owner unchanged. It also returns t for nonexistent files.

If the optional argument group is non-nil, this function also checks that the file's group would be unchanged.

This function does not follow symbolic links.

— Function: file-modes filename
This function returns the mode bits of filename—an integer summarizing its read, write, and execution permissions. This function follows symbolic links. If the file does not exist, the return value is nil.

See File permissions, for a description of mode bits. For example, if the low-order bit is 1, the file is executable by all users; if the second-lowest-order bit is 1, the file is writable by all users; etc. The highest possible value is 4095 (7777 octal), meaning that everyone has read, write, and execute permission, the SUID bit is set for both others and group, and the sticky bit is set.

See Changing Files, for the set-file-modes function, which can be used to set these permissions.

          (file-modes "~/junk/diffs")
               ⇒ 492               ; Decimal integer.
          (format "%o" 492)
               ⇒ "754"             ; Convert to octal.

          (set-file-modes "~/junk/diffs" #o666)
               ⇒ nil

          $ ls -l diffs
          -rw-rw-rw- 1 lewis lewis 3063 Oct 30 16:00 diffs
MS-DOS note: On MS-DOS, there is no such thing as an executable file mode bit. So file-modes considers a file executable if its name ends in one of the standard executable extensions, such as .com, .bat, .exe, and some others. Files that begin with the POSIX-standard ‘#!’ signature, such as shell and Perl scripts, are also considered executable. Directories are also reported as executable, for compatibility with POSIX. These conventions are also followed by file-attributes (see File Attributes).

*** 2. Kinds of Files: Is it a directory? A symbolic link?
This section describes how to distinguish various kinds of files, such as directories, symbolic links, and ordinary files.

Symbolic links are ordinarily followed wherever they appear. For example, to interpret the file name a/b/c, any of a, a/b, and a/b/c can be symbolic links that are followed, possibly recursively if the link targets are themselves symbolic links. However, a few functions do not follow symbolic links at the end of a file name (a/b/c in this example). Such a function is said to not follow symbolic links.

— Function: file-symlink-p filename
If the file filename is a symbolic link, this function does not follow it and instead returns its link target as a string. (The link target string is not necessarily the full absolute file name of the target; determining the full file name that the link points to is nontrivial, see below.)

If the file filename is not a symbolic link, or does not exist, file-symlink-p returns nil.

Here are a few examples of using this function:

          (file-symlink-p "not-a-symlink")
               ⇒ nil
          (file-symlink-p "sym-link")
               ⇒ "not-a-symlink"
          (file-symlink-p "sym-link2")
               ⇒ "sym-link"
          (file-symlink-p "/bin")
               ⇒ "/pub/bin"
Note that in the third example, the function returned sym-link, but did not proceed to resolve it, although that file is itself a symbolic link. That is because this function does not follow symbolic links—the process of following the symbolic links does not apply to the last component of the file name.

The string that this function returns is what is recorded in the symbolic link; it may or may not include any leading directories. This function does not expand the link target to produce a fully-qualified file name, and in particular does not use the leading directories, if any, of the filename argument if the link target is not an absolute file name. Here's an example:

          (file-symlink-p "/foo/bar/baz")
               ⇒ "some-file"
Here, although /foo/bar/baz was given as a fully-qualified file name, the result is not, and in fact does not have any leading directories at all. And since some-file might itself be a symbolic link, you cannot simply prepend leading directories to it, nor even naively use expand-file-name (see File Name Expansion) to produce its absolute file name.

For this reason, this function is seldom useful if you need to determine more than just the fact that a file is or isn't a symbolic link. If you actually need the file name of the link target, use file-chase-links or file-truename, described in Truenames.

— Function: file-directory-p filename
This function returns t if filename is the name of an existing directory, nil otherwise. This function follows symbolic links.

          (file-directory-p "~rms")
               ⇒ t
          (file-directory-p "~rms/lewis/files.texi")
               ⇒ nil
          (file-directory-p "~rms/lewis/no-such-file")
               ⇒ nil
          (file-directory-p "$HOME")
               ⇒ nil
          (file-directory-p
           (substitute-in-file-name "$HOME"))
               ⇒ t
— Function: file-regular-p filename
This function returns t if the file filename exists and is a regular file (not a directory, named pipe, terminal, or other I/O device). This function follows symbolic links.
*** 3. Truenames: Eliminating symbolic links from a file name.
The truename of a file is the name that you get by following symbolic links at all levels until none remain, then simplifying away ‘.’ and ‘..’ appearing as name components. This results in a sort of canonical name for the file. A file does not always have a unique truename; the number of distinct truenames a file has is equal to the number of hard links to the file. However, truenames are useful because they eliminate symbolic links as a cause of name variation.

— Function: file-truename filename
This function returns the truename of the file filename. If the argument is not an absolute file name, this function first expands it against default-directory.

This function does not expand environment variables. Only substitute-in-file-name does that. See Definition of substitute-in-file-name.

If you may need to follow symbolic links preceding ‘..’ appearing as a name component, call file-truename without prior direct or indirect calls to expand-file-name. Otherwise, the file name component immediately preceding ‘..’ will be simplified away before file-truename is called. To eliminate the need for a call to expand-file-name, file-truename handles ‘~’ in the same way that expand-file-name does.

If the target of a symbolic links has remote file name syntax, file-truename returns it quoted. See Functions that Expand Filenames.

— Function: file-chase-links filename &optional limit
This function follows symbolic links, starting with filename, until it finds a file name which is not the name of a symbolic link. Then it returns that file name. This function does not follow symbolic links at the level of parent directories.

If you specify a number for limit, then after chasing through that many links, the function just returns what it has even if that is still a symbolic link.

To illustrate the difference between file-chase-links and file-truename, suppose that /usr/foo is a symbolic link to the directory /home/foo, and /home/foo/hello is an ordinary file (or at least, not a symbolic link) or nonexistent. Then we would have:

     (file-chase-links "/usr/foo/hello")
          ;; This does not follow the links in the parent directories.
          ⇒ "/usr/foo/hello"
     (file-truename "/usr/foo/hello")
          ;; Assuming that /home is not a symbolic link.
          ⇒ "/home/foo/hello"
— Function: file-equal-p file1 file2
This function returns t if the files file1 and file2 name the same file. This is similar to comparing their truenames, except that remote file names are also handled in an appropriate manner. If file1 or file2 does not exist, the return value is unspecified.

— Function: file-name-case-insensitive-p filename
Sometimes file names or their parts need to be compared as strings, in which case it's important to know whether the underlying filesystem is case-insensitive. This function returns t if file filename is on a case-insensitive filesystem. It always returns t on MS-DOS and MS-Windows. On Cygwin and macOS, filesystems may or may not be case-insensitive, and the function tries to determine case-sensitivity by a runtime test. If the test is inconclusive, the function returns t on Cygwin and nil on macOS.

Currently this function always returns nil on platforms other than MS-DOS, MS-Windows, Cygwin, and macOS. It does not detect case-insensitivity of mounted filesystems, such as Samba shares or NFS-mounted Windows volumes. On remote hosts, it assumes t for the ‘smb’ method. For all other connection methods, runtime tests are performed.

— Function: file-in-directory-p file dir
This function returns t if file is a file in directory dir, or in a subdirectory of dir. It also returns t if file and dir are the same directory. It compares the truenames of the two directories. If dir does not name an existing directory, the return value is nil.

— Function: vc-responsible-backend file
This function determines the responsible VC backend of the given file. For example, if emacs.c is a file tracked by Git, (vc-responsible-backend "emacs.c") returns ‘Git’. Note that if file is a symbolic link, vc-responsible-backend will not resolve it—the backend of the symbolic link file itself is reported. To get the backend VC of the file to which file refers, wrap file with a symbolic link resolving function such as file-chase-links:

          (vc-responsible-backend (file-chase-links "emacs.c"))

*** 4. File Attributes: File sizes, modification times, etc.
This section describes the functions for getting detailed information about a file, including the owner and group numbers, the number of names, the inode number, the size, and the times of access and modification.

— Function: file-newer-than-file-p filename1 filename2
This function returns t if the file filename1 is newer than file filename2. If filename1 does not exist, it returns nil. If filename1 does exist, but filename2 does not, it returns t.

In the following example, assume that the file aug-19 was written on the 19th, aug-20 was written on the 20th, and the file no-file doesn't exist at all.

          (file-newer-than-file-p "aug-19" "aug-20")
               ⇒ nil
          (file-newer-than-file-p "aug-20" "aug-19")
               ⇒ t
          (file-newer-than-file-p "aug-19" "no-file")
               ⇒ t
          (file-newer-than-file-p "no-file" "aug-19")
               ⇒ nil
— Function: file-attributes filename &optional id-format
This function returns a list of attributes of file filename. If the specified file's attributes cannot be accessed, it returns nil. This function does not follow symbolic links. The optional parameter id-format specifies the preferred format of attributes UID and GID (see below)—the valid values are 'string and 'integer. The latter is the default, but we plan to change that, so you should specify a non-nil value for id-format if you use the returned UID or GID.

On GNU platforms when operating on a local file, this function is atomic: if the filesystem is simultaneously being changed by some other process, this function returns the file's attributes either before or after the change. Otherwise this function is not atomic, and might return nil if it detects the race condition, or might return a hodgepodge of the previous and current file attributes.

Accessor functions are provided to access the elements in this list. The accessors are mentioned along with the descriptions of the elements below.

The elements of the list, in order, are:

t for a directory, a string for a symbolic link (the name linked to), or nil for a text file (file-attribute-type).
The number of names the file has (file-attribute-link-number). Alternate names, also known as hard links, can be created by using the add-name-to-file function (see Changing Files).
The file's UID, normally as a string (file-attribute-user-id). However, if it does not correspond to a named user, the value is a number.
The file's GID, likewise (file-attribute-group-id).
The time of last access, as a list of four integers (sec-high sec-low microsec picosec) (file-attribute-access-time). (This is similar to the value of current-time; see Time of Day.) The value is truncated to that of the filesystem's timestamp resolution; for example, on some FAT-based filesystems, only the date of last access is recorded, so this time will always hold the midnight of the day of the last access.

The time of last modification as a list of four integers (as above) (file-attribute-modification-time). This is the last time when the file's contents were modified.
The time of last status change as a list of four integers (as above) (file-attribute-status-change-time). This is the time of the last change to the file's access mode bits, its owner and group, and other information recorded in the filesystem for the file, beyond the file's contents.
The size of the file in bytes (file-attribute-size). This is floating point if the size is too large to fit in a Lisp integer.
The file's modes, as a string of ten letters or dashes, as in ‘ls -l’ (file-attribute-modes).
An unspecified value, present for backward compatibility.
The file's inode number (file-attribute-inode-number). If possible, this is an integer. If the inode number is too large to be represented as an integer in Emacs Lisp but dividing it by 2^16 yields a representable integer, then the value has the form (high . low), where low holds the low 16 bits. If the inode number is too wide for even that, the value is of the form (high middle . low), where high holds the high bits, middle the middle 24 bits, and low the low 16 bits.
The filesystem number of the device that the file is on file-attribute-device-number). Depending on the magnitude of the value, this can be either an integer or a cons cell, in the same manner as the inode number. This element and the file's inode number together give enough information to distinguish any two files on the system—no two files can have the same values for both of these numbers.
For example, here are the file attributes for files.texi:

          (file-attributes "files.texi" 'string)
               ⇒  (nil 1 "lh" "users"
                    (20614 64019 50040 152000)
                    (20000 23 0 0)
                    (20614 64555 902289 872000)
                    122295 "-rw-rw-rw-"
                    t (5888 2 . 43978)
                    (15479 . 46724))
and here is how the result is interpreted:

nil
is neither a directory nor a symbolic link.
1
has only one name (the name files.texi in the current default directory).
"lh"
is owned by the user with name ‘lh’.
"users"
is in the group with name ‘users’.
(20614 64019 50040 152000)
was last accessed on October 23, 2012, at 20:12:03.050040152 UTC.
(20000 23 0 0)
was last modified on July 15, 2001, at 08:53:43 UTC.
(20614 64555 902289 872000)
last had its status changed on October 23, 2012, at 20:20:59.902289872 UTC.
122295
is 122295 bytes long. (It may not contain 122295 characters, though, if some of the bytes belong to multibyte sequences, and also if the end-of-line format is CR-LF.)
"-rw-rw-rw-"
has a mode of read and write access for the owner, group, and world.
t
is merely a placeholder; it carries no information.
(5888 2 . 43978)
has an inode number of 6473924464520138.
(15479 . 46724)
is on the file-system device whose number is 1014478468.
— Function: file-nlinks filename
This function returns the number of names (i.e., hard links) that file filename has. If the file does not exist, this function returns nil. Note that symbolic links have no effect on this function, because they are not considered to be names of the files they link to. This function does not follow symbolic links.

          $ ls -l foo*
          -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo
          -rw-rw-rw- 2 rms rms 4 Aug 19 01:27 foo1

          (file-nlinks "foo")
               ⇒ 2
          (file-nlinks "doesnt-exist")
               ⇒ nil


*** 5. Extended Attributes: Extended file attributes for access control.
On some operating systems, each file can be associated with arbitrary extended file attributes. At present, Emacs supports querying and setting two specific sets of extended file attributes: Access Control Lists (ACLs) and SELinux contexts. These extended file attributes are used, on some systems, to impose more sophisticated file access controls than the basic Unix-style permissions discussed in the previous sections.

A detailed explanation of ACLs and SELinux is beyond the scope of this manual. For our purposes, each file can be associated with an ACL, which specifies its properties under an ACL-based file control system, and/or an SELinux context, which specifies its properties under the SELinux system.

— Function: file-acl filename
This function returns the ACL for the file filename. The exact Lisp representation of the ACL is unspecified (and may change in future Emacs versions), but it is the same as what set-file-acl takes for its acl argument (see Changing Files).

The underlying ACL implementation is platform-specific; on GNU/Linux and BSD, Emacs uses the POSIX ACL interface, while on MS-Windows Emacs emulates the POSIX ACL interface with native file security APIs.

If Emacs was not compiled with ACL support, or the file does not exist or is inaccessible, or Emacs was unable to determine the ACL entries for any other reason, then the return value is nil.

— Function: file-selinux-context filename
This function returns the SELinux context of the file filename, as a list of the form (user role type range). The list elements are the context's user, role, type, and range respectively, as Lisp strings; see the SELinux documentation for details about what these actually mean. The return value has the same form as what set-file-selinux-context takes for its context argument (see Changing Files).

If Emacs was not compiled with SELinux support, or the file does not exist or is inaccessible, or if the system does not support SELinux, then the return value is (nil nil nil nil).

— Function: file-extended-attributes filename
This function returns an alist of the Emacs-recognized extended attributes of file filename. Currently, it serves as a convenient way to retrieve both the ACL and SELinux context; you can then call the function set-file-extended-attributes, with the returned alist as its second argument, to apply the same file access attributes to another file (see Changing Files).

One of the elements is (acl . acl), where acl has the same form returned by file-acl.

Another element is (selinux-context . context), where context is the SELinux context, in the same form returned by file-selinux-context.

*** 6. Locating Files: How to find a file in standard places.
This section explains how to search for a file in a list of directories (a path), or for an executable file in the standard list of executable file directories.

To search for a user-specific configuration file, See Standard File Names, for the locate-user-emacs-file function.

— Function: locate-file filename path &optional suffixes predicate
This function searches for a file whose name is filename in a list of directories given by path, trying the suffixes in suffixes. If it finds such a file, it returns the file's absolute file name (see Relative File Names); otherwise it returns nil.

The optional argument suffixes gives the list of file-name suffixes to append to filename when searching. locate-file tries each possible directory with each of these suffixes. If suffixes is nil, or (""), then there are no suffixes, and filename is used only as-is. Typical values of suffixes are exec-suffixes (see Subprocess Creation), load-suffixes, load-file-rep-suffixes and the return value of the function get-load-suffixes (see Load Suffixes).

Typical values for path are exec-path (see Subprocess Creation) when looking for executable programs, or load-path (see Library Search) when looking for Lisp files. If filename is absolute, path has no effect, but the suffixes in suffixes are still tried.

The optional argument predicate, if non-nil, specifies a predicate function for testing whether a candidate file is suitable. The predicate is passed the candidate file name as its single argument. If predicate is nil or omitted, locate-file uses file-readable-p as the predicate. See Kinds of Files, for other useful predicates, e.g., file-executable-p and file-directory-p.

This function will normally skip directories, so if you want it to find directories, make sure the predicate function returns dir-ok for them. For example:

          (locate-file "html" '("/var/www" "/srv") nil
                       (lambda (f) (if (file-directory-p f) 'dir-ok)))
For compatibility, predicate can also be one of the symbols executable, readable, writable, exists, or a list of one or more of these symbols.

— Function: executable-find program
This function searches for the executable file of the named program and returns the absolute file name of the executable, including its file-name extensions, if any. It returns nil if the file is not found. The functions searches in all the directories in exec-path, and tries all the file-name extensions in exec-suffixes (see Subprocess Creation).

** 7. Changing Files: Renaming files, changing permissions, etc.
The functions in this section rename, copy, delete, link, and set the modes (permissions) of files. Typically, they signal a file-error error if they fail to perform their function, reporting the system-dependent error message that describes the reason for the failure. If they fail because a file is missing, they signal a file-missing error instead.

For performance, the operating system may cache or alias changes made by these functions instead of writing them immediately to secondary storage. See Files and Storage.

In the functions that have an argument newname, if this argument is a directory name it is treated as if the nondirectory part of the source name were appended. Typically, a directory name is one that ends in ‘/’ (see Directory Names). For example, if the old name is a/b/c, the newname d/e/f/ is treated as if it were d/e/f/c. This special treatment does not apply if newname is not a directory name but names a file that is a directory; for example, the newname d/e/f is left as-is even if d/e/f happens to be a directory.

In the functions that have an argument newname, if a file by the name of newname already exists, the actions taken depend on the value of the argument ok-if-already-exists:

Signal a file-already-exists error if ok-if-already-exists is nil.
Request confirmation if ok-if-already-exists is a number.
Replace the old file without confirmation if ok-if-already-exists is any other value.
— Command: add-name-to-file oldname newname &optional ok-if-already-exists
This function gives the file named oldname the additional name newname. This means that newname becomes a new hard link to oldname.

If newname is a symbolic link, its directory entry is replaced, not the directory entry it points to. If oldname is a symbolic link, this function might or might not follow the link; it does not follow the link on GNU platforms. If oldname is a directory, this function typically fails, although for the superuser on a few old-fashioned non-GNU platforms it can succeed and create a filesystem that is not tree-structured.

In the first part of the following example, we list two files, foo and foo3.

          $ ls -li fo*
          81908 -rw-rw-rw- 1 rms rms 29 Aug 18 20:32 foo
          84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3
Now we create a hard link, by calling add-name-to-file, then list the files again. This shows two names for one file, foo and foo2.

          (add-name-to-file "foo" "foo2")
               ⇒ nil

          $ ls -li fo*
          81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo
          81908 -rw-rw-rw- 2 rms rms 29 Aug 18 20:32 foo2
          84302 -rw-rw-rw- 1 rms rms 24 Aug 18 20:31 foo3
Finally, we evaluate the following:

          (add-name-to-file "foo" "foo3" t)
and list the files again. Now there are three names for one file: foo, foo2, and foo3. The old contents of foo3 are lost.

          (add-name-to-file "foo1" "foo3")
               ⇒ nil

          $ ls -li fo*
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo2
          81908 -rw-rw-rw- 3 rms rms 29 Aug 18 20:32 foo3
This function is meaningless on operating systems where multiple names for one file are not allowed. Some systems implement multiple names by copying the file instead.

See also file-nlinks in File Attributes.

— Command: rename-file filename newname &optional ok-if-already-exists
This command renames the file filename as newname.

If filename has additional names aside from filename, it continues to have those names. In fact, adding the name newname with add-name-to-file and then deleting filename has the same effect as renaming, aside from momentary intermediate states and treatment of errors, directories and symbolic links.

This command does not follow symbolic links. If filename is a symbolic link, this command renames the symbolic link, not the file it points to. If newname is a symbolic link, its directory entry is replaced, not the directory entry it points to.

This command does nothing if filename and newname are the same directory entry, i.e., if they refer to the same parent directory and give the same name within that directory. Otherwise, if filename and newname name the same file, this command does nothing on POSIX-conforming systems, and removes filename on some non-POSIX systems.

If newname exists, then it must be an empty directory if oldname is a directory and a non-directory otherwise.

— Command: copy-file oldname newname &optional ok-if-already-exists time preserve-uid-gid preserve-extended-attributes
This command copies the file oldname to newname. An error is signaled if oldname is not a regular file. If newname names a directory, it copies oldname into that directory, preserving its final name component.
This function follows symbolic links, except that it does not follow a dangling symbolic link to create newname.

If time is non-nil, then this function gives the new file the same last-modified time that the old one has. (This works on only some operating systems.) If setting the time gets an error, copy-file signals a file-date-error error. In an interactive call, a prefix argument specifies a non-nil value for time.

If argument preserve-uid-gid is nil, we let the operating system decide the user and group ownership of the new file (this is usually set to the user running Emacs). If preserve-uid-gid is non-nil, we attempt to copy the user and group ownership of the file. This works only on some operating systems, and only if you have the correct permissions to do so.

If the optional argument preserve-permissions is non-nil, this function copies the file modes (or “permissions”) of oldname to newname, as well as the Access Control List and SELinux context (if any). See Information about Files.

Otherwise, the file modes of newname are left unchanged if it is an existing file, and set to those of oldname, masked by the default file permissions (see set-default-file-modes below), if newname is to be newly created. The Access Control List or SELinux context are not copied over in either case.

— Command: make-symbolic-link target newname &optional ok-if-already-exists
This command makes a symbolic link to target, named newname. This is like the shell command ‘ln -s target newname’. The target argument is treated only as a string; it need not name an existing file. If ok-if-already-exists is an integer, indicating interactive use, then leading ‘~’ is expanded and leading ‘/:’ is stripped in the target string.

If target is a relative file name, the resulting symbolic link is interpreted relative to the directory containing the symbolic link. See Relative File Names.

If both target and newname have remote file name syntax, and if both remote identifications are equal, the symbolic link points to the local file name part of target.

This function is not available on systems that don't support symbolic links.


— Command: delete-file filename &optional trash
This command deletes the file filename. If the file has multiple names, it continues to exist under the other names. If filename is a symbolic link, delete-file deletes only the symbolic link and not its target.

A suitable kind of file-error error is signaled if the file does not exist, or is not deletable. (On GNU and other POSIX-like systems, a file is deletable if its directory is writable.)

If the optional argument trash is non-nil and the variable delete-by-moving-to-trash is non-nil, this command moves the file into the system Trash instead of deleting it. See Miscellaneous File Operations. When called interactively, trash is t if no prefix argument is given, and nil otherwise.

See also delete-directory in Create/Delete Dirs.


— Command: set-file-modes filename mode
This function sets the file mode (or permissions) of filename to mode. This function follows symbolic links.

If called non-interactively, mode must be an integer. Only the lowest 12 bits of the integer are used; on most systems, only the lowest 9 bits are meaningful. You can use the Lisp construct for octal numbers to enter mode. For example,

          (set-file-modes #o644)
specifies that the file should be readable and writable for its owner, readable for group members, and readable for all other users. See File permissions, for a description of mode bit specifications.

Interactively, mode is read from the minibuffer using read-file-modes (see below), which lets the user type in either an integer or a string representing the permissions symbolically.

See File Attributes, for the function file-modes, which returns the permissions of a file.

— Function: set-default-file-modes mode
This function sets the default permissions for new files created by Emacs and its subprocesses. Every file created with Emacs initially has these permissions, or a subset of them (write-region will not grant execute permissions even if the default file permissions allow execution). On GNU and other POSIX-like systems, the default permissions are given by the bitwise complement of the ‘umask’ value, i.e. each bit that is set in the argument mode will be reset in the default permissions with which Emacs creates files.

The argument mode should be an integer which specifies the permissions, similar to set-file-modes above. Only the lowest 9 bits are meaningful.

The default file permissions have no effect when you save a modified version of an existing file; saving a file preserves its existing permissions.

— Macro: with-file-modes mode body...
This macro evaluates the body forms with the default permissions for new files temporarily set to modes (whose value is as for set-file-modes above). When finished, it restores the original default file permissions, and returns the value of the last form in body.

This is useful for creating private files, for example.

— Function: default-file-modes
This function returns the default file permissions, as an integer.

— Function: read-file-modes &optional prompt base-file
This function reads a set of file mode bits from the minibuffer. The first optional argument prompt specifies a non-default prompt. Second second optional argument base-file is the name of a file on whose permissions to base the mode bits that this function returns, if what the user types specifies mode bits relative to permissions of an existing file.

If user input represents an octal number, this function returns that number. If it is a complete symbolic specification of mode bits, as in "u=rwx", the function converts it to the equivalent numeric value using file-modes-symbolic-to-number and returns the result. If the specification is relative, as in "o+g", then the permissions on which the specification is based are taken from the mode bits of base-file. If base-file is omitted or nil, the function uses 0 as the base mode bits. The complete and relative specifications can be combined, as in "u+r,g+rx,o+r,g-w". See File permissions, for a description of file mode specifications.

— Function: file-modes-symbolic-to-number modes &optional base-modes
This function converts a symbolic file mode specification in modes into the equivalent integer. If the symbolic specification is based on an existing file, that file's mode bits are taken from the optional argument base-modes; if that argument is omitted or nil, it defaults to 0, i.e., no access rights at all.

— Function: set-file-times filename &optional time
This function sets the access and modification times of filename to time. The return value is t if the times are successfully set, otherwise it is nil. time defaults to the current time and must be a time value (see Time of Day).

— Function: set-file-extended-attributes filename attribute-alist
This function sets the Emacs-recognized extended file attributes for filename. The second argument attribute-alist should be an alist of the same form returned by file-extended-attributes. The return value is t if the attributes are successfully set, otherwise it is nil. See Extended Attributes.

— Function: set-file-selinux-context filename context
This function sets the SELinux security context for filename to context. The context argument should be a list (user role type range), where each element is a string. See Extended Attributes.

The function returns t if it succeeds in setting the SELinux context of filename. It returns nil if the context was not set (e.g., if SELinux is disabled, or if Emacs was compiled without SELinux support).

— Function: set-file-acl filename acl
This function sets the Access Control List for filename to acl. The acl argument should have the same form returned by the function file-acl. See Extended Attributes.

The function returns t if it successfully sets the ACL of filename, nil otherwise.

** 8. Files and Storage: Surviving power and media failures
After Emacs changes a file, there are two reasons the changes might not survive later failures of power or media, both having to do with efficiency. First, the operating system might alias written data with data already stored elsewhere on secondary storage until one file or the other is later modified; this will lose both files if the only copy on secondary storage is lost due to media failure. Second, the operating system might not write data to secondary storage immediately, which will lose the data if power is lost.

Although both sorts of failures can largely be avoided by a suitably configured file system, such systems are typically more expensive or less efficient. In more-typical systems, to survive media failure you can copy the file to a different device, and to survive a power failure you can use the write-region function with the write-region-inhibit-fsync variable set to nil. See Writing to Files.

** 9. File Names: Decomposing and expanding file names.
Files are generally referred to by their names, in Emacs as elsewhere. File names in Emacs are represented as strings. The functions that operate on a file all expect a file name argument.

In addition to operating on files themselves, Emacs Lisp programs often need to operate on file names; i.e., to take them apart and to use part of a name to construct related file names. This section describes how to manipulate file names.

The functions in this section do not actually access files, so they can operate on file names that do not refer to an existing file or directory.

On MS-DOS and MS-Windows, these functions (like the function that actually operate on files) accept MS-DOS or MS-Windows file-name syntax, where backslashes separate the components, as well as POSIX syntax; but they always return POSIX syntax. This enables Lisp programs to specify file names in POSIX syntax and work properly on all systems without change.14

*** 1. File Name Components: The directory part of a file name, and the rest.
The operating system groups files into directories. To specify a file, you must specify the directory and the file's name within that directory. Therefore, Emacs considers a file name as having two main parts: the directory name part, and the nondirectory part (or file name within the directory). Either part may be empty. Concatenating these two parts reproduces the original file name.

On most systems, the directory part is everything up to and including the last slash (backslash is also allowed in input on MS-DOS or MS-Windows); the nondirectory part is the rest.

For some purposes, the nondirectory part is further subdivided into the name proper and the version number. On most systems, only backup files have version numbers in their names.

— Function: file-name-directory filename
This function returns the directory part of filename, as a directory name (see Directory Names), or nil if filename does not include a directory part.

On GNU and other POSIX-like systems, a string returned by this function always ends in a slash. On MS-DOS it can also end in a colon.

          (file-name-directory "lewis/foo")  ; GNU example
               ⇒ "lewis/"
          (file-name-directory "foo")        ; GNU example
               ⇒ nil
— Function: file-name-nondirectory filename
This function returns the nondirectory part of filename.

          (file-name-nondirectory "lewis/foo")
               ⇒ "foo"
          (file-name-nondirectory "foo")
               ⇒ "foo"
          (file-name-nondirectory "lewis/")
               ⇒ ""
— Function: file-name-sans-versions filename &optional keep-backup-version
This function returns filename with any file version numbers, backup version numbers, or trailing tildes discarded.

If keep-backup-version is non-nil, then true file version numbers understood as such by the file system are discarded from the return value, but backup version numbers are kept.

          (file-name-sans-versions "~rms/foo.~1~")
               ⇒ "~rms/foo"
          (file-name-sans-versions "~rms/foo~")
               ⇒ "~rms/foo"
          (file-name-sans-versions "~rms/foo")
               ⇒ "~rms/foo"
— Function: file-name-extension filename &optional period
This function returns filename's final extension, if any, after applying file-name-sans-versions to remove any version/backup part. The extension, in a file name, is the part that follows the last ‘.’ in the last name component (minus any version/backup part).

This function returns nil for extensionless file names such as foo. It returns "" for null extensions, as in foo.. If the last component of a file name begins with a ‘.’, that ‘.’ doesn't count as the beginning of an extension. Thus, .emacs's extension is nil, not ‘.emacs’.

If period is non-nil, then the returned value includes the period that delimits the extension, and if filename has no extension, the value is "".

— Function: file-name-sans-extension filename
This function returns filename minus its extension, if any. The version/backup part, if present, is only removed if the file has an extension. For example,

          (file-name-sans-extension "foo.lose.c")
               ⇒ "foo.lose"
          (file-name-sans-extension "big.hack/foo")
               ⇒ "big.hack/foo"
          (file-name-sans-extension "/my/home/.emacs")
               ⇒ "/my/home/.emacs"
          (file-name-sans-extension "/my/home/.emacs.el")
               ⇒ "/my/home/.emacs"
          (file-name-sans-extension "~/foo.el.~3~")
               ⇒ "~/foo"
          (file-name-sans-extension "~/foo.~3~")
               ⇒ "~/foo.~3~"
Note that the ‘.~3~’ in the two last examples is the backup part, not an extension.

— Function: file-name-base &optional filename
This function is the composition of file-name-sans-extension and file-name-nondirectory. For example,

          (file-name-base "/my/home/foo.c")
              ⇒ "foo"
The filename argument defaults to buffer-file-name.



*** 2. Relative File Names: Some file names are relative to a current directory.
All the directories in the file system form a tree starting at the root directory. A file name can specify all the directory names starting from the root of the tree; then it is called an absolute file name. Or it can specify the position of the file in the tree relative to a default directory; then it is called a relative file name. On GNU and other POSIX-like systems, after any leading ‘~’ has been expanded, an absolute file name starts with a ‘/’ (see abbreviate-file-name), and a relative one does not. On MS-DOS and MS-Windows, an absolute file name starts with a slash or a backslash, or with a drive specification ‘x:/’, where x is the drive letter.

— Function: file-name-absolute-p filename
This function returns t if file filename is an absolute file name or begins with ‘~’, nil otherwise.

          (file-name-absolute-p "~rms/foo")
               ⇒ t
          (file-name-absolute-p "rms/foo")
               ⇒ nil
          (file-name-absolute-p "/user/rms/foo")
               ⇒ t
Given a possibly relative file name, you can expand any leading ‘~’ and convert the result to an absolute name using expand-file-name (see File Name Expansion). This function converts absolute file names to relative names:

— Function: file-relative-name filename &optional directory
This function tries to return a relative name that is equivalent to filename, assuming the result will be interpreted relative to directory (an absolute directory name or directory file name). If directory is omitted or nil, it defaults to the current buffer's default directory.

On some operating systems, an absolute file name begins with a device name. On such systems, filename has no relative equivalent based on directory if they start with two different device names. In this case, file-relative-name returns filename in absolute form.

          (file-relative-name "/foo/bar" "/foo/")
               ⇒ "bar"
          (file-relative-name "/foo/bar" "/hack/")
               ⇒ "../foo/bar"

*** 3. Directory Names: A directory's name as a directory is different from its name as a file.
A directory name is a string that must name a directory if it names any file at all. A directory is actually a kind of file, and it has a file name (called the directory file name, which is related to the directory name but is typically not identical. (This is not quite the same as the usual POSIX terminology.) These two names for the same entity are related by a syntactic transformation. On GNU and other POSIX-like systems, this is simple: to obtain a directory name, append a ‘/’ to a directory file name that does not already end in ‘/’. On MS-DOS the relationship is more complicated.

The difference between a directory name and a directory file name is subtle but crucial. When an Emacs variable or function argument is described as being a directory name, a directory file name is not acceptable. When file-name-directory returns a string, that is always a directory name.

The following two functions convert between directory names and directory file names. They do nothing special with environment variable substitutions such as ‘$HOME’, and the constructs ‘~’, ‘.’ and ‘..’.

— Function: file-name-as-directory filename
This function returns a string representing filename in a form that the operating system will interpret as the name of a directory (a directory name). On most systems, this means appending a slash to the string (if it does not already end in one).

          (file-name-as-directory "~rms/lewis")
               ⇒ "~rms/lewis/"
— Function: directory-name-p filename
This function returns non-nil if filename ends with a directory separator character. This is the forward slash ‘/’ on GNU and other POSIX-like systems; MS-Windows and MS-DOS recognize both the forward slash and the backslash ‘\’ as directory separators.

— Function: directory-file-name dirname
This function returns a string representing dirname in a form that the operating system will interpret as the name of a file (a directory file name). On most systems, this means removing the final directory separators from the string, unless the string consists entirely of directory separators.

          (directory-file-name "~lewis/")
               ⇒ "~lewis"
Given a directory name, you can combine it with a relative file name using concat:

     (concat dirname relfile)
Be sure to verify that the file name is relative before doing that. If you use an absolute file name, the results could be syntactically invalid or refer to the wrong file.

If you want to use a directory file name in making such a combination, you must first convert it to a directory name using file-name-as-directory:

     (concat (file-name-as-directory dirfile) relfile)
Don't try concatenating a slash by hand, as in

     ;;; Wrong!
     (concat dirfile "/" relfile)
because this is not portable. Always use file-name-as-directory.

To avoid the issues mentioned above, or if the dirname value might be nil (for example, from an element of load-path), use:

     (expand-file-name relfile dirname)
However, expand-file-name expands leading ‘~’ in relfile, which may not be what you want. See File Name Expansion.

To convert a directory name to its abbreviation, use this function:


— Function: abbreviate-file-name filename
This function returns an abbreviated form of filename. It applies the abbreviations specified in directory-abbrev-alist (see File Aliases), then substitutes ‘~’ for the user's home directory if the argument names a file in the home directory or one of its subdirectories. If the home directory is a root directory, it is not replaced with ‘~’, because this does not make the result shorter on many systems.

You can use this function for directory names and for file names, because it recognizes abbreviations even as part of the name.
*** 4. File Name Expansion: Converting relative file names to absolute ones.
Expanding a file name means converting a relative file name to an absolute one. Since this is done relative to a default directory, you must specify the default directory as well as the file name to be expanded. It also involves expanding abbreviations like ~/ (see abbreviate-file-name), and eliminating redundancies like ./ and name/../.

— Function: expand-file-name filename &optional directory
This function converts filename to an absolute file name. If directory is supplied, it is the default directory to start with if filename is relative and does not start with ‘~’. (The value of directory should itself be an absolute directory name or directory file name; it may start with ‘~’.) Otherwise, the current buffer's value of default-directory is used. For example:

          (expand-file-name "foo")
               ⇒ "/xcssun/users/rms/lewis/foo"
          (expand-file-name "../foo")
               ⇒ "/xcssun/users/rms/foo"
          (expand-file-name "foo" "/usr/spool/")
               ⇒ "/usr/spool/foo"
If the part of filename before the first slash is ‘~’, it expands to the value of the HOME environment variable (usually your home directory). If the part before the first slash is ‘~user’ and if user is a valid login name, it expands to user's home directory. If you do not want this expansion for a relative filename that might begin with a literal ‘~’, you can use (concat (file-name-as-directory directory) filename) instead of (expand-file-name filename directory).

Filenames containing ‘.’ or ‘..’ are simplified to their canonical form:

          (expand-file-name "bar/../foo")
               ⇒ "/xcssun/users/rms/lewis/foo"
In some cases, a leading ‘..’ component can remain in the output:

          (expand-file-name "../home" "/")
               ⇒ "/../home"
This is for the sake of filesystems that have the concept of a superroot above the root directory /. On other filesystems, /../ is interpreted exactly the same as /.

Expanding . or the empty string returns the default directory:

          (expand-file-name "." "/usr/spool/")
               ⇒ "/usr/spool"
          (expand-file-name "" "/usr/spool/")
               ⇒ "/usr/spool"
Note that expand-file-name does not expand environment variables; only substitute-in-file-name does that:

          (expand-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/lewis/$HOME/foo"
Note also that expand-file-name does not follow symbolic links at any level. This results in a difference between the way file-truename and expand-file-name treat ‘..’. Assuming that ‘/tmp/bar’ is a symbolic link to the directory ‘/tmp/foo/bar’ we get:

          (file-truename "/tmp/bar/../myfile")
               ⇒ "/tmp/foo/myfile"
          (expand-file-name "/tmp/bar/../myfile")
               ⇒ "/tmp/myfile"
If you may need to follow symbolic links preceding ‘..’, you should make sure to call file-truename without prior direct or indirect calls to expand-file-name. See Truenames.

— Variable: default-directory
The value of this buffer-local variable is the default directory for the current buffer. It should be an absolute directory name; it may start with ‘~’. This variable is buffer-local in every buffer.

expand-file-name uses the default directory when its second argument is nil.

The value is always a string ending with a slash.

          default-directory
               ⇒ "/user/lewis/manual/"
— Function: substitute-in-file-name filename
This function replaces environment variable references in filename with the environment variable values. Following standard Unix shell syntax, ‘$’ is the prefix to substitute an environment variable value. If the input contains ‘$$’, that is converted to ‘$’; this gives the user a way to quote a ‘$’.

The environment variable name is the series of alphanumeric characters (including underscores) that follow the ‘$’. If the character following the ‘$’ is a ‘{’, then the variable name is everything up to the matching ‘}’.

Calling substitute-in-file-name on output produced by substitute-in-file-name tends to give incorrect results. For instance, use of ‘$$’ to quote a single ‘$’ won't work properly, and ‘$’ in an environment variable's value could lead to repeated substitution. Therefore, programs that call this function and put the output where it will be passed to this function need to double all ‘$’ characters to prevent subsequent incorrect results.
Here we assume that the environment variable HOME, which holds the user's home directory, has value ‘/xcssun/users/rms’.

          (substitute-in-file-name "$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"
After substitution, if a ‘~’ or a ‘/’ appears immediately after another ‘/’, the function discards everything before it (up through the immediately preceding ‘/’).

          (substitute-in-file-name "bar/~/foo")
               ⇒ "~/foo"
          (substitute-in-file-name "/usr/local/$HOME/foo")
               ⇒ "/xcssun/users/rms/foo"
               ;; /usr/local/ has been discarded.
Sometimes, it is not desired to expand file names. In such cases, the file name can be quoted to suppress the expansion, and to handle the file name literally. Quoting happens by prefixing the file name with ‘/:’.

— Macro: file-name-quote name
This macro adds the quotation prefix ‘/:’ to the file name. For a local file name, it prefixes name with ‘/:’. If name is a remote file name, the local part of name (see Magic File Names) is quoted. If name is already a quoted file name, name is returned unchanged.

          (substitute-in-file-name (file-name-quote "bar/~/foo"))
               ⇒ "/:bar/~/foo"

          (substitute-in-file-name (file-name-quote "/ssh:host:bar/~/foo"))
               ⇒ "/ssh:host:/:bar/~/foo"
The macro cannot be used to suppress file name handlers from magic file names (see Magic File Names).

— Macro: file-name-unquote name
This macro removes the quotation prefix ‘/:’ from the file name, if any. If name is a remote file name, the local part of name is unquoted.

— Macro: file-name-quoted-p name
This macro returns non-nil, when name is quoted with the prefix ‘/:’. If name is a remote file name, the local part of name is checked.




*** 5. Unique File Names: Generating names for temporary files.
Some programs need to write temporary files. Here is the usual way to construct a name for such a file:

     (make-temp-file name-of-application)
The job of make-temp-file is to prevent two different users or two different jobs from trying to use the exact same file name.

— Function: make-temp-file prefix &optional dir-flag suffix text
This function creates a temporary file and returns its name. Emacs creates the temporary file's name by adding to prefix some random characters that are different in each Emacs job. The result is guaranteed to be a newly created file, containing text if that's given as a string and empty otherwise. On MS-DOS, this function can truncate prefix to fit into the 8+3 file-name limits. If prefix is a relative file name, it is expanded against temporary-file-directory.

          (make-temp-file "foo")
               ⇒ "/tmp/foo232J6v"
When make-temp-file returns, the file has been created and is empty. At that point, you should write the intended contents into the file.

If dir-flag is non-nil, make-temp-file creates an empty directory instead of an empty file. It returns the file name, not the directory name, of that directory. See Directory Names.

If suffix is non-nil, make-temp-file adds it at the end of the file name.

If text is a string, make-temp-file inserts it in the file.

To prevent conflicts among different libraries running in the same Emacs, each Lisp program that uses make-temp-file should have its own prefix. The number added to the end of prefix distinguishes between the same application running in different Emacs jobs. Additional added characters permit a large number of distinct names even in one Emacs job.

The default directory for temporary files is controlled by the variable temporary-file-directory. This variable gives the user a uniform way to specify the directory for all temporary files. Some programs use small-temporary-file-directory instead, if that is non-nil. To use it, you should expand the prefix against the proper directory before calling make-temp-file.

— User Option: temporary-file-directory
This variable specifies the directory name for creating temporary files. Its value should be a directory name (see Directory Names), but it is good for Lisp programs to cope if the value is a directory's file name instead. Using the value as the second argument to expand-file-name is a good way to achieve that.

The default value is determined in a reasonable way for your operating system; it is based on the TMPDIR, TMP and TEMP environment variables, with a fall-back to a system-dependent name if none of these variables is defined.

Even if you do not use make-temp-file to create the temporary file, you should still use this variable to decide which directory to put the file in. However, if you expect the file to be small, you should use small-temporary-file-directory first if that is non-nil.

— User Option: small-temporary-file-directory
This variable specifies the directory name for creating certain temporary files, which are likely to be small.

If you want to write a temporary file which is likely to be small, you should compute the directory like this:

          (make-temp-file
            (expand-file-name prefix
                              (or small-temporary-file-directory
                                  temporary-file-directory)))
— Function: make-temp-name base-name
This function generates a string that might be a unique file name. The name starts with base-name, and has several random characters appended to it, which are different in each Emacs job. It is like make-temp-file except that (i) it just constructs a name and does not create a file, (ii) base-name should be an absolute file name that is not magic, and (iii) if the returned file name is magic, it might name an existing file. See Magic File Names.

Warning: In most cases, you should not use this function; use make-temp-file instead! This function is susceptible to a race condition, between the make-temp-name call and the creation of the file, which in some cases may cause a security hole.

Sometimes, it is necessary to create a temporary file on a remote host or a mounted directory. The following two functions support this.

— Function: make-nearby-temp-file prefix &optional dir-flag suffix
This function is similar to make-temp-file, but it creates a temporary file as close as possible to default-directory. If prefix is a relative file name, and default-directory is a remote file name or located on a mounted file systems, the temporary file is created in the directory returned by the function temporary-file-directory. Otherwise, the function make-temp-file is used. prefix, dir-flag and suffix have the same meaning as in make-temp-file.

          (let ((default-directory "/ssh:remotehost:"))
            (make-nearby-temp-file "foo"))
               ⇒ "/ssh:remotehost:/tmp/foo232J6v"
— Function: temporary-file-directory
The directory for writing temporary files via make-nearby-temp-file. In case of a remote default-directory, this is a directory for temporary files on that remote host. If such a directory does not exist, or default-directory ought to be located on a mounted file system (see mounted-file-systems), the function returns default-directory. For a non-remote and non-mounted default-directory, the value of the variable temporary-file-directory is returned.

In order to extract the local part of the file's name of a temporary file, use file-local-name (see Magic File Names).



*** 6. File Name Completion: Finding the completions for a given file name.
This section describes low-level subroutines for completing a file name. For higher level functions, see Reading File Names.

— Function: file-name-all-completions partial-filename directory
This function returns a list of all possible completions for a file whose name starts with partial-filename in directory directory. The order of the completions is the order of the files in the directory, which is unpredictable and conveys no useful information.

The argument partial-filename must be a file name containing no directory part and no slash (or backslash on some systems). The current buffer's default directory is prepended to directory, if directory is not absolute.

In the following example, suppose that ~rms/lewis is the current default directory, and has five files whose names begin with ‘f’: foo, file~, file.c, file.c.~1~, and file.c.~2~.

          (file-name-all-completions "f" "")
               ⇒ ("foo" "file~" "file.c.~2~"
                          "file.c.~1~" "file.c")

          (file-name-all-completions "fo" "")
               ⇒ ("foo")
— Function: file-name-completion filename directory &optional predicate
This function completes the file name filename in directory directory. It returns the longest prefix common to all file names in directory directory that start with filename. If predicate is non-nil then it ignores possible completions that don't satisfy predicate, after calling that function with one argument, the expanded absolute file name.

If only one match exists and filename matches it exactly, the function returns t. The function returns nil if directory directory contains no name starting with filename.

In the following example, suppose that the current default directory has five files whose names begin with ‘f’: foo, file~, file.c, file.c.~1~, and file.c.~2~.

          (file-name-completion "fi" "")
               ⇒ "file"

          (file-name-completion "file.c.~1" "")
               ⇒ "file.c.~1~"

          (file-name-completion "file.c.~1~" "")
               ⇒ t

          (file-name-completion "file.c.~3" "")
               ⇒ nil
— User Option: completion-ignored-extensions
file-name-completion usually ignores file names that end in any string in this list. It does not ignore them when all the possible completions end in one of these suffixes. This variable has no effect on file-name-all-completions.

A typical value might look like this:

          completion-ignored-extensions
               ⇒ (".o" ".elc" "~" ".dvi")
If an element of completion-ignored-extensions ends in a slash ‘/’, it signals a directory. The elements which do not end in a slash will never match a directory; thus, the above value will not filter out a directory named foo.elc.




*** 7. Standard File Names: If your package uses a fixed file name, how to handle various operating systems simply.
configuration data specified by the current user. Usually, such files should be located in the directory specified by user-emacs-directory, which is ~/.emacs.d by default (see Init File). For example, abbrev definitions are stored by default in ~/.emacs.d/abbrev_defs. The easiest way to specify such a file name is to use the function locate-user-emacs-file.

— Function: locate-user-emacs-file base-name &optional old-name
This function returns an absolute file name for an Emacs-specific configuration or data file. The argument base-name should be a relative file name. The return value is the absolute name of a file in the directory specified by user-emacs-directory; if that directory does not exist, this function creates it.

If the optional argument old-name is non-nil, it specifies a file in the user's home directory, ~/old-name. If such a file exists, the return value is the absolute name of that file, instead of the file specified by base-name. This argument is intended to be used by Emacs packages to provide backward compatibility. For instance, prior to the introduction of user-emacs-directory, the abbrev file was located in ~/.abbrev_defs. Here is the definition of abbrev-file-name:

          (defcustom abbrev-file-name
            (locate-user-emacs-file "abbrev_defs" ".abbrev_defs")
            "Default name of file from which to read abbrevs."
            ...
            :type 'file)
A lower-level function for standardizing file names, which locate-user-emacs-file uses as a subroutine, is convert-standard-filename.

— Function: convert-standard-filename filename
This function returns a file name based on filename, which fits the conventions of the current operating system.

On GNU and other POSIX-like systems, this simply returns filename. On other operating systems, it may enforce system-specific file name conventions; for example, on MS-DOS this function performs a variety of changes to enforce MS-DOS file name limitations, including converting any leading ‘.’ to ‘_’ and truncating to three characters after the ‘.’.

The recommended way to use this function is to specify a name which fits the conventions of GNU and Unix systems, and pass it to convert-standard-filename.


** 10. Contents of Directories: Getting a list of the files in a directory.
A directory is a kind of file that contains other files entered under various names. Directories are a feature of the file system.

Emacs can list the names of the files in a directory as a Lisp list, or display the names in a buffer using the ls shell command. In the latter case, it can optionally display information about each file, depending on the options passed to the ls command.

— Function: directory-files directory &optional full-name match-regexp nosort
This function returns a list of the names of the files in the directory directory. By default, the list is in alphabetical order.

If full-name is non-nil, the function returns the files' absolute file names. Otherwise, it returns the names relative to the specified directory.

If match-regexp is non-nil, this function returns only those file names that contain a match for that regular expression—the other file names are excluded from the list. On case-insensitive filesystems, the regular expression matching is case-insensitive.
If nosort is non-nil, directory-files does not sort the list, so you get the file names in no particular order. Use this if you want the utmost possible speed and don't care what order the files are processed in. If the order of processing is visible to the user, then the user will probably be happier if you do sort the names.

          (directory-files "~lewis")
               ⇒ ("#foo#" "#foo.el#" "." ".."
                   "dired-mods.el" "files.texi"
                   "files.texi.~1~")
An error is signaled if directory is not the name of a directory that can be read.

— Function: directory-files-recursively directory regexp &optional include-directories
Return all files under directory whose names match regexp. This function searches the specified directory and its sub-directories, recursively, for files whose basenames (i.e., without the leading directories) match the specified regexp, and returns a list of the absolute file names of the matching files (see absolute file names). The file names are returned in depth-first order, meaning that files in some sub-directory are returned before the files in its parent directory. In addition, matching files found in each subdirectory are sorted alphabetically by their basenames. By default, directories whose names match regexp are omitted from the list, but if the optional argument include-directories is non-nil, they are included.

— Function: directory-files-and-attributes directory &optional full-name match-regexp nosort id-format
This is similar to directory-files in deciding which files to report on and how to report their names. However, instead of returning a list of file names, it returns for each file a list (filename attributes), where attributes is what file-attributes returns for that file. The optional argument id-format has the same meaning as the corresponding argument to file-attributes (see Definition of file-attributes).

— Function: file-expand-wildcards pattern &optional full
This function expands the wildcard pattern pattern, returning a list of file names that match it.

If pattern is written as an absolute file name, the values are absolute also.

If pattern is written as a relative file name, it is interpreted relative to the current default directory. The file names returned are normally also relative to the current default directory. However, if full is non-nil, they are absolute.

— Function: insert-directory file switches &optional wildcard full-directory-p
This function inserts (in the current buffer) a directory listing for directory file, formatted with ls according to switches. It leaves point after the inserted text. switches may be a string of options, or a list of strings representing individual options.

The argument file may be either a directory or a file specification including wildcard characters. If wildcard is non-nil, that means treat file as a file specification with wildcards.

If full-directory-p is non-nil, that means the directory listing is expected to show the full contents of a directory. You should specify t when file is a directory and switches do not contain ‘-d’. (The ‘-d’ option to ls says to describe a directory itself as a file, rather than showing its contents.)

On most systems, this function works by running a directory listing program whose name is in the variable insert-directory-program. If wildcard is non-nil, it also runs the shell specified by shell-file-name, to expand the wildcards.

MS-DOS and MS-Windows systems usually lack the standard Unix program ls, so this function emulates the standard Unix program ls with Lisp code.

As a technical detail, when switches contains the long ‘--dired’ option, insert-directory treats it specially, for the sake of dired. However, the normally equivalent short ‘-D’ option is just passed on to insert-directory-program, as any other option.

— Variable: insert-directory-program
This variable's value is the program to run to generate a directory listing for the function insert-directory. It is ignored on systems which generate the listing with Lisp code.


** 11. Create/Delete Dirs: Creating and Deleting Directories.
Most Emacs Lisp file-manipulation functions get errors when used on files that are directories. For example, you cannot delete a directory with delete-file. These special functions exist to create and delete directories.


— Command: make-directory dirname &optional parents
This command creates a directory named dirname. If parents is non-nil, as is always the case in an interactive call, that means to create the parent directories first, if they don't already exist.

mkdir is an alias for this.

— Command: copy-directory dirname newname &optional keep-time parents copy-contents
This command copies the directory named dirname to newname. If newname is a directory name, dirname will be copied to a subdirectory there. See Directory Names.

It always sets the file modes of the copied files to match the corresponding original file.

The third argument keep-time non-nil means to preserve the modification time of the copied files. A prefix arg makes keep-time non-nil.

The fourth argument parents says whether to create parent directories if they don't exist. Interactively, this happens by default.

The fifth argument copy-contents, if non-nil, means to copy the contents of dirname directly into newname if the latter is a directory name, instead of copying dirname into it as a subdirectory.


— Command: delete-directory dirname &optional recursive trash
This command deletes the directory named dirname. The function delete-file does not work for files that are directories; you must use delete-directory for them. If recursive is nil, and the directory contains any files, delete-directory signals an error. If recursive is non-nil, there is no error merely because the directory or its files are deleted by some other process before delete-directory gets to them.

delete-directory only follows symbolic links at the level of parent directories.

If the optional argument trash is non-nil and the variable delete-by-moving-to-trash is non-nil, this command moves the file into the system Trash instead of deleting it. See Miscellaneous File Operations. When called interactively, trash is t if no prefix argument is given, and nil otherwise.

** 12. Magic File Names: Special handling for certain file names.

You can implement special handling for certain file names. This is called making those names magic. The principal use for this feature is in implementing access to remote files (see Remote Files).

To define a kind of magic file name, you must supply a regular expression to define the class of names (all those that match the regular expression), plus a handler that implements all the primitive Emacs file operations for file names that match.

The variable file-name-handler-alist holds a list of handlers, together with regular expressions that determine when to apply each handler. Each element has this form:

     (regexp . handler)
All the Emacs primitives for file access and file name transformation check the given file name against file-name-handler-alist. If the file name matches regexp, the primitives handle that file by calling handler.

The first argument given to handler is the name of the primitive, as a symbol; the remaining arguments are the arguments that were passed to that primitive. (The first of these arguments is most often the file name itself.) For example, if you do this:

     (file-exists-p filename)
and filename has handler handler, then handler is called like this:

     (funcall handler 'file-exists-p filename)
When a function takes two or more arguments that must be file names, it checks each of those names for a handler. For example, if you do this:

     (expand-file-name filename dirname)
then it checks for a handler for filename and then for a handler for dirname. In either case, the handler is called like this:

     (funcall handler 'expand-file-name filename dirname)
The handler then needs to figure out whether to handle filename or dirname.

If the specified file name matches more than one handler, the one whose match starts last in the file name gets precedence. This rule is chosen so that handlers for jobs such as uncompression are handled first, before handlers for jobs such as remote file access.

Here are the operations that a magic file name handler gets to handle:

access-file, add-name-to-file, byte-compiler-base-file-name,
copy-directory, copy-file, delete-directory, delete-file, diff-latest-backup-file, directory-file-name, directory-files, directory-files-and-attributes, dired-compress-file, dired-uncache,
expand-file-name, file-accessible-directory-p, file-acl, file-attributes, file-directory-p, file-equal-p, file-executable-p, file-exists-p, file-in-directory-p, file-local-copy, file-modes, file-name-all-completions, file-name-as-directory, file-name-case-insensitive-p, file-name-completion, file-name-directory, file-name-nondirectory, file-name-sans-versions, file-newer-than-file-p, file-notify-add-watch, file-notify-rm-watch, file-notify-valid-p, file-ownership-preserved-p, file-readable-p, file-regular-p, file-remote-p, file-selinux-context, file-symlink-p, file-truename, file-writable-p, find-backup-file-name,
get-file-buffer, insert-directory, insert-file-contents,
load, make-auto-save-file-name, make-directory, make-directory-internal, make-nearby-temp-file, make-symbolic-link,
process-file, rename-file, set-file-acl, set-file-modes, set-file-selinux-context, set-file-times, set-visited-file-modtime, shell-command, start-file-process, substitute-in-file-name,
temporary-file-directory, unhandled-file-name-directory, vc-registered, verify-visited-file-modtime,
write-region.

Handlers for insert-file-contents typically need to clear the buffer's modified flag, with (set-buffer-modified-p nil), if the visit argument is non-nil. This also has the effect of unlocking the buffer if it is locked.

The handler function must handle all of the above operations, and possibly others to be added in the future. It need not implement all these operations itself—when it has nothing special to do for a certain operation, it can reinvoke the primitive, to handle the operation in the usual way. It should always reinvoke the primitive for an operation it does not recognize. Here's one way to do this:

     (defun my-file-handler (operation &rest args)
       ;; First check for the specific operations
       ;; that we have special handling for.
       (cond ((eq operation 'insert-file-contents) ...)
             ((eq operation 'write-region) ...)
             ...
             ;; Handle any operation we don't know about.
             (t (let ((inhibit-file-name-handlers
                       (cons 'my-file-handler
                             (and (eq inhibit-file-name-operation operation)
                                  inhibit-file-name-handlers)))
                      (inhibit-file-name-operation operation))
                  (apply operation args)))))
When a handler function decides to call the ordinary Emacs primitive for the operation at hand, it needs to prevent the primitive from calling the same handler once again, thus leading to an infinite recursion. The example above shows how to do this, with the variables inhibit-file-name-handlers and inhibit-file-name-operation. Be careful to use them exactly as shown above; the details are crucial for proper behavior in the case of multiple handlers, and for operations that have two file names that may each have handlers.

Handlers that don't really do anything special for actual access to the file—such as the ones that implement completion of host names for remote file names—should have a non-nil safe-magic property. For instance, Emacs normally protects directory names it finds in PATH from becoming magic, if they look like magic file names, by prefixing them with ‘/:’. But if the handler that would be used for them has a non-nil safe-magic property, the ‘/:’ is not added.

A file name handler can have an operations property to declare which operations it handles in a nontrivial way. If this property has a non-nil value, it should be a list of operations; then only those operations will call the handler. This avoids inefficiency, but its main purpose is for autoloaded handler functions, so that they won't be loaded except when they have real work to do.

Simply deferring all operations to the usual primitives does not work. For instance, if the file name handler applies to file-exists-p, then it must handle load itself, because the usual load code won't work properly in that case. However, if the handler uses the operations property to say it doesn't handle file-exists-p, then it need not handle load nontrivially.

— Variable: inhibit-file-name-handlers
This variable holds a list of handlers whose use is presently inhibited for a certain operation.

— Variable: inhibit-file-name-operation
The operation for which certain handlers are presently inhibited.

— Function: find-file-name-handler file operation
This function returns the handler function for file name file, or nil if there is none. The argument operation should be the operation to be performed on the file—the value you will pass to the handler as its first argument when you call it. If operation equals inhibit-file-name-operation, or if it is not found in the operations property of the handler, this function returns nil.

— Function: file-local-copy filename
This function copies file filename to an ordinary non-magic file on the local machine, if it isn't on the local machine already. Magic file names should handle the file-local-copy operation if they refer to files on other machines. A magic file name that is used for other purposes than remote file access should not handle file-local-copy; then this function will treat the file as local.

If filename is local, whether magic or not, this function does nothing and returns nil. Otherwise it returns the file name of the local copy file.

— Function: file-remote-p filename &optional identification connected
This function tests whether filename is a remote file. If filename is local (not remote), the return value is nil. If filename is indeed remote, the return value is a string that identifies the remote system.

This identifier string can include a host name and a user name, as well as characters designating the method used to access the remote system. For example, the remote identifier string for the filename /sudo::/some/file is /sudo:root@localhost:.

If file-remote-p returns the same identifier for two different filenames, that means they are stored on the same file system and can be accessed locally with respect to each other. This means, for example, that it is possible to start a remote process accessing both files at the same time. Implementers of file handlers need to ensure this principle is valid.

identification specifies which part of the identifier shall be returned as string. identification can be the symbol method, user or host; any other value is handled like nil and means to return the complete identifier string. In the example above, the remote user identifier string would be root.

If connected is non-nil, this function returns nil even if filename is remote, if Emacs has no network connection to its host. This is useful when you want to avoid the delay of making connections when they don't exist.

— Function: unhandled-file-name-directory filename
This function returns the name of a directory that is not magic. For a non-magic filename it returns the corresponding directory name (see Directory Names). For a magic filename, it invokes the file name handler, which therefore decides what value to return. If filename is not accessible from a local process, then the file name handler should indicate that by returning nil.

This is useful for running a subprocess; every subprocess must have a non-magic directory to serve as its current directory, and this function is a good way to come up with one.


— Function: file-local-name filename
This function returns the local part of filename. This is the part of the file's name that identifies it on the remote host, and is typically obtained by removing from the remote file name the parts that specify the remote host and the method of accessing it. For example:

          (file-local-name "/ssh:user@host:/foo/bar")
               ⇒ "/foo/bar"
For a remote filename, this function returns a file name which could be used directly as an argument of a remote process (see Asynchronous Processes, and see Synchronous Processes), and as the program to run on the remote host. If filename is local, this function returns it unchanged.

— User Option: remote-file-name-inhibit-cache
The attributes of remote files can be cached for better performance. If they are changed outside of Emacs's control, the cached values become invalid, and must be reread.

When this variable is set to nil, cached values are never expired. Use this setting with caution, only if you are sure nothing other than Emacs ever changes the remote files. If it is set to t, cached values are never used. This is the safest value, but could result in performance degradation.

A compromise is to set it to a positive number. This means that cached values are used for that amount of seconds since they were cached. If a remote file is checked regularly, it might be a good idea to let-bind this variable to a value less than the time period between consecutive checks. For example:

          (defun display-time-file-nonempty-p (file)
            (let ((remote-file-name-inhibit-cache
                   (- display-time-interval 5)))
              (and (file-exists-p file)
                   (< 0 (nth 7 (file-attributes
                                 (file-chase-links file)))))))

** 13. Format Conversion: Conversion to and from various file formats.
Emacs performs several steps to convert the data in a buffer (text, text properties, and possibly other information) to and from a representation suitable for storing into a file. This section describes the fundamental functions that perform this format conversion, namely insert-file-contents for reading a file into a buffer, and write-region for writing a buffer into a file.

*** 1. Overview: insert-file-contents and write-region.
The function insert-file-contents:

initially, inserts bytes from the file into the buffer;
decodes bytes to characters as appropriate;
processes formats as defined by entries in format-alist; and
calls functions in after-insert-file-functions.
The function write-region:

initially, calls functions in write-region-annotate-functions;
processes formats as defined by entries in format-alist;
encodes characters to bytes as appropriate; and
modifies the file with the bytes.
This shows the symmetry of the lowest-level operations; reading and writing handle things in opposite order. The rest of this section describes the two facilities surrounding the three variables named above, as well as some related functions. Coding Systems, for details on character encoding and decoding.
*** 2. Round-Trip: Using format-alist.
The most general of the two facilities is controlled by the variable format-alist, a list of file format specifications, which describe textual representations used in files for the data in an Emacs buffer. The descriptions for reading and writing are paired, which is why we call this “round-trip” specification (see Format Conversion Piecemeal, for non-paired specification).

— Variable: format-alist
This list contains one format definition for each defined file format. Each format definition is a list of this form:

          (name doc-string regexp from-fn to-fn modify mode-fn preserve)
Here is what the elements in a fpormat definition mean:

name
The name of this format.
doc-string
A documentation string for the format.
regexp
A regular expression which is used to recognize files represented in this format. If nil, the format is never applied automatically.
from-fn
A shell command or function to decode data in this format (to convert file data into the usual Emacs data representation).
A shell command is represented as a string; Emacs runs the command as a filter to perform the conversion.

If from-fn is a function, it is called with two arguments, begin and end, which specify the part of the buffer it should convert. It should convert the text by editing it in place. Since this can change the length of the text, from-fn should return the modified end position.

One responsibility of from-fn is to make sure that the beginning of the file no longer matches regexp. Otherwise it is likely to get called again. Also, from-fn must not involve buffers or files other than the one being decoded, otherwise the internal buffer used for formatting might be overwritten.

to-fn
A shell command or function to encode data in this format—that is, to convert the usual Emacs data representation into this format.
If to-fn is a string, it is a shell command; Emacs runs the command as a filter to perform the conversion.

If to-fn is a function, it is called with three arguments: begin and end, which specify the part of the buffer it should convert, and buffer, which specifies which buffer. There are two ways it can do the conversion:

By editing the buffer in place. In this case, to-fn should return the end-position of the range of text, as modified.
By returning a list of annotations. This is a list of elements of the form (position . string), where position is an integer specifying the relative position in the text to be written, and string is the annotation to add there. The list must be sorted in order of position when to-fn returns it.
When write-region actually writes the text from the buffer to the file, it intermixes the specified annotations at the corresponding positions. All this takes place without modifying the buffer.

to-fn must not involve buffers or files other than the one being encoded, otherwise the internal buffer used for formatting might be overwritten.

modify
A flag, t if the encoding function modifies the buffer, and nil if it works by returning a list of annotations.
mode-fn
A minor-mode function to call after visiting a file converted from this format. The function is called with one argument, the integer 1; that tells a minor-mode function to enable the mode.
preserve
A flag, t if format-write-file should not remove this format from buffer-file-format.
The function insert-file-contents automatically recognizes file formats when it reads the specified file. It checks the text of the beginning of the file against the regular expressions of the format definitions, and if it finds a match, it calls the decoding function for that format. Then it checks all the known formats over again. It keeps checking them until none of them is applicable.

Visiting a file, with find-file-noselect or the commands that use it, performs conversion likewise (because it calls insert-file-contents); it also calls the mode function for each format that it decodes. It stores a list of the format names in the buffer-local variable buffer-file-format.

— Variable: buffer-file-format
This variable states the format of the visited file. More precisely, this is a list of the file format names that were decoded in the course of visiting the current buffer's file. It is always buffer-local in all buffers.

When write-region writes data into a file, it first calls the encoding functions for the formats listed in buffer-file-format, in the order of appearance in the list.

— Command: format-write-file file format &optional confirm
This command writes the current buffer contents into the file file in a format based on format, which is a list of format names. It constructs the actual format starting from format, then appending any elements from the value of buffer-file-format with a non-nil preserve flag (see above), if they are not already present in format. It then updates buffer-file-format with this format, making it the default for future saves. Except for the format argument, this command is similar to write-file. In particular, confirm has the same meaning and interactive treatment as the corresponding argument to write-file. See Definition of write-file.

— Command: format-find-file file format
This command finds the file file, converting it according to format format. It also makes format the default if the buffer is saved later.

The argument format is a list of format names. If format is nil, no conversion takes place. Interactively, typing just <RET> for format specifies nil.

— Command: format-insert-file file format &optional beg end
This command inserts the contents of file file, converting it according to format format. If beg and end are non-nil, they specify which part of the file to read, as in insert-file-contents (see Reading from Files).

The return value is like what insert-file-contents returns: a list of the absolute file name and the length of the data inserted (after conversion).

The argument format is a list of format names. If format is nil, no conversion takes place. Interactively, typing just <RET> for format specifies nil.

— Variable: buffer-auto-save-file-format
This variable specifies the format to use for auto-saving. Its value is a list of format names, just like the value of buffer-file-format; however, it is used instead of buffer-file-format for writing auto-save files. If the value is t, the default, auto-saving uses the same format as a regular save in the same buffer. This variable is always buffer-local in all buffers.





*** 3. Piecemeal: Specifying non-paired conversion.
In contrast to the round-trip specification described in the previous subsection (see Format Conversion Round-Trip), you can use the variables after-insert-file-functions and write-region-annotate-functions to separately control the respective reading and writing conversions.

Conversion starts with one representation and produces another representation. When there is only one conversion to do, there is no conflict about what to start with. However, when there are multiple conversions involved, conflict may arise when two conversions need to start with the same data.

This situation is best understood in the context of converting text properties during write-region. For example, the character at position 42 in a buffer is ‘X’ with a text property foo. If the conversion for foo is done by inserting into the buffer, say, ‘FOO:’, then that changes the character at position 42 from ‘X’ to ‘F’. The next conversion will start with the wrong data straight away.

To avoid conflict, cooperative conversions do not modify the buffer, but instead specify annotations, a list of elements of the form (position . string), sorted in order of increasing position.

If there is more than one conversion, write-region merges their annotations destructively into one sorted list. Later, when the text from the buffer is actually written to the file, it intermixes the specified annotations at the corresponding positions. All this takes place without modifying the buffer.
In contrast, when reading, the annotations intermixed with the text are handled immediately. insert-file-contents sets point to the beginning of some text to be converted, then calls the conversion functions with the length of that text. These functions should always return with point at the beginning of the inserted text. This approach makes sense for reading because annotations removed by the first converter can't be mistakenly processed by a later converter. Each conversion function should scan for the annotations it recognizes, remove the annotation, modify the buffer text (to set a text property, for example), and return the updated length of the text, as it stands after those changes. The value returned by one function becomes the argument to the next function.

— Variable: write-region-annotate-functions
A list of functions for write-region to call. Each function in the list is called with two arguments: the start and end of the region to be written. These functions should not alter the contents of the buffer. Instead, they should return annotations.

As a special case, a function may return with a different buffer current. Emacs takes this to mean that the current buffer contains altered text to be output. It therefore changes the start and end arguments of the write-region call, giving them the values of point-min and point-max in the new buffer, respectively. It also discards all previous annotations, because they should have been dealt with by this function.

— Variable: write-region-post-annotation-function
The value of this variable, if non-nil, should be a function. This function is called, with no arguments, after write-region has completed.

If any function in write-region-annotate-functions returns with a different buffer current, Emacs calls write-region-post-annotation-function more than once. Emacs calls it with the last buffer that was current, and again with the buffer before that, and so on back to the original buffer.

Thus, a function in write-region-annotate-functions can create a buffer, give this variable the local value of kill-buffer in that buffer, set up the buffer with altered text, and make the buffer current. The buffer will be killed after write-region is done.

— Variable: after-insert-file-functions
Each function in this list is called by insert-file-contents with one argument, the number of characters inserted, and with point at the beginning of the inserted text. Each function should leave point unchanged, and return the new character count describing the inserted text as modified by the function.
We invite users to write Lisp programs to store and retrieve text properties in files, using these hooks, and thus to experiment with various data formats and find good ones. Eventually we hope users will produce good, general extensions we can install in Emacs.

We suggest not trying to handle arbitrary Lisp objects as text property names or values—because a program that general is probably difficult to write, and slow. Instead, choose a set of possible data types that are reasonably flexible, and not too hard to encode.
* 26 Backups and Auto-Saving
xlBackup files and auto-save files are two methods by which Emacs tries to protect the user from the consequences of crashes or of the user's own errors. Auto-saving preserves the text from earlier in the current editing session; backup files preserve file contents prior to the current session.

*** 1. -+ Backup Files: How backup files are made; how their names are chosen.
A backup file is a copy of the old contents of a file you are editing. Emacs makes a backup file the first time you save a buffer into its visited file. Thus, normally, the backup file contains the contents of the file as it was before the current editing session. The contents of the backup file normally remain unchanged once it exists.

Backups are usually made by renaming the visited file to a new name. Optionally, you can specify that backup files should be made by copying the visited file. This choice makes a difference for files with multiple names; it also can affect whether the edited file remains owned by the original owner or becomes owned by the user editing it.

By default, Emacs makes a single backup file for each file edited. You can alternatively request numbered backups; then each new backup file gets a new name. You can delete old numbered backups when you don't want them any more, or Emacs can delete them automatically.

For performance, the operating system may not write the backup file's contents to secondary storage immediately, or may alias the backup data with the original until one or the other is later modified. See Files and Storage.

**** 1. Making Backups: How Emacs makes backup files, and when.

— Function: backup-buffer
This function makes a backup of the file visited by the current buffer, if appropriate. It is called by save-buffer before saving the buffer the first time.

If a backup was made by renaming, the return value is a cons cell of the form (modes extra-alist backupname), where modes are the mode bits of the original file, as returned by file-modes (see Testing Accessibility), extra-alist is an alist describing the original file's extended attributes, as returned by file-extended-attributes (see Extended Attributes), and backupname is the name of the backup.

In all other cases (i.e., if a backup was made by copying or if no backup was made), this function returns nil.

— Variable: buffer-backed-up
This buffer-local variable says whether this buffer's file has been backed up on account of this buffer. If it is non-nil, the backup file has been written. Otherwise, the file should be backed up when it is next saved (if backups are enabled). This is a permanent local; kill-all-local-variables does not alter it.

— User Option: make-backup-files
This variable determines whether or not to make backup files. If it is non-nil, then Emacs creates a backup of each file when it is saved for the first time—provided that backup-inhibited is nil (see below).

The following example shows how to change the make-backup-files variable only in the Rmail buffers and not elsewhere. Setting it nil stops Emacs from making backups of these files, which may save disk space. (You would put this code in your init file.)

          (add-hook 'rmail-mode-hook
                    (lambda () (setq-local make-backup-files nil)))
— Variable: backup-enable-predicate
This variable's value is a function to be called on certain occasions to decide whether a file should have backup files. The function receives one argument, an absolute file name to consider. If the function returns nil, backups are disabled for that file. Otherwise, the other variables in this section say whether and how to make backups.

The default value is normal-backup-enable-predicate, which checks for files in temporary-file-directory and small-temporary-file-directory.

— Variable: backup-inhibited
If this variable is non-nil, backups are inhibited. It records the result of testing backup-enable-predicate on the visited file name. It can also coherently be used by other mechanisms that inhibit backups based on which file is visited. For example, VC sets this variable non-nil to prevent making backups for files managed with a version control system.

This is a permanent local, so that changing the major mode does not lose its value. Major modes should not set this variable—they should set make-backup-files instead.

— User Option: backup-directory-alist
This variable's value is an alist of filename patterns and backup directories. Each element looks like

          (regexp . directory)
Backups of files with names matching regexp will be made in directory. directory may be relative or absolute. If it is absolute, so that all matching files are backed up into the same directory, the file names in this directory will be the full name of the file backed up with all directory separators changed to ‘!’ to prevent clashes. This will not work correctly if your filesystem truncates the resulting name.

For the common case of all backups going into one directory, the alist should contain a single element pairing ‘"."’ with the appropriate directory.

If this variable is nil (the default), or it fails to match a filename, the backup is made in the original file's directory.

On MS-DOS filesystems without long names this variable is always ignored.

— User Option: make-backup-file-name-function
This variable's value is a function to use for making backup file names. The function make-backup-file-name calls it. See Naming Backup Files.

This could be buffer-local to do something special for specific files. If you change it, you may need to change backup-file-name-p and file-name-sans-versions too.

**** 2. Rename or Copy: Two alternatives: renaming the old file or copying it.
There are two ways that Emacs can make a backup file:

Emacs can rename the original file so that it becomes a backup file, and then write the buffer being saved into a new file. After this procedure, any other names (i.e., hard links) of the original file now refer to the backup file. The new file is owned by the user doing the editing, and its group is the default for new files written by the user in that directory.
Emacs can copy the original file into a backup file, and then overwrite the original file with new contents. After this procedure, any other names (i.e., hard links) of the original file continue to refer to the current (updated) version of the file. The file's owner and group will be unchanged.
The first method, renaming, is the default.

The variable backup-by-copying, if non-nil, says to use the second method, which is to copy the original file and overwrite it with the new buffer contents. The variable file-precious-flag, if non-nil, also has this effect (as a sideline of its main significance). See Saving Buffers.

— User Option: backup-by-copying
If this variable is non-nil, Emacs always makes backup files by copying. The default is nil.

The following three variables, when non-nil, cause the second method to be used in certain special cases. They have no effect on the treatment of files that don't fall into the special cases.

— User Option: backup-by-copying-when-linked
If this variable is non-nil, Emacs makes backups by copying for files with multiple names (hard links). The default is nil.

This variable is significant only if backup-by-copying is nil, since copying is always used when that variable is non-nil.

— User Option: backup-by-copying-when-mismatch
If this variable is non-nil (the default), Emacs makes backups by copying in cases where renaming would change either the owner or the group of the file.

The value has no effect when renaming would not alter the owner or group of the file; that is, for files which are owned by the user and whose group matches the default for a new file created there by the user.

This variable is significant only if backup-by-copying is nil, since copying is always used when that variable is non-nil.

— User Option: backup-by-copying-when-privileged-mismatch
This variable, if non-nil, specifies the same behavior as backup-by-copying-when-mismatch, but only for certain user-id values: namely, those less than or equal to a certain number. You set this variable to that number.

Thus, if you set backup-by-copying-when-privileged-mismatch to 0, backup by copying is done for the superuser only, when necessary to prevent a change in the owner of the file.

The default is 200.


**** 3. Numbered Backups: Keeping multiple backups for each source file.
If a file's name is foo, the names of its numbered backup versions are foo.~v~, for various integers v, like this: foo.~1~, foo.~2~, foo.~3~, ..., foo.~259~, and so on.

— User Option: version-control
This variable controls whether to make a single non-numbered backup file or multiple numbered backups.

nil
Make numbered backups if the visited file already has numbered backups; otherwise, do not. This is the default.
never
Do not make numbered backups.
anything else
Make numbered backups.
The use of numbered backups ultimately leads to a large number of backup versions, which must then be deleted. Emacs can do this automatically or it can ask the user whether to delete them.

— User Option: kept-new-versions
The value of this variable is the number of newest versions to keep when a new numbered backup is made. The newly made backup is included in the count. The default value is 2.

— User Option: kept-old-versions
The value of this variable is the number of oldest versions to keep when a new numbered backup is made. The default value is 2.

If there are backups numbered 1, 2, 3, 5, and 7, and both of these variables have the value 2, then the backups numbered 1 and 2 are kept as old versions and those numbered 5 and 7 are kept as new versions; backup version 3 is excess. The function find-backup-file-name (see Backup Names) is responsible for determining which backup versions to delete, but does not delete them itself.

— User Option: delete-old-versions
If this variable is t, then saving a file deletes excess backup versions silently. If it is nil, that means to ask for confirmation before deleting excess backups. Otherwise, they are not deleted at all.

— User Option: dired-kept-versions
This variable specifies how many of the newest backup versions to keep in the Dired command . (dired-clean-directory). That's the same thing kept-new-versions specifies when you make a new backup file. The default is 2.


**** 4. Backup Names: How backup file names are computed; customization.
The functions in this section are documented mainly because you can customize the naming conventions for backup files by redefining them. If you change one, you probably need to change the rest.

— Function: backup-file-name-p filename
This function returns a non-nil value if filename is a possible name for a backup file. It just checks the name, not whether a file with the name filename exists.

          (backup-file-name-p "foo")
               ⇒ nil
          (backup-file-name-p "foo~")
               ⇒ 3
The standard definition of this function is as follows:

          (defun backup-file-name-p (file)
            "Return non-nil if FILE is a backup file \
          name (numeric or not)..."
            (string-match "~\\'" file))
Thus, the function returns a non-nil value if the file name ends with a ‘~’. (We use a backslash to split the documentation string's first line into two lines in the text, but produce just one line in the string itself.)

This simple expression is placed in a separate function to make it easy to redefine for customization.

— Function: make-backup-file-name filename
This function returns a string that is the name to use for a non-numbered backup file for file filename. On Unix, this is just filename with a tilde appended.

The standard definition of this function, on most operating systems, is as follows:

          (defun make-backup-file-name (file)
            "Create the non-numeric backup file name for FILE..."
            (concat file "~"))
You can change the backup-file naming convention by redefining this function. The following example redefines make-backup-file-name to prepend a ‘.’ in addition to appending a tilde:

          (defun make-backup-file-name (filename)
            (expand-file-name
              (concat "." (file-name-nondirectory filename) "~")
              (file-name-directory filename)))

          (make-backup-file-name "backups.texi")
               ⇒ ".backups.texi~"
Some parts of Emacs, including some Dired commands, assume that backup file names end with ‘~’. If you do not follow that convention, it will not cause serious problems, but these commands may give less-than-desirable results.

— Function: find-backup-file-name filename
This function computes the file name for a new backup file for filename. It may also propose certain existing backup files for deletion. find-backup-file-name returns a list whose car is the name for the new backup file and whose cdr is a list of backup files whose deletion is proposed. The value can also be nil, which means not to make a backup.

Two variables, kept-old-versions and kept-new-versions, determine which backup versions should be kept. This function keeps those versions by excluding them from the cdr of the value. See Numbered Backups.

In this example, the value says that ~rms/foo.~5~ is the name to use for the new backup file, and ~rms/foo.~3~ is an excess version that the caller should consider deleting now.

          (find-backup-file-name "~rms/foo")
               ⇒ ("~rms/foo.~5~" "~rms/foo.~3~")
— Function: file-newest-backup filename
This function returns the name of the most recent backup file for filename, or nil if that file has no backup files.

Some file comparison commands use this function so that they can automatically compare a file with its most recent backup.

*** 2. Auto-Saving: How auto-save files are made; how their names are chosen.
Emacs periodically saves all files that you are visiting; this is called auto-saving. Auto-saving prevents you from losing more than a limited amount of work if the system crashes. By default, auto-saves happen every 300 keystrokes, or after around 30 seconds of idle time. See Auto Save, for information on auto-save for users. Here we describe the functions used to implement auto-saving and the variables that control them.

— Variable: buffer-auto-save-file-name
This buffer-local variable is the name of the file used for auto-saving the current buffer. It is nil if the buffer should not be auto-saved.

          buffer-auto-save-file-name
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"
— Command: auto-save-mode arg
This is the mode command for Auto Save mode, a buffer-local minor mode. When Auto Save mode is enabled, auto-saving is enabled in the buffer. The calling convention is the same as for other minor mode commands (see Minor Mode Conventions).

Unlike most minor modes, there is no auto-save-mode variable. Auto Save mode is enabled if buffer-auto-save-file-name is non-nil and buffer-saved-size (see below) is non-zero.

— Function: auto-save-file-name-p filename
This function returns a non-nil value if filename is a string that could be the name of an auto-save file. It assumes the usual naming convention for auto-save files: a name that begins and ends with hash marks (‘#’) is a possible auto-save file name. The argument filename should not contain a directory part.

          (make-auto-save-file-name)
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"
          (auto-save-file-name-p "#backups.texi#")
               ⇒ 0
          (auto-save-file-name-p "backups.texi")
               ⇒ nil
The standard definition of this function is as follows:

          (defun auto-save-file-name-p (filename)
            "Return non-nil if FILENAME can be yielded by..."
            (string-match "^#.*#$" filename))
This function exists so that you can customize it if you wish to change the naming convention for auto-save files. If you redefine it, be sure to redefine the function make-auto-save-file-name correspondingly.

— Function: make-auto-save-file-name
This function returns the file name to use for auto-saving the current buffer. This is just the file name with hash marks (‘#’) prepended and appended to it. This function does not look at the variable auto-save-visited-file-name (described below); callers of this function should check that variable first.

          (make-auto-save-file-name)
               ⇒ "/xcssun/users/rms/lewis/#backups.texi#"
Here is a simplified version of the standard definition of this function:

          (defun make-auto-save-file-name ()
            "Return file name to use for auto-saves \
          of current buffer.."
            (if buffer-file-name
                (concat
                 (file-name-directory buffer-file-name)
                 "#"
                 (file-name-nondirectory buffer-file-name)
                 "#")
              (expand-file-name
               (concat "#%" (buffer-name) "#"))))
This exists as a separate function so that you can redefine it to customize the naming convention for auto-save files. Be sure to change auto-save-file-name-p in a corresponding way.

— User Option: auto-save-visited-file-name
If this variable is non-nil, Emacs auto-saves buffers in the files they are visiting. That is, the auto-save is done in the same file that you are editing. Normally, this variable is nil, so auto-save files have distinct names that are created by make-auto-save-file-name.

When you change the value of this variable, the new value does not take effect in an existing buffer until the next time auto-save mode is reenabled in it. If auto-save mode is already enabled, auto-saves continue to go in the same file name until auto-save-mode is called again.

Note that setting this variable to a non-nil value does not change the fact that auto-saving is different from saving the buffer; e.g., the hooks described in Saving Buffers are not run when a buffer is auto-saved.

— Function: recent-auto-save-p
This function returns t if the current buffer has been auto-saved since the last time it was read in or saved.

— Function: set-buffer-auto-saved
This function marks the current buffer as auto-saved. The buffer will not be auto-saved again until the buffer text is changed again. The function returns nil.

— User Option: auto-save-interval
The value of this variable specifies how often to do auto-saving, in terms of number of input events. Each time this many additional input events are read, Emacs does auto-saving for all buffers in which that is enabled. Setting this to zero disables autosaving based on the number of characters typed.

— User Option: auto-save-timeout
The value of this variable is the number of seconds of idle time that should cause auto-saving. Each time the user pauses for this long, Emacs does auto-saving for all buffers in which that is enabled. (If the current buffer is large, the specified timeout is multiplied by a factor that increases as the size increases; for a million-byte buffer, the factor is almost 4.)

If the value is zero or nil, then auto-saving is not done as a result of idleness, only after a certain number of input events as specified by auto-save-interval.

— Variable: auto-save-hook
This normal hook is run whenever an auto-save is about to happen.

— User Option: auto-save-default
If this variable is non-nil, buffers that are visiting files have auto-saving enabled by default. Otherwise, they do not.

— Command: do-auto-save &optional no-message current-only
This function auto-saves all buffers that need to be auto-saved. It saves all buffers for which auto-saving is enabled and that have been changed since the previous auto-save.

If any buffers are auto-saved, do-auto-save normally displays a message saying ‘Auto-saving...’ in the echo area while auto-saving is going on. However, if no-message is non-nil, the message is inhibited.

If current-only is non-nil, only the current buffer is auto-saved.

— Function: delete-auto-save-file-if-necessary &optional force
This function deletes the current buffer's auto-save file if delete-auto-save-files is non-nil. It is called every time a buffer is saved.

Unless force is non-nil, this function only deletes the file if it was written by the current Emacs session since the last true save.

— User Option: delete-auto-save-files
This variable is used by the function delete-auto-save-file-if-necessary. If it is non-nil, Emacs deletes auto-save files when a true save is done (in the visited file). This saves disk space and unclutters your directory.

— Function: rename-auto-save-file
This function adjusts the current buffer's auto-save file name if the visited file name has changed. It also renames an existing auto-save file, if it was made in the current Emacs session. If the visited file name has not changed, this function does nothing.

— Variable: buffer-saved-size
The value of this buffer-local variable is the length of the current buffer, when it was last read in, saved, or auto-saved. This is used to detect a substantial decrease in size, and turn off auto-saving in response.

If it is −1, that means auto-saving is temporarily shut off in this buffer due to a substantial decrease in size. Explicitly saving the buffer stores a positive value in this variable, thus reenabling auto-saving. Turning auto-save mode off or on also updates this variable, so that the substantial decrease in size is forgotten.

If it is −2, that means this buffer should disregard changes in buffer size; in particular, it should not shut off auto-saving temporarily due to changes in buffer size.

— Variable: auto-save-list-file-name
This variable (if non-nil) specifies a file for recording the names of all the auto-save files. Each time Emacs does auto-saving, it writes two lines into this file for each buffer that has auto-saving enabled. The first line gives the name of the visited file (it's empty if the buffer has none), and the second gives the name of the auto-save file.

When Emacs exits normally, it deletes this file; if Emacs crashes, you can look in the file to find all the auto-save files that might contain work that was otherwise lost. The recover-session command uses this file to find them.

The default name for this file specifies your home directory and starts with ‘.saves-’. It also contains the Emacs process ID and the host name.

— User Option: auto-save-list-file-prefix
After Emacs reads your init file, it initializes auto-save-list-file-name (if you have not already set it non-nil) based on this prefix, adding the host name and process ID. If you set this to nil in your init file, then Emacs does not initialize auto-save-list-file-name.


*** 3. Reverting: revert-buffer, and how to customize what it does.
If you have made extensive changes to a file and then change your mind about them, you can get rid of them by reading in the previous version of the file with the revert-buffer command. See Reverting a Buffer.

— Command: revert-buffer &optional ignore-auto noconfirm preserve-modes
This command replaces the buffer text with the text of the visited file on disk. This action undoes all changes since the file was visited or saved.

By default, if the latest auto-save file is more recent than the visited file, and the argument ignore-auto is nil, revert-buffer asks the user whether to use that auto-save instead. When you invoke this command interactively, ignore-auto is t if there is no numeric prefix argument; thus, the interactive default is not to check the auto-save file.

Normally, revert-buffer asks for confirmation before it changes the buffer; but if the argument noconfirm is non-nil, revert-buffer does not ask for confirmation.

Normally, this command reinitializes the buffer's major and minor modes using normal-mode. But if preserve-modes is non-nil, the modes remain unchanged.

Reverting tries to preserve marker positions in the buffer by using the replacement feature of insert-file-contents. If the buffer contents and the file contents are identical before the revert operation, reverting preserves all the markers. If they are not identical, reverting does change the buffer; in that case, it preserves the markers in the unchanged text (if any) at the beginning and end of the buffer. Preserving any additional markers would be problematical.

— Variable: revert-buffer-in-progress-p
revert-buffer binds this variable to a non-nil value while it is working.

You can customize how revert-buffer does its work by setting the variables described in the rest of this section.

— User Option: revert-without-query
This variable holds a list of files that should be reverted without query. The value is a list of regular expressions. If the visited file name matches one of these regular expressions, and the file has changed on disk but the buffer is not modified, then revert-buffer reverts the file without asking the user for confirmation.

Some major modes customize revert-buffer by making buffer-local bindings for these variables:

— Variable: revert-buffer-function
The value of this variable is the function to use to revert this buffer. It should be a function with two optional arguments to do the work of reverting. The two optional arguments, ignore-auto and noconfirm, are the arguments that revert-buffer received.

Modes such as Dired mode, in which the text being edited does not consist of a file's contents but can be regenerated in some other fashion, can give this variable a buffer-local value that is a special function to regenerate the contents.

— Variable: revert-buffer-insert-file-contents-function
The value of this variable specifies the function to use to insert the updated contents when reverting this buffer. The function receives two arguments: first the file name to use; second, t if the user has asked to read the auto-save file.

The reason for a mode to change this variable instead of revert-buffer-function is to avoid duplicating or replacing the rest of what revert-buffer does: asking for confirmation, clearing the undo list, deciding the proper major mode, and running the hooks listed below.

— Variable: before-revert-hook
This normal hook is run by the default revert-buffer-function before inserting the modified contents. A custom revert-buffer-function may or may not run this hook.

— Variable: after-revert-hook
This normal hook is run by the default revert-buffer-function after inserting the modified contents. A custom revert-buffer-function may or may not run this hook.

Emacs can revert buffers automatically. It does that by default for buffers visiting files. The following describes how to add support for auto-reverting new types of buffers.

First, such buffers must have a suitable revert-buffer-function and buffer-stale-function defined.

— Variable: buffer-stale-function
The value of this variable specifies a function to call to check whether a buffer needs reverting. The default value only handles buffers that are visiting files, by checking their modification time. Buffers that are not visiting files require a custom function of one optional argument noconfirm. The function should return non-nil if the buffer should be reverted. The buffer is current when this function is called.

While this function is mainly intended for use in auto-reverting, it could be used for other purposes as well. For instance, if auto-reverting is not enabled, it could be used to warn the user that the buffer needs reverting. The idea behind the noconfirm argument is that it should be t if the buffer is going to be reverted without asking the user and nil if the function is just going to be used to warn the user that the buffer is out of date. In particular, for use in auto-reverting, noconfirm is t. If the function is only going to be used for auto-reverting, you can ignore the noconfirm argument.

If you just want to automatically auto-revert every auto-revert-interval seconds (like the Buffer Menu), use:

          (setq-local buffer-stale-function
               #'(lambda (&optional noconfirm) 'fast))
in the buffer's mode function.

The special return value ‘fast’ tells the caller that the need for reverting was not checked, but that reverting the buffer is fast. It also tells Auto Revert not to print any revert messages, even if auto-revert-verbose is non-nil. This is important, as getting revert messages every auto-revert-interval seconds can be very annoying. The information provided by this return value could also be useful if the function is consulted for purposes other than auto-reverting.

Once the buffer has a suitable revert-buffer-function and buffer-stale-function, several problems usually remain.

The buffer will only auto-revert if it is marked unmodified. Hence, you will have to make sure that various functions mark the buffer modified if and only if either the buffer contains information that might be lost by reverting, or there is reason to believe that the user might be inconvenienced by auto-reverting, because he is actively working on the buffer. The user can always override this by manually adjusting the modified status of the buffer. To support this, calling the revert-buffer-function on a buffer that is marked unmodified should always keep the buffer marked unmodified.

It is important to assure that point does not continuously jump around as a consequence of auto-reverting. Of course, moving point might be inevitable if the buffer radically changes.

You should make sure that the revert-buffer-function does not print messages that unnecessarily duplicate Auto Revert's own messages, displayed if auto-revert-verbose is t, and effectively override a nil value for auto-revert-verbose. Hence, adapting a mode for auto-reverting often involves getting rid of such messages. This is especially important for buffers that automatically revert every auto-revert-interval seconds.

If the new auto-reverting is part of Emacs, you should mention it in the documentation string of global-auto-revert-non-file-buffers.

Similarly, you should document the additions in the Emacs manual.

* 27 Buffers
A buffer is a Lisp object containing text to be edited. Buffers are used to hold the contents of files that are being visited; there may also be buffers that are not visiting files. While several buffers may exist at one time, only one buffer is designated the current buffer at any time. Most editing commands act on the contents of the current buffer. Each buffer, including the current buffer, may or may not be displayed in any windows.

** 1. Buffer Basics: What is a buffer?
** 2. Current Buffer: Designating a buffer as current so that primitives will access its contents.
** 3. Buffer Names: Accessing and changing buffer names.
** 4. Buffer File Name: The buffer file name indicates which file is visited.
** 5. Buffer Modification: A buffer is modified if it needs to be saved.
** 6. Modification Time: Determining whether the visited file was changed behind Emacs's back.
** 7. Read Only Buffers: Modifying text is not allowed in a read-only buffer.
** 8. Buffer List: How to look at all the existing buffers.
** 9. Creating Buffers: Functions that create buffers.
** 10. Killing Buffers: Buffers exist until explicitly killed.
** 11. Indirect Buffers: An indirect buffer shares text with some other buffer.
** 12. Swapping Text: Swapping text between two buffers.
** 13. Buffer Gap: The gap in the buffer.



* 28 Windows
This chapter describes the functions and variables related to Emacs windows. See Frames, for how windows are assigned an area of screen available for Emacs to use. See Display, for information on how text is displayed in windows.

Basic Windows: Basic information on using windows.
Windows and Frames: Relating windows to the frame they appear on.
Window Sizes: Accessing a window's size.
Resizing Windows: Changing the sizes of windows.
Preserving Window Sizes: Preserving the size of windows.
Splitting Windows: Creating a new window.
Deleting Windows: Removing a window from its frame.
Recombining Windows: Preserving the frame layout when splitting and deleting windows.
Selecting Windows: The selected window is the one that you edit in.
Cyclic Window Ordering: Moving around the existing windows.
Buffers and Windows: Each window displays the contents of a buffer.
Switching Buffers: Higher-level functions for switching to a buffer.
Displaying Buffers: Displaying a buffer in a suitable window.
Window History: Each window remembers the buffers displayed in it.
Dedicated Windows: How to avoid displaying another buffer in a specific window.
Quitting Windows: How to restore the state prior to displaying a buffer.
Side Windows: Special windows on a frame's sides.
Atomic Windows: Preserving parts of the window layout.
Window Point: Each window has its own location of point.
Window Start and End: Buffer positions indicating which text is on-screen in a window.
Textual Scrolling: Moving text up and down through the window.
Vertical Scrolling: Moving the contents up and down on the window.
Horizontal Scrolling: Moving the contents sideways on the window.
Coordinates and Windows: Converting coordinates to windows.
Mouse Window Auto-selection: Automatically selecting windows with the mouse.
Window Configurations: Saving and restoring the state of the screen.
Window Parameters: Associating additional information with windows.
Window Hooks: Hooks for scrolling, window size changes, redisplay going past a certain point, or window configuration changes.
* 29 Frames
A frame is a screen object that contains one or more Emacs windows (see Windows). It is the kind of object called a “window” in the terminology of graphical environments; but we can't call it a “window” here, because Emacs uses that word in a different way. In Emacs Lisp, a frame object is a Lisp object that represents a frame on the screen. See Frame Type.

A frame initially contains a single main window and/or a minibuffer window; you can subdivide the main window vertically or horizontally into smaller windows. See Splitting Windows.

A terminal is a display device capable of displaying one or more Emacs frames. In Emacs Lisp, a terminal object is a Lisp object that represents a terminal. See Terminal Type.

There are two classes of terminals: text terminals and graphical terminals. Text terminals are non-graphics-capable displays, including xterm and other terminal emulators. On a text terminal, each Emacs frame occupies the terminal's entire screen; although you can create additional frames and switch between them, the terminal only shows one frame at a time. Graphical terminals, on the other hand, are managed by graphical display systems such as the X Window System, which allow Emacs to show multiple frames simultaneously on the same display.

On GNU and Unix systems, you can create additional frames on any available terminal, within a single Emacs session, regardless of whether Emacs was started on a text or graphical terminal. Emacs can display on both graphical and text terminals simultaneously. This comes in handy, for instance, when you connect to the same session from several remote locations. See Multiple Terminals.

— Function: framep object
This predicate returns a non-nil value if object is a frame, and nil otherwise. For a frame, the value indicates which kind of display the frame uses:

t
The frame is displayed on a text terminal.
x
The frame is displayed on an X graphical terminal.
w32
The frame is displayed on a MS-Windows graphical terminal.
ns
The frame is displayed on a GNUstep or Macintosh Cocoa graphical terminal.
pc
The frame is displayed on an MS-DOS terminal.
— Function: frame-terminal &optional frame
This function returns the terminal object that displays frame. If frame is nil or unspecified, it defaults to the selected frame.

— Function: terminal-live-p object
This predicate returns a non-nil value if object is a terminal that is live (i.e., not deleted), and nil otherwise. For live terminals, the return value indicates what kind of frames are displayed on that terminal; the list of possible values is the same as for framep above.

On a graphical terminal we distinguish two types of frames: A normal top-level frame is a frame whose window-system window is a child of the window-system's root window for that terminal. A child frame is a frame whose window-system window is the child of the window-system window of another Emacs frame. See Child Frames.

Creating Frames: Creating additional frames.
Multiple Terminals: Displaying on several different devices.
Frame Geometry: Geometric properties of frames.
Frame Parameters: Controlling frame size, position, font, etc.
Terminal Parameters: Parameters common for all frames on terminal.
Frame Titles: Automatic updating of frame titles.
Deleting Frames: Frames last until explicitly deleted.
Finding All Frames: How to examine all existing frames.
Minibuffers and Frames: How a frame finds the minibuffer to use.
Input Focus: Specifying the selected frame.
Visibility of Frames: Frames may be visible or invisible, or icons.
Raising and Lowering: Raising, Lowering and Restacking Frames.
Frame Configurations: Saving the state of all frames.
Child Frames: Making a frame the child of another.
Mouse Tracking: Getting events that say when the mouse moves.
Mouse Position: Asking where the mouse is, or moving it.
Pop-Up Menus: Displaying a menu for the user to select from.
Dialog Boxes: Displaying a box to ask yes or no.
Pointer Shape: Specifying the shape of the mouse pointer.
Window System Selections: Transferring text to and from other X clients.
Drag and Drop: Internals of Drag-and-Drop implementation.
Color Names: Getting the definitions of color names.
Text Terminal Colors: Defining colors for text terminals.
Resources: Getting resource values from the server.
Display Feature Testing: Determining the features of a terminal.
* 30 Positions
A position is the index of a character in the text of a buffer. More precisely, a position identifies the place between two characters (or before the first character, or after the last character), so we can speak of the character before or after a given position. However, we often speak of the character “at” a position, meaning the character after that position.

Positions are usually represented as integers starting from 1, but can also be represented as markers—special objects that relocate automatically when text is inserted or deleted so they stay with the surrounding characters. Functions that expect an argument to be a position (an integer), but accept a marker as a substitute, normally ignore which buffer the marker points into; they convert the marker to an integer, and use that integer, exactly as if you had passed the integer as the argument, even if the marker points to the wrong buffer. A marker that points nowhere cannot convert to an integer; using it instead of an integer causes an error. See Markers.

See also the field feature (see Fields), which provides functions that are used by many cursor-motion commands.

Point: The special position where editing takes place.
Motion: Changing point.
Excursions: Temporary motion and buffer changes.
Narrowing: Restricting editing to a portion of the buffer.
* 31 Markers
A marker is a Lisp object used to specify a position in a buffer relative to the surrounding text. A marker changes its offset from the beginning of the buffer automatically whenever text is inserted or deleted, so that it stays with the two characters on either side of it.

Overview of Markers: The components of a marker, and how it relocates.
Predicates on Markers: Testing whether an object is a marker.
Creating Markers: Making empty markers or markers at certain places.
Information from Markers: Finding the marker's buffer or character position.
Marker Insertion Types: Two ways a marker can relocate when you insert where it points.
Moving Markers: Moving the marker to a new buffer or position.
The Mark: How the mark is implemented xwith a marker.
The Region: How to access the region.
* 32 Text
This chapter describes the functions that deal with the text in a buffer. Most examine, insert, or delete text in the current buffer, often operating at point or on text adjacent to point. Many are interactive. All the functions that change the text provide for undoing the changes (see Undo).

Many text-related functions operate on a region of text defined by two buffer positions passed in arguments named start and end. These arguments should be either markers (see Markers) or numeric character positions (see Positions). The order of these arguments does not matter; it is all right for start to be the end of the region and end the beginning. For example, (delete-region 1 10) and (delete-region 10 1) are equivalent. An args-out-of-range error is signaled if either start or end is outside the accessible portion of the buffer. In an interactive call, point and the mark are used for these arguments.

Throughout this chapter, “text” refers to the characters in the buffer, together with their properties (when relevant). Keep in mind that point is always between two characters, and the cursor appears on the character after point.

** 1. Near Point: Examining text in the vicinity of point.
** 2. Buffer Contents: Examining text in a general fashion.
** 3. Comparing Text: Comparing substrings of buffers.
** 4. Insertion: Adding new text to a buffer.
** 5. Commands for Insertion: User-level commands to insert text.
** 6. Deletion: Removing text from a buffer.
** 7. User-Level Deletion: User-level commands to delete text.
** 8. The Kill Ring: Where removed text sometimes is saved for later use.
** 9. Undo: Undoing changes to the text of a buffer.
** 10. Maintaining Undo: How to enable and disable undo information. How to control how much information is kept.
** 11. Filling: Functions for explicit filling.
** 12. Margins: How to specify margins for filling commands.
** 13. Adaptive Fill: Adaptive Fill mode chooses a fill prefix from context.
** 14. Auto Filling: How auto-fill mode is implemented to break lines.
** 15. Sorting: Functions for sorting parts of the buffer.
** 16. Columns: Computing horizontal positions, and using them.
** 17. Indentation: Functions to insert or adjust indentation.
** 18. Case Changes: Case conversion of parts of the buffer.
** 19. Text Properties: Assigning Lisp property lists to text characters.
** 20. Substitution: Replacing a given character wherever it appears.
** 21. Registers: How registers are implemented. Accessing the text or position stored in a register.
** 22. Transposition: Swapping two portions of a buffer.
** 23. Replacing: Replacing the text of one buffer with the text of another buffer.
** 24. Decompression: Dealing with compressed data.
** 25. Base 64: Conversion to or from base 64 encoding.
** 26. Checksum/Hash: Computing cryptographic hashes.
** 27. GnuTLS Cryptography: Cryptographic algorithms imported from GnuTLS.
** 28. Parsing HTML/XML: Parsing HTML and XML.
** 29. Atomic Changes: Installing several buffer changes atomically.
** 30. Change Hooks: Supplying functions to be run when text is changed.

* 33 Non-ASCII Characters
This chapter covers the special issues relating to characters and how they are stored in strings and buffers.

Text Representations: How Emacs represents text.
Disabling Multibyte: Controlling whether to use multibyte characters.
Converting Representations: Converting unibyte to multibyte and vice versa.
Selecting a Representation: Treating a byte sequence as unibyte or multi.
Character Codes: How unibyte and multibyte relate to codes of individual characters.
Character Properties: Character attributes that define their behavior and handling.
Character Sets: The space of possible character codes is divided into various character sets.
Scanning Charsets: Which character sets are used in a buffer?
Translation of Characters: Translation tables are used for conversion.
Coding Systems: Coding systems are conversions for saving files.
Input Methods: Input methods allow users to enter various non-ASCII characters without special keyboards.
Locales: Interacting with the POSIX locale.
* 34 Searching and Matching
GNU Emacs provides two ways to search through a buffer for specified text: exact string searches and regular expression searches. After a regular expression search, you can examine the match data to determine which text matched the whole regular expression or various portions of it.

String Search: Search for an exact match.
Searching and Case: Case-independent or case-significant searching.
Regular Expressions: Describing classes of strings.
Regexp Search: Searching for a match for a regexp.
POSIX Regexps: Searching POSIX-style for the longest match.
Match Data: Finding out which part of the text matched, after a string or regexp search.
Search and Replace: Commands that loop, searching and replacing.
Standard Regexps: Useful regexps for finding sentences, pages,...
The ‘skip-chars...’ functions also perform a kind of searching. See Skipping Characters. To search for changes in character properties, see Property Search.

** 34.3 Regular Expressions

A regular expression, or regexp for short, is a pattern that denotes a (possibly infinite) set of strings. Searching for matches for a regexp is a very powerful operation. This section explains how to write regexps; the following section says how to search for them.

For interactive development of regular expressions, you can use the M-x re-builder command. It provides a convenient interface for creating regular expressions, by giving immediate visual feedback in a separate buffer. As you edit the regexp, all its matches in the target buffer are highlighted. Each parenthesized sub-expression of the regexp is shown in a distinct face, which makes it easier to verify even very complex regexps.

*** Syntax of Regexps: Rules for writing regular expressions.

Regular expressions have a syntax in which a few characters are special constructs and the rest are ordinary. An ordinary character is a simple regular expression that matches that character and nothing else. The special characters are ‘.’, ‘*’, ‘+’, ‘?’, ‘[’, ‘^’, ‘$’, and ‘\’; no new special characters will be defined in the future. The character ‘]’ is special if it ends a character alternative (see later). The character ‘-’ is special inside a character alternative. A ‘[:’ and balancing ‘:]’ enclose a character class inside a character alternative. Any other character appearing in a regular expression is ordinary, unless a ‘\’ precedes it.

For example, ‘f’ is not a special character, so it is ordinary, and therefore ‘f’ is a regular expression that matches the string ‘f’ and no other string. (It does not match the string ‘fg’, but it does match a part of that string.) Likewise, ‘o’ is a regular expression that matches only ‘o’.

Any two regular expressions a and b can be concatenated. The result is a regular expression that matches a string if a matches some amount of the beginning of that string and b matches the rest of the string.

As a simple example, we can concatenate the regular expressions ‘f’ and ‘o’ to get the regular expression ‘fo’, which matches only the string ‘fo’. Still trivial. To do something more powerful, you need to use one of the special regular expression constructs.

**** Regexp Special: Special characters in regular expressions.
**** Char Classes: Character classes used in regular expressions.
Here is a table of the classes you can use in a character alternative, and what they mean:

‘[:ascii:]’
    This matches any ASCII character (codes 0–127).
‘[:alnum:]’
    This matches any letter or digit. For multibyte characters, it matches characters whose Unicode ‘general-category’ property (see Character Properties) indicates they are alphabetic or decimal number characters.
‘[:alpha:]’
    This matches any letter. For multibyte characters, it matches characters whose Unicode ‘general-category’ property (see Character Properties) indicates they are alphabetic characters.
‘[:blank:]’
    This matches horizontal whitespace, as defined by Annex C of the Unicode Technical Standard #18. In particular, it matches spaces, tabs, and other characters whose Unicode ‘general-category’ property (see Character Properties) indicates they are spacing separators.
‘[:cntrl:]’
    This matches any ASCII control character.
‘[:digit:]’
    This matches ‘0’ through ‘9’. Thus, ‘[-+[:digit:]]’ matches any digit, as well as ‘+’ and ‘-’.
‘[:graph:]’
    This matches graphic characters—everything except whitespace, ASCII and non-ASCII control characters, surrogates, and codepoints unassigned by Unicode, as indicated by the Unicode ‘general-category’ property (see Character Properties).
‘[:lower:]’
    This matches any lower-case letter, as determined by the current case table (see Case Tables). If case-fold-search is non-nil, this also matches any upper-case letter.
‘[:multibyte:]’
    This matches any multibyte character (see Text Representations).
‘[:nonascii:]’
    This matches any non-ASCII character.
‘[:print:]’
    This matches any printing character—either whitespace, or a graphic character matched by ‘[:graph:]’.
‘[:punct:]’
    This matches any punctuation character. (At present, for multibyte characters, it matches anything that has non-word syntax.)
‘[:space:]’
    This matches any character that has whitespace syntax (see Syntax Class Table).
‘[:unibyte:]’
    This matches any unibyte character (see Text Representations).
‘[:upper:]’
    This matches any upper-case letter, as determined by the current case table (see Case Tables). If case-fold-search is non-nil, this also matches any lower-case letter.
‘[:word:]’
    This matches any character that has word syntax (see Syntax Class Table).
‘[:xdigit:]’
    This matches the hexadecimal digits: ‘0’ through ‘9’, ‘a’ through ‘f’ and ‘A’ through ‘F’. 


**** Regexp Backslash: Backslash-sequences in regular expressions.

*** Regexp Example: Illustrates regular expression syntax.
*** Regexp Functions: Functions for operating on regular expressions.

* 35 Syntax Tables
A syntax table specifies the syntactic role of each character in a buffer. It can be used to determine where words, symbols, and other syntactic constructs begin and end. This information is used by many Emacs facilities, including Font Lock mode (see Font Lock Mode) and the various complex movement commands (see Motion).

Basics: Basic concepts of syntax tables.
Syntax Descriptors: How characters are classified.
Syntax Table Functions: How to create, examine and alter syntax tables.
Syntax Properties: Overriding syntax with text properties.
Motion and Syntax: Moving over characters with certain syntaxes.
Parsing Expressions: Parsing balanced expressions using the syntax table.
Syntax Table Internals: How syntax table information is stored.
Categories: Another way of classifying character syntax.

*** 35.2.1 Table of Syntax Classes
Here is a table of syntax classes, the characters that designate them, their meanings, and examples of their use.

Whitespace characters: ‘ ’ or ‘-’
    Characters that separate symbols and words from each other. Typically, whitespace characters have no other syntactic significance, and multiple whitespace characters are syntactically equivalent to a single one. Space, tab, and formfeed are classified as whitespace in almost all major modes.

    This syntax class can be designated by either ‘ ’ or ‘-’. Both designators are equivalent.
Word constituents: ‘w’
    Parts of words in human languages. These are typically used in variable and command names in programs. All upper- and lower-case letters, and the digits, are typically word constituents.
Symbol constituents: ‘_’
    Extra characters used in variable and command names along with word constituents. Examples include the characters ‘$&*+-_<>’ in Lisp mode, which may be part of a symbol name even though they are not part of English words. In standard C, the only non-word-constituent character that is valid in symbols is underscore (‘_’).
Punctuation characters: ‘.’
    Characters used as punctuation in a human language, or used in a programming language to separate symbols from one another. Some programming language modes, such as Emacs Lisp mode, have no characters in this class since the few characters that are not symbol or word constituents all have other uses. Other programming language modes, such as C mode, use punctuation syntax for operators.
Open parenthesis characters: ‘(’
Close parenthesis characters: ‘)’
    Characters used in dissimilar pairs to surround sentences or expressions. Such a grouping is begun with an open parenthesis character and terminated with a close. Each open parenthesis character matches a particular close parenthesis character, and vice versa. Normally, Emacs indicates momentarily the matching open parenthesis when you insert a close parenthesis. See Blinking.

    In human languages, and in C code, the parenthesis pairs are ‘()’, ‘[]’, and ‘{}’. In Emacs Lisp, the delimiters for lists and vectors (‘()’ and ‘[]’) are classified as parenthesis characters.
String quotes: ‘"’
    Characters used to delimit string constants. The same string quote character appears at the beginning and the end of a string. Such quoted strings do not nest.

    The parsing facilities of Emacs consider a string as a single token. The usual syntactic meanings of the characters in the string are suppressed.

    The Lisp modes have two string quote characters: double-quote (‘"’) and vertical bar (‘|’). ‘|’ is not used in Emacs Lisp, but it is used in Common Lisp. C also has two string quote characters: double-quote for strings, and apostrophe (‘'’) for character constants.

    Human text has no string quote characters. We do not want quotation marks to turn off the usual syntactic properties of other characters in the quotation.
Escape-syntax characters: ‘\’
    Characters that start an escape sequence, such as is used in string and character constants. The character ‘\’ belongs to this class in both C and Lisp. (In C, it is used thus only inside strings, but it turns out to cause no trouble to treat it this way throughout C code.)

    Characters in this class count as part of words if words-include-escapes is non-nil. See Word Motion.
Character quotes: ‘/’
    Characters used to quote the following character so that it loses its normal syntactic meaning. This differs from an escape character in that only the character immediately following is ever affected.

    Characters in this class count as part of words if words-include-escapes is non-nil. See Word Motion.

    This class is used for backslash in TeX mode.
Paired delimiters: ‘$’
    Similar to string quote characters, except that the syntactic properties of the characters between the delimiters are not suppressed. Only TeX mode uses a paired delimiter presently—the ‘$’ that both enters and leaves math mode.
Expression prefixes: ‘'’
    Characters used for syntactic operators that are considered as part of an expression if they appear next to one. In Lisp modes, these characters include the apostrophe, ‘'’ (used for quoting), the comma, ‘,’ (used in macros), and ‘#’ (used in the read syntax for certain data types).
Comment starters: ‘<’
Comment enders: ‘>’
    Characters used in various languages to delimit comments. Human text has no comment characters. In Lisp, the semicolon (‘;’) starts a comment and a newline or formfeed ends one.
Inherit standard syntax: ‘@’
    This syntax class does not specify a particular syntax. It says to look in the standard syntax table to find the syntax of this character.
Generic comment delimiters: ‘!’
    Characters that start or end a special kind of comment. Any generic comment delimiter matches any generic comment delimiter, but they cannot match a comment starter or comment ender; generic comment delimiters can only match each other.

    This syntax class is primarily meant for use with the syntax-table text property (see Syntax Properties). You can mark any range of characters as forming a comment, by giving the first and last characters of the range syntax-table properties identifying them as generic comment delimiters.
Generic string delimiters: ‘|’
    Characters that start or end a string. This class differs from the string quote class in that any generic string delimiter can match any other generic string delimiter; but they do not match ordinary string quote characters.

    This syntax class is primarily meant for use with the syntax-table text property (see Syntax Properties). You can mark any range of characters as forming a string constant, by giving the first and last characters of the range syntax-table properties identifying them as generic string delimiters.
* 36 Abbrevs and Abbrev Expansion

An abbreviation or abx brev is a string of characters that may be expanded to a longer string. The user can insert the abbrev string and find it replaced automatically with the expansion of the abbrev. This saves typing.

The set of abbrevs currently in effect is recorded in an abbrev table. Each buffer has a local abbrev table, but normally all buffers in the same major mode share one abbrev table. There is also a global abbrev table. Normally both are used.

An abbrev table is represented as an obarray. See Creating Symbols, for information about obarrays. Each abbreviation is represented by a symbol in the obarray. The symbol's name is the abbreviation; its value is the expansion; its function definition is the hook function for performing the expansion (see Defining Abbrevs); and its property list cell contains various additional properties, including the use count and the number of times the abbreviation has been expanded (see Abbrev Properties).
* 37 Threads
Emacs Lisp provides a limited form of concurrency, called threads. All the threads in a given instance of Emacs share the same memory. Concurrency in Emacs Lisp is “mostly cooperative”, meaning that Emacs will only switch execution between threads at well-defined times. However, the Emacs thread support has been designed in a way to later allow more fine-grained concurrency, and correct programs should not rely on cooperative threading.

Currently, thread switching will occur upon explicit request via thread-yield, when waiting for keyboard input or for process output from asynchronous processes (e.g., during accept-process-output), or during blocking operations relating to threads, such as mutex locking or thread-join.

Emacs Lisp provides primitives to create and control threads, and also to create and control mutexes and condition variables, useful for thread synchronization.

While global variables are shared among all Emacs Lisp threads, local variables are not—a dynamic let binding is local. Each thread also has its own current buffer (see Current Buffer) and its own match data (see Match Data).

Note that let bindings are treated specially by the Emacs Lisp implementation. There is no way to duplicate this unwinding and rewinding behavior other than by using let. For example, a manual implementation of let written using unwind-protect cannot arrange for variable values to be thread-specific.

In the case of lexical bindings (see Variable Scoping), a closure is an object like any other in Emacs Lisp, and bindings in a closure are shared by any threads invoking the closure.

** 1. Basic Thread Functions: Basic thread functions.
Threads can be created and waited for. A thread cannot be exited directly, but the current thread can be exited implicitly, and other threads can be signaled.

— Function: make-thread function &optional name
Create a new thread of execution which invokes function. When function returns, the thread exits.

The new thread is created with no local variable bindings in effect. The new thread's current buffer is inherited from the current thread.

name can be supplied to give a name to the thread. The name is used for debugging and informational purposes only; it has no meaning to Emacs. If name is provided, it must be a string.

This function returns the new thread.

— Function: threadp object
This function returns t if object represents an Emacs thread, nil otherwise.

— Function: thread-join thread
Block until thread exits, or until the current thread is signaled. If thread has already exited, this returns immediately.

— Function: thread-signal thread error-symbol data
Like signal (see Signaling Errors), but the signal is delivered in the thread thread. If thread is the current thread, then this just calls signal immediately. Otherwise, thread will receive the signal as soon as it becomes current. If thread was blocked by a call to mutex-lock, condition-wait, or thread-join; thread-signal will unblock it.

— Function: thread-yield
Yield execution to the next runnable thread.

— Function: thread-name thread
Return the name of thread, as specified to make-thread.

— Function: thread-live-p thread
Return t if thread is alive, or nil if it is not. A thread is alive as long as its function is still executing.

— Function: thread–blocker thread
Return the object that thread is waiting on. This function is primarily intended for debugging, and is given a “double hyphen” name to indicate that.

If thread is blocked in thread-join, this returns the thread for which it is waiting.

If thread is blocked in mutex-lock, this returns the mutex.

If thread is blocked in condition-wait, this returns the condition variable.

Otherwise, this returns nil.

— Function: current-thread
Return the current thread.

— Function: all-threads
Return a list of all the live thread objects. A new list is returned by each invocation.

When code run by a thread signals an error that is unhandled, the thread exits. Other threads can access the error form which caused the thread to exit using the following function.

— Function: thread-last-error
This function returns the last error form recorded when a thread exited due to an error. Each thread that exits abnormally overwrites the form stored by the previous thread's error with a new value, so only the last one can be accessed.


** 2. Mutexes: Mutexes allow exclusive access to data.
A mutex is an exclusive lock. At any moment, zero or one threads may own a mutex. If a thread attempts to acquire a mutex, and the mutex is already owned by some other thread, then the acquiring thread will block until the mutex becomes available.

Emacs Lisp mutexes are of a type called recursive, which means that a thread can re-acquire a mutex it owns any number of times. A mutex keeps a count of how many times it has been acquired, and each acquisition of a mutex must be paired with a release. The last release by a thread of a mutex reverts it to the unowned state, potentially allowing another thread to acquire the mutex.

— Function: mutexp object
This function returns t if object represents an Emacs mutex, nil otherwise.

— Function: make-mutex &optional name
Create a new mutex and return it. If name is specified, it is a name given to the mutex. It must be a string. The name is for debugging purposes only; it has no meaning to Emacs.

— Function: mutex-name mutex
Return the name of mutex, as specified to make-mutex.

— Function: mutex-lock mutex
This will block until this thread acquires mutex, or until this thread is signaled using thread-signal. If mutex is already owned by this thread, this simply returns.

— Function: mutex-unlock mutex
Release mutex. If mutex is not owned by this thread, this will signal an error.

— Macro: with-mutex mutex body...
This macro is the simplest and safest way to evaluate forms while holding a mutex. It acquires mutex, invokes body, and then releases mutex. It returns the result of body.
** 3. Condition Variables: Inter-thread events.
A condition variable is a way for a thread to block until some event occurs. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.

A condition variable is associated with a mutex and, conceptually, with some condition. For proper operation, the mutex must be acquired, and then a waiting thread must loop, testing the condition and waiting on the condition variable. For example:

     (with-mutex mutex
       (while (not global-variable)
         (condition-wait cond-var)))
The mutex ensures atomicity, and the loop is for robustness—there may be spurious notifications.

Similarly, the mutex must be held before notifying the condition. The typical, and best, approach is to acquire the mutex, make the changes associated with this condition, and then notify it:

     (with-mutex mutex
       (setq global-variable (some-computation))
       (condition-notify cond-var))
— Function: make-condition-variable mutex &optional name
Make a new condition variable associated with mutex. If name is specified, it is a name given to the condition variable. It must be a string. The name is for debugging purposes only; it has no meaning to Emacs.

— Function: condition-variable-p object
This function returns t if object represents a condition variable, nil otherwise.

— Function: condition-wait cond
Wait for another thread to notify cond, a condition variable. This function will block until the condition is notified, or until a signal is delivered to this thread using thread-signal.

It is an error to call condition-wait without holding the condition's associated mutex.

condition-wait releases the associated mutex while waiting. This allows other threads to acquire the mutex in order to notify the condition.

— Function: condition-notify cond &optional all
Notify cond. The mutex with cond must be held before calling this. Ordinarily a single waiting thread is woken by condition-notify; but if all is not nil, then all threads waiting on cond are notified.

condition-notify releases the associated mutex while waiting. This allows other threads to acquire the mutex in order to wait on the condition.
— Function: condition-name cond
Return the name of cond, as passed to make-condition-variable.

— Function: condition-mutex cond
Return the mutex associated with cond. Note that the associated mutex cannot be changed.
* 38 Processes
- [GNU Emacs Lisp Reference Manual](https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Processes)
In the terminology of operating systems, a process is a space in which a program can execute. Emacs runs in a process. Emacs Lisp programs can invoke other programs in processes of their own. These are called subprocesses or child processes of the Emacs process, which is their parent process.

A subprocess of Emacs may be synchronous or asynchronous, depending on how it is created. When you create a synchronous subprocess, the Lisp program waits for the subprocess to terminate before continuing execution. When you create an asynchronous subprocess, it can run in parallel with the Lisp program. This kind of subprocess is represented within Emacs by a Lisp object which is also called a “process”. Lisp programs can use this object to communicate with the subprocess or to control it. For example, you can send signals, obtain status information, receive output from the process, or send input to it.

In addition to processes that run programs, Lisp programs can open connections of several types to devices or processes running on the same machine or on other machines. The supported connection types are: TCP and UDP network connections, serial port connections, and pipe connections. Each such connection is also represented by a process object.

— Function: processp object

This function returns t if object represents an Emacs process object, nil otherwise. The process object can represent a subprocess running a program or a connection of any supported type.

In addition to subprocesses of the current Emacs session, you can also access other processes running on your machine. See System Processes.

** 1.Subprocess Creation: Functions that start subprocesses.
There are three primitives that create a new subprocess in which to run a program. One of them, =make-process=, creates an asynchronous process and returns a process object (see Asynchronous Processes). The other two, =call-process= and =call-process-region=, create a synchronous process and do not return a process object (see Synchronous Processes). There are various higher-level functions that make use of these primitives to run particular types of process.

Synchronous and asynchronous processes are explained in the following sections. Since the three functions are all called in a similar fashion, their common arguments are described here.

In all cases, the functions specify the program to be run. An error is signaled if the file is not found or cannot be executed. If the file name is relative, the variable =exec-path= contains a list of directories to search. Emacs initializes =exec-path= when it starts up, based on the value of the environment variable PATH. The standard file name constructs, ‘~’, ‘.’, and ‘..’, are interpreted as usual in exec-path, but environment variable substitutions (‘$HOME’, etc.) are not recognized; use substitute-in-file-name to perform them (see File Name Expansion). nil in this list refers to default-directory.

Executing a program can also try adding suffixes to the specified name:

— User Option: =exec-suffixes=
This variable is a list of suffixes (strings) to try adding to the specified program file name. The list should include "" if you want the name to be tried exactly as specified. The default value is system-dependent.

Please note: The argument program contains only the name of the program file; it may not contain any command-line arguments. You must use a separate argument, args, to provide those, as described below.

Each of the subprocess-creating functions has a buffer-or-name argument that specifies where the output from the program will go. It should be a buffer or a buffer name; if it is a buffer name, that will create the buffer if it does not already exist. It can also be nil, which says to discard the output, unless a custom filter function handles it. (See Filter Functions, and Read and Print.) Normally, you should avoid having multiple processes send output to the same buffer because their output would be intermixed randomly. For synchronous processes, you can send the output to a file instead of a buffer (and the corresponding argument is therefore more appropriately called destination). By default, both standard output and standard error streams go to the same destination, but all the 3 primitives allow optionally to direct the standard error stream to a different destination.

All three of the subprocess-creating functions allow to specify command-line arguments for the process to run. For call-process and call-process-region, these come in the form of a &rest argument, args. For make-process, both the program to run and its command-line arguments are specified as a list of strings. The command-line arguments must all be strings, and they are supplied to the program as separate argument strings. Wildcard characters and other shell constructs have no special meanings in these strings, since the strings are passed directly to the specified program.

The subprocess inherits its environment from Emacs, but you can specify overrides for it with process-environment. See System Environment. The subprocess gets its current directory from the value of default-directory.

— Variable: =exec-directory=
The value of this variable is a string, the name of a directory that contains programs that come with GNU Emacs and are intended for Emacs to invoke. The program movemail is an example of such a program; Rmail uses it to fetch new mail from an inbox.

— User Option: ~exec-path~
The value of this variable is a list of directories to search for programs to run in subprocesses. Each element is either the name of a directory (i.e., a string), or nil, which stands for the default directory (which is the value of default-directory). See executable-find, for the details of this search. The value of exec-path is used by call-process and start-process when the program argument is not an absolute file name.

Generally, you should not modify exec-path directly. Instead, ensure that your PATH environment variable is set appropriately before starting Emacs. Trying to modify exec-path independently of PATH can lead to confusing results.

** 2.Shell Arguments: Quoting an argument to pass it to a shell.
Lisp programs sometimes need to run a shell and give it a command that contains file names that were specified by the user. These programs ought to be able to support any valid file name. But the shell gives special treatment to certain characters, and if these characters occur in the file name, they will confuse the shell. To handle these characters, use the function shell-quote-argument:

— Function: ==shell-quote-argument= argument
This function returns a string that represents, in shell syntax, an argument whose actual contents are argument. It should work reliably to concatenate the return value into a shell command and then pass it to a shell for execution.

Precisely what this function does depends on your operating system. The function is designed to work with the syntax of your system's standard shell; if you use an unusual shell, you will need to redefine this function. See Security Considerations.
#+BEGIN_SRC elisp

          ;; This example shows the behavior on GNU and Unix systems.
          (shell-quote-argument "foo > bar")
               ⇒ "foo\\ \\>\\ bar"

          ;; This example shows the behavior on MS-DOS and MS-Windows.
          (shell-quote-argument "foo > bar")
               ⇒ "\"foo > bar\""

#+END_SRC
Here's an example of using shell-quote-argument to construct a shell command:
#+BEGIN_SRC elisp
          (concat "diff -u "
                  (shell-quote-argument oldfile)
                  " "
                  (shell-quote-argument newfile))

#+END_SRC

The following two functions are useful for combining a list of individual command-line argument strings into a single string, and taking a string apart into a list of individual command-line arguments. These functions are mainly intended for converting user input in the minibuffer, a Lisp string, into a list of string arguments to be passed to make-process, call-process or start-process, or for converting such lists of arguments into a single Lisp string to be presented in the minibuffer or echo area. Note that if a shell is involved (e.g., if using call-process-shell-command), arguments should still be protected by shell-quote-argument; combine-and-quote-strings is not intended to protect special characters from shell evaluation.

— Function: =split-string-and-unquote= string &optional separators
This function splits string into substrings at matches for the regular expression separators, like split-string does (see Creating Strings); in addition, it removes quoting from the substrings. It then makes a list of the substrings and returns it.

If separators is omitted or nil, it defaults to "\\s-+", which is a regular expression that matches one or more characters with whitespace syntax (see Syntax Class Table).

This function supports two types of quoting: enclosing a whole string in double quotes "...", and quoting individual characters with a backslash escape ‘\’. The latter is also used in Lisp strings, so this function can handle those as well.

— Function: ==combine-and-quote-strings= list-of-strings &optional separator
This function concatenates list-of-strings into a single string, quoting each string as necessary. It also sticks the separator string between each pair of strings; if separator is omitted or nil, it defaults to " ". The return value is the resulting string.

The strings in list-of-strings that need quoting are those that include separator as their substring. Quoting a string encloses it in double quotes "...". In the simplest case, if you are consing a command from the individual command-line arguments, every argument that includes embedded blanks will be quoted.
** 3.Synchronous Processes: Details of using synchronous subprocesses.
After a synchronous process is created, Emacs waits for the process to terminate before continuing. Starting Dired on GNU or Unix19 is an example of this: it runs ls in a synchronous process, then modifies the output slightly. Because the process is synchronous, the entire directory listing arrives in the buffer before Emacs tries to do anything with it.

While Emacs waits for the synchronous subprocess to terminate, the user can quit by typing *C-g*. The first C-g tries to kill the subprocess with a SIGINT signal; but it waits until the subprocess actually terminates before quitting. If during that time the user types another C-g, that kills the subprocess instantly with SIGKILL and quits immediately (except on MS-DOS, where killing other processes doesn't work). See Quitting.

The synchronous subprocess functions return an indication of how the process terminated.

The output from a synchronous subprocess is generally decoded using a coding system, much like text read from a file. The input sent to a subprocess by call-process-region is encoded using a coding system, much like text written into a file. See Coding Systems.

— Function: =call-process= program &optional infile destination display &rest args
This function calls program and waits for it to finish.

The current working directory of the subprocess is set to the current buffer's value of default-directory if that is local (as determined by unhandled-file-name-directory), or "~" otherwise. If you want to run a process in a remote directory use process-file.

The standard input for the new process comes from file infile if infile is not nil, and from the null device otherwise. The argument destination says where to put the process output. Here are the possibilities:

*a buffer*
  Insert the output in that buffer, before point. This includes both the standard output stream and the standard error stream of the process.
*a buffer name (a string)**
  Insert the output in a buffer with that name, before point.
*t*
  Insert the output in the current buffer, before point.
*nil*
  Discard the output.
*0*
Discard the output, and return nil immediately without waiting for the subprocess to finish.
In this case, the process is not truly synchronous, since it can run in parallel with Emacs; but you can think of it as synchronous in that Emacs is essentially finished with the subprocess as soon as this function returns.

MS-DOS doesn't support asynchronous subprocesses, so this option doesn't work there.

(:file file-name)

Send the output to the file name specified, overwriting it if it already exists.
(real-destination error-destination)
Keep the standard output stream separate from the standard error stream; deal with the ordinary output as specified by real-destination, and dispose of the error output according to error-destination. If error-destination is nil, that means to discard the error output, t means mix it with the ordinary output, and a string specifies a file name to redirect error output into.
You can't directly specify a buffer to put the error output in; that is too difficult to implement. But you can achieve this result by sending the error output to a temporary file and then inserting the file into a buffer when the subprocess finishes.

If display is non-nil, then call-process redisplays the buffer as output is inserted. (However, if the coding system chosen for decoding output is undecided, meaning deduce the encoding from the actual data, then redisplay sometimes cannot continue once non-ASCII characters are encountered. There are fundamental reasons why it is hard to fix this; see Output from Processes.)

Otherwise the function call-process does no redisplay, and the results become visible on the screen only when Emacs redisplays that buffer in the normal course of events.

The remaining arguments, args, are strings that specify command line arguments for the program. Each string is passed to program as a separate argument.

The value returned by call-process (unless you told it not to wait) indicates the reason for process termination. A number gives the exit status of the subprocess; 0 means success, and any other value means failure. If the process terminated with a signal, call-process returns a string describing the signal. If you told call-process not to wait, it returns nil.

In the examples below, the buffer ‘foo’ is current.

          (call-process "pwd" nil t)
               ⇒ 0

          ---------- Buffer: foo ----------
          /home/lewis/manual
          ---------- Buffer: foo ----------

          (call-process "grep" nil "bar" nil "lewis" "/etc/passwd")
               ⇒ 0

          ---------- Buffer: bar ----------
          lewis:x:1001:1001:Bil Lewis,,,,:/home/lewis:/bin/bash

          ---------- Buffer: bar ----------
Here is an example of the use of call-process, as used to be found in the definition of the insert-directory function:

          (call-process insert-directory-program nil t nil switches
                        (if full-directory-p
                            (concat (file-name-as-directory file) ".")
                          file))
— Function: process-file program &optional infile buffer display &rest args
This function processes files synchronously in a separate process. It is similar to call-process, but may invoke a file handler based on the value of the variable default-directory, which specifies the current working directory of the subprocess.

The arguments are handled in almost the same way as for call-process, with the following differences:

Some file handlers may not support all combinations and forms of the arguments infile, buffer, and display. For example, some file handlers might behave as if display were nil, regardless of the value actually passed. As another example, some file handlers might not support separating standard output and error output by way of the buffer argument.

If a file handler is invoked, it determines the program to run based on the first argument program. For instance, suppose that a handler for remote files is invoked. Then the path that is used for searching for the program might be different from exec-path.

The second argument infile may invoke a file handler. The file handler could be different from the handler chosen for the process-file function itself. (For example, default-directory could be on one remote host, and infile on a different remote host. Or default-directory could be non-special, whereas infile is on a remote host.)

If buffer is a list of the form (real-destination error-destination), and error-destination names a file, then the same remarks as for infile apply.

The remaining arguments (args) will be passed to the process verbatim. Emacs is not involved in processing file names that are present in args. To avoid confusion, it may be best to avoid absolute file names in args, but rather to specify all file names as relative to default-directory. The function file-relative-name is useful for constructing such relative file names. Alternatively, you can use file-local-name (see Magic File Names) to obtain an absolute file name as seen from the remote host's perspective.

— Variable: process-file-side-effects
This variable indicates whether a call of process-file changes remote files.

By default, this variable is always set to t, meaning that a call of process-file could potentially change any file on a remote host. When set to nil, a file handler could optimize its behavior with respect to remote file attribute caching.

You should only ever change this variable with a let-binding; never with setq.

— Function: call-process-region start end program &optional delete destination display &rest args
This function sends the text from start to end as standard input to a process running program. It deletes the text sent if delete is non-nil; this is useful when destination is t, to insert the output in the current buffer in place of the input.

The arguments destination and display control what to do with the output from the subprocess, and whether to update the display as it comes in. For details, see the description of call-process, above. If destination is the integer 0, call-process-region discards the output and returns nil immediately, without waiting for the subprocess to finish (this only works if asynchronous subprocesses are supported; i.e., not on MS-DOS).

The remaining arguments, args, are strings that specify command line arguments for the program.

The return value of call-process-region is just like that of call-process: nil if you told it to return without waiting; otherwise, a number or string which indicates how the subprocess terminated.

In the following example, we use call-process-region to run the cat utility, with standard input being the first five characters in buffer ‘foo’ (the word ‘input’). cat copies its standard input into its standard output. Since the argument destination is t, this output is inserted in the current buffer.

          ---------- Buffer: foo ----------
          input-!-
          ---------- Buffer: foo ----------

          (call-process-region 1 6 "cat" nil t)
               ⇒ 0

          ---------- Buffer: foo ----------
          inputinput-!-
          ---------- Buffer: foo ----------
For example, the shell-command-on-region command uses call-shell-region in a manner similar to this:

          (call-shell-region
           start end
           command              ; shell command
           nil                  ; do not delete region
           buffer)              ; send output to buffer
— Function: call-process-shell-command command &optional infile destination display
This function executes the shell command command synchronously. The other arguments are handled as in call-process. An old calling convention allowed passing any number of additional arguments after display, which were concatenated to command; this is still supported, but strongly discouraged.

— Function: process-file-shell-command command &optional infile destination display
This function is like call-process-shell-command, but uses process-file internally. Depending on default-directory, command can be executed also on remote hosts. An old calling convention allowed passing any number of additional arguments after display, which were concatenated to command; this is still supported, but strongly discouraged.

— Function: call-shell-region start end command &optional delete destination
This function sends the text from start to end as standard input to an inferior shell running command. This function is similar than call-process-region, with process being a shell. The arguments delete, destination and the return value are like in call-process-region. Note that this function doesn't accept additional arguments.

— Function: shell-command-to-string command
This function executes command (a string) as a shell command, then returns the command's output as a string.

— Function: process-lines program &rest args
This function runs program, waits for it to finish, and returns its output as a list of strings. Each string in the list holds a single line of text output by the program; the end-of-line characters are stripped from each line. The arguments beyond program, args, are strings that specify command-line arguments with which to run the program.

If program exits with a non-zero exit status, this function signals an error.

This function works by calling call-process, so program output is decoded in the same way as for call-process.


** 4.Asynchronous Processes: Starting up an asynchronous subprocess.
In this section, we describe how to create an asynchronous process. After an asynchronous process is created, it runs in parallel with Emacs, and Emacs can communicate with it using the functions described in the following sections (see Input to Processes, and see Output from Processes). Note that process communication is only partially asynchronous: Emacs sends data to the process only when certain functions are called, and Emacs accepts data from the process only while waiting for input or for a time delay.

An asynchronous process is controlled either via a pty (pseudo-terminal) or a pipe. The choice of pty or pipe is made when creating the process, by default based on the value of the variable process-connection-type (see below). If available, ptys are usually preferable for processes visible to the user, as in Shell mode, because they allow for job control (C-c, C-z, etc.) between the process and its children, and because interactive programs treat ptys as terminal devices, whereas pipes don't support these features. However, for subprocesses used by Lisp programs for internal purposes (i.e., no user interaction with the subprocess is required), where significant amounts of data need to be exchanged between the subprocess and the Lisp program, it is often better to use a pipe, because pipes are more efficient. Also, the total number of ptys is limited on many systems, and it is good not to waste them unnecessarily.

— Function: =make-process= &rest args
This function is the basic low-level primitive for starting asynchronous subprocesses. It returns a process object representing the subprocess. Compared to the more high-level =start-process=, described below, it takes keyword arguments, is more flexible, and allows to specify process filters and sentinels in a single call.

The arguments args are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value nil. Here are the meaningful keywords:

:name name
Use the string name as the process name; if a process with this name already exists, then name is modified (by appending ‘<1>’, etc.) to be unique.
:buffer buffer
Use buffer as the process buffer. If the value is nil, the subprocess is not associated with any buffer.
:command command
Use command as the command line of the process. The value should be a list starting with the program's executable file name, followed by strings to give to the program as its arguments. If the first element of the list is nil, Emacs opens a new pseudoterminal (pty) and associates its input and output with buffer, without actually running any program; the rest of the list elements are ignored in that case.
:coding coding
If coding is a symbol, it specifies the coding system to be used for both reading and writing of data from and to the connection. If coding is a cons cell (decoding . encoding), then decoding will be used for reading and encoding for writing. The coding system used for encoding the data written to the program is also used for encoding the command-line arguments (but not the program itself, whose file name is encoded as any other file name; see file-name-coding-system).
If coding is nil, the default rules for finding the coding system will apply. See Default Coding Systems.

:connection-type type
Initialize the type of device used to communicate with the subprocess. Possible values are pty to use a pty, pipe to use a pipe, or nil to use the default derived from the value of the process-connection-type variable. This parameter and the value of process-connection-type are ignored if a non-nil value is specified for the :stderr parameter; in that case, the type will always be pipe. On systems where ptys are not available (MS-Windows), this parameter is likewise ignored, and pipes are used unconditionally.
:noquery query-flag
Initialize the process query flag to query-flag. See Query Before Exit.
:stop stopped
If stopped is non-nil, start the process in the stopped state.
:filter filter
Initialize the process filter to filter. If not specified, a default filter will be provided, which can be overridden later. See Filter Functions.
:sentinel sentinel
Initialize the process sentinel to sentinel. If not specified, a default sentinel will be used, which can be overridden later. See Sentinels.
:stderr stderr
Associate stderr with the standard error of the process. A non-nil value should be either a buffer or a pipe process created with make-pipe-process, described below.
The original argument list, modified with the actual connection information, is available via the process-contact function.

The current working directory of the subprocess is set to the current buffer's value of default-directory if that is local (as determined by `unhandled-file-name-directory'), or "~" otherwise. If you want to run a process in a remote directory use start-file-process.

— Function: make-pipe-process &rest args
This function creates a bidirectional pipe which can be attached to a child process. This is useful with the :stderr keyword of make-process. The function returns a process object.

The arguments args are a list of keyword/argument pairs. Omitting a keyword is always equivalent to specifying it with value nil.

Here are the meaningful keywords:

:name name
Use the string name as the process name. As with make-process, it is modified if necessary to make it unique.
:buffer buffer
Use buffer as the process buffer.
:coding coding
If coding is a symbol, it specifies the coding system to be used for both reading and writing of data from and to the connection. If coding is a cons cell (decoding . encoding), then decoding will be used for reading and encoding for writing.
If coding is nil, the default rules for finding the coding system will apply. See Default Coding Systems.

:noquery query-flag
Initialize the process query flag to query-flag. See Query Before Exit.
:stop stopped
If stopped is non-nil, start the process in the stopped state. In the stopped state, a pipe process does not accept incoming data, but you can send outgoing data. The stopped state is set by stop-process and cleared by continue-process (see Signals to Processes).
:filter filter
Initialize the process filter to filter. If not specified, a default filter will be provided, which can be changed later. See Filter Functions.
:sentinel sentinel
Initialize the process sentinel to sentinel. If not specified, a default sentinel will be used, which can be changed later. See Sentinels.
The original argument list, modified with the actual connection information, is available via the process-contact function.

— Function: start-process name buffer-or-name program &rest args
This function is a higher-level wrapper around make-process, exposing an interface that is similar to call-process. It creates a new asynchronous subprocess and starts the specified program running in it. It returns a process object that stands for the new subprocess in Lisp. The argument name specifies the name for the process object; as with make-process, it is modified if necessary to make it unique. The buffer buffer-or-name is the buffer to associate with the process.

If program is nil, Emacs opens a new pseudoterminal (pty) and associates its input and output with buffer-or-name, without creating a subprocess. In that case, the remaining arguments args are ignored.

The rest of args are strings that specify command line arguments for the subprocess.

In the example below, the first process is started and runs (rather, sleeps) for 100 seconds (the output buffer ‘foo’ is created immediately). Meanwhile, the second process is started, and given the name ‘my-process<1>’ for the sake of uniqueness. It inserts the directory listing at the end of the buffer ‘foo’, before the first process finishes. Then it finishes, and a message to that effect is inserted in the buffer. Much later, the first process finishes, and another message is inserted in the buffer for it.

          (start-process "my-process" "foo" "sleep" "100")
               ⇒ #<process my-process>

          (start-process "my-process" "foo" "ls" "-l" "/bin")
               ⇒ #<process my-process<1>>

          ---------- Buffer: foo ----------
          total 8336
          -rwxr-xr-x 1 root root 971384 Mar 30 10:14 bash
          -rwxr-xr-x 1 root root 146920 Jul  5  2011 bsd-csh
          ...
          -rwxr-xr-x 1 root root 696880 Feb 28 15:55 zsh4

          Process my-process<1> finished

          Process my-process finished
          ---------- Buffer: foo ----------
— Function: start-file-process name buffer-or-name program &rest args
Like start-process, this function starts a new asynchronous subprocess running program in it, and returns its process object.

The difference from start-process is that this function may invoke a file handler based on the value of default-directory. This handler ought to run program, perhaps on the local host, perhaps on a remote host that corresponds to default-directory. In the latter case, the local part of default-directory becomes the working directory of the process.

This function does not try to invoke file name handlers for program or for the rest of args. For that reason, if program or any of args use the remote-file syntax (see Magic File Names), they must be converted either to file names relative to default-directory, or to names that identify the files locally on the remote host, by running them through file-local-name.

Depending on the implementation of the file handler, it might not be possible to apply process-filter or process-sentinel to the resulting process object. See Filter Functions, and Sentinels.
Some file handlers may not support start-file-process (for example the function ange-ftp-hook-function). In such cases, this function does nothing and returns nil.

— Function: start-process-shell-command name buffer-or-name command
This function is like start-process, except that it uses a shell to execute the specified command. The argument command is a shell command string. The variable shell-file-name specifies which shell to use.

The point of running a program through the shell, rather than directly with make-process or start-process, is so that you can employ shell features such as wildcards in the arguments. It follows that if you include any arbitrary user-specified arguments in the command, you should quote them with shell-quote-argument first, so that any special shell characters do not have their special shell meanings. See Shell Arguments. Of course, when executing commands based on user input you should also consider the security implications.

— Function: start-file-process-shell-command name buffer-or-name command
This function is like start-process-shell-command, but uses start-file-process internally. Because of this, command can also be executed on remote hosts, depending on default-directory.

— Variable: process-connection-type
This variable controls the type of device used to communicate with asynchronous subprocesses. If it is non-nil, then ptys are used, when available. Otherwise, pipes are used.

The value of process-connection-type takes effect when make-process or start-process is called. So you can specify how to communicate with one subprocess by binding the variable around the call to these functions.

Note that the value of this variable is ignored when make-process is called with a non-nil value of the :stderr parameter; in that case, Emacs will communicate with the process using pipes. It is also ignored if ptys are unavailable (MS-Windows).

          (let ((process-connection-type nil))  ; use a pipe
            (start-process ...))
To determine whether a given subprocess actually got a pipe or a pty, use the function process-tty-name (see Process Information).

** 5.Deleting Processes: Eliminating an asynchronous subprocess.
Deleting a process disconnects Emacs immediately from the subprocess. Processes are deleted automatically after they terminate, but not necessarily right away. You can delete a process explicitly at any time. If you explicitly delete a terminated process before it is deleted automatically, no harm results. Deleting a running process sends a signal to terminate it (and its child processes, if any), and calls the process sentinel. See Sentinels.

When a process is deleted, the process object itself continues to exist as long as other Lisp objects point to it. All the Lisp primitives that work on process objects accept deleted processes, but those that do I/O or send signals will report an error. The process mark continues to point to the same place as before, usually into a buffer where output from the process was being inserted.

— User Option: delete-exited-processes
This variable controls automatic deletion of processes that have terminated (due to calling exit or to a signal). If it is nil, then they continue to exist until the user runs list-processes. Otherwise, they are deleted immediately after they exit.

— Function: delete-process process
This function deletes a process, killing it with a SIGKILL signal if the process was running a program. The argument may be a process, the name of a process, a buffer, or the name of a buffer. (A buffer or buffer-name stands for the process that get-buffer-process returns.) Calling delete-process on a running process terminates it, updates the process status, and runs the sentinel immediately. If the process has already terminated, calling delete-process has no effect on its status, or on the running of its sentinel (which will happen sooner or later).

If the process object represents a network, serial, or pipe connection, its status changes to closed; otherwise, it changes to signal, unless the process already exited. See process-status.

          (delete-process "*shell*")
               ⇒ nil

** 6.Process Information: Accessing run-status and other attributes.
Several functions return information about processes.

— Command: =list-processes= &optional query-only buffer
This command displays a listing of all living processes. In addition, it finally deletes any process whose status was ‘Exited’ or ‘Signaled’. It returns nil.

The processes are shown in a buffer named *Process List* (unless you specify otherwise using the optional argument buffer), whose major mode is Process Menu mode.

If query-only is non-nil, it only lists processes whose query flag is non-nil. See Query Before Exit.

— Function: ==process-list=
This function returns a list of all processes that have not been deleted.

          (process-list)
               ⇒ (#<process display-time> #<process shell>)
— Function: =get-process= name
This function returns the process named name (a string), or nil if there is none. The argument name can also be a process object, in which case it is returned.

          (get-process "shell")
               ⇒ #<process shell>
— Function: process-command process
This function returns the command that was executed to start process. This is a list of strings, the first string being the program executed and the rest of the strings being the arguments that were given to the program. For a network, serial, or pipe connection, this is either nil, which means the process is running or t (process is stopped).

          (process-command (get-process "shell"))
               ⇒ ("bash" "-i")
— Function: ==process-contact= process &optional key
This function returns information about how a network, a serial, or a pipe connection was set up. When key is nil, it returns (hostname service) for a network connection, (port speed) for a serial connection, and t for a pipe connection. For an ordinary child process, this function always returns t when called with a nil key.

If key is t, the value is the complete status information for the connection, server, serial port, or pipe; that is, the list of keywords and values specified in make-network-process, make-serial-process, or make-pipe-process, except that some of the values represent the current status instead of what you specified.

For a network process, the values include (see make-network-process for a complete list):

:buffer
The associated value is the process buffer.
:filter
The associated value is the process filter function. See Filter Functions.
:sentinel
The associated value is the process sentinel function. See Sentinels.
:remote
In a connection, the address in internal format of the remote peer.
:local
The local address, in internal format.
:service
In a server, if you specified t for service, this value is the actual port number.
:local and :remote are included even if they were not specified explicitly in make-network-process.

For a serial connection, see make-serial-process and serial-process-configure for the list of keys. For a pipe connection, see make-pipe-process for the list of keys.

If key is a keyword, the function returns the value corresponding to that keyword.

— Function: process-id process
This function returns the PID of process. This is an integral number that distinguishes the process process from all other processes running on the same computer at the current time. The PID of a process is chosen by the operating system kernel when the process is started and remains constant as long as the process exists. For network, serial, and pipe connections, this function returns nil.

— Function: process-name process
This function returns the name of process, as a string.

— Function: process-status process-name
This function returns the status of process-name as a symbol. The argument process-name must be a process, a buffer, or a process name (a string).

The possible values for an actual subprocess are:

run
for a process that is running.
stop
for a process that is stopped but continuable.
exit
for a process that has exited.
signal
for a process that has received a fatal signal.
open
for a network, serial, or pipe connection that is open.
closed
for a network, serial, or pipe connection that is closed. Once a connection is closed, you cannot reopen it, though you might be able to open a new connection to the same place.
connect
for a non-blocking connection that is waiting to complete.
failed
for a non-blocking connection that has failed to complete.
listen
for a network server that is listening.
nil
if process-name is not the name of an existing process.
          (process-status (get-buffer "*shell*"))
               ⇒ run
For a network, serial, or pipe connection, process-status returns one of the symbols open, stop, or closed. The latter means that the other side closed the connection, or Emacs did delete-process. The value stop means that stop-process was called on the connection.

— Function: process-live-p process
This function returns non-nil if process is alive. A process is considered alive if its status is run, open, listen, connect or stop.

— Function: process-type process
This function returns the symbol network for a network connection or server, serial for a serial port connection, pipe for a pipe connection, or real for a subprocess created for running a program.

— Function: process-exit-status process
This function returns the exit status of process or the signal number that killed it. (Use the result of process-status to determine which of those it is.) If process has not yet terminated, the value is 0. For network, serial, and pipe connections that are already closed, the value is either 0 or 256, depending on whether the connection was closed normally or abnormally.

— Function: process-tty-name process
This function returns the terminal name that process is using for its communication with Emacs—or nil if it is using pipes instead of a pty (see process-connection-type in Asynchronous Processes). If process represents a program running on a remote host, the terminal name used by that program on the remote host is provided as process property remote-tty. If process represents a network, serial, or pipe connection, the value is nil.

— Function: process-coding-system process
This function returns a cons cell (decode . encode), describing the coding systems in use for decoding output from, and encoding input to, process (see Coding Systems).

— Function: set-process-coding-system process &optional decoding-system encoding-system
This function specifies the coding systems to use for subsequent output from and input to process. It will use decoding-system to decode subprocess output, and encoding-system to encode subprocess input.

Every process also has a property list that you can use to store miscellaneous values associated with the process.

— Function: process-get process propname
This function returns the value of the propname property of process.

— Function: process-put process propname value
This function sets the value of the propname property of process to value.

— Function: process-plist process
This function returns the process plist of process.

— Function: set-process-plist process plist
This function sets the process plist of process to plist.



** 7.Input to Processes: Sending input to an asynchronous subprocess.

Asynchronous subprocesses receive input when it is sent to them by Emacs, which is done with the functions in this section. You must specify the process to send input to, and the input data to send. If the subprocess runs a program, the data appears on the standard input of that program; for connections, the data is sent to the connected device or program.
Some operating systems have limited space for buffered input in a pty. On these systems, Emacs sends an EOF periodically amidst the other characters, to force them through. For most programs, these EOFs do no harm.

Subprocess input is normally encoded using a coding system before the subprocess receives it, much like text written into a file. You can use set-process-coding-system to specify which coding system to use (see Process Information). Otherwise, the coding system comes from coding-system-for-write, if that is non-nil; or else from the defaulting mechanism (see Default Coding Systems).

Sometimes the system is unable to accept input for that process, because the input buffer is full. When this happens, the send functions wait a short while, accepting output from subprocesses, and then try again. This gives the subprocess a chance to read more of its pending input and make space in the buffer. It also allows filters, sentinels and timers to run—so take account of that in writing your code.

In these functions, the process argument can be a process or the name of a process, or a buffer or buffer name (which stands for a process via get-buffer-process). nil means the current buffer's process.

— Function: process-send-string process string
This function sends process the contents of string as standard input. It returns nil. For example, to make a Shell buffer list files:

          (process-send-string "shell<1>" "ls\n")
               ⇒ nil
— Function: process-send-region process start end
This function sends the text in the region defined by start and end as standard input to process.

An error is signaled unless both start and end are integers or markers that indicate positions in the current buffer. (It is unimportant which number is larger.)

— Function: process-send-eof &optional process
This function makes process see an end-of-file in its input. The EOF comes after any text already sent to it. The function returns process.

          (process-send-eof "shell")
               ⇒ "shell"
— Function: process-running-child-p &optional process
This function will tell you whether a process, which must not be a connection but a real subprocess, has given control of its terminal to a child process of its own. If this is true, the function returns the numeric ID of the foreground process group of process; it returns nil if Emacs can be certain that this is not so. The value is t if Emacs cannot tell whether this is true. This function signals an error if process is a network, serial, or pipe connection, or is the subprocess is not active.

** 8.Signals to Processes: Stopping, continuing or interrupting an asynchronous subprocess.
Sending a signal to a subprocess is a way of interrupting its activities. There are several different signals, each with its own meaning. The set of signals and their names is defined by the operating system. For example, the signal SIGINT means that the user has typed C-c, or that some analogous thing has happened.

Each signal has a standard effect on the subprocess. Most signals kill the subprocess, but some stop (or resume) execution instead. Most signals can optionally be handled by programs; if the program handles the signal, then we can say nothing in general about its effects.

You can send signals explicitly by calling the functions in this section. Emacs also sends signals automatically at certain times: killing a buffer sends a SIGHUP signal to all its associated processes; killing Emacs sends a SIGHUP signal to all remaining processes. (SIGHUP is a signal that usually indicates that the user “hung up the phone”, i.e., disconnected.)

Each of the signal-sending functions takes two optional arguments: process and current-group.

The argument process must be either a process, a process name, a buffer, a buffer name, or nil. A buffer or buffer name stands for a process through get-buffer-process. nil stands for the process associated with the current buffer. Except with stop-process and continue-process, an error is signaled if process does not identify an active process, or if it represents a network, serial, or pipe connection.

The argument current-group is a flag that makes a difference when you are running a job-control shell as an Emacs subprocess. If it is non-nil, then the signal is sent to the current process-group of the terminal that Emacs uses to communicate with the subprocess. If the process is a job-control shell, this means the shell's current subjob. If current-group is nil, the signal is sent to the process group of the immediate subprocess of Emacs. If the subprocess is a job-control shell, this is the shell itself. If current-group is lambda, the signal is sent to the process-group that owns the terminal, but only if it is not the shell itself.

The flag current-group has no effect when a pipe is used to communicate with the subprocess, because the operating system does not support the distinction in the case of pipes. For the same reason, job-control shells won't work when a pipe is used. See process-connection-type in Asynchronous Processes.

— Function: =interrupt-process= &optional process current-group
This function interrupts the process process by sending the signal SIGINT. Outside of Emacs, typing the interrupt character (normally C-c on some systems, and <DEL> on others) sends this signal. When the argument current-group is non-nil, you can think of this function as typing C-c on the terminal by which Emacs talks to the subprocess.

— Function: ==kill-process= &optional process current-group
This function kills the process process by sending the signal SIGKILL. This signal kills the subprocess immediately, and cannot be handled by the subprocess.

— Function: quit-process &optional process current-group
This function sends the signal SIGQUIT to the process process. This signal is the one sent by the quit character (usually C-\) when you are not inside Emacs.

— Function: ==stop-process= &optional process current-group
This function stops the specified process. If it is a real subprocess running a program, it sends the signal SIGTSTP to that subprocess. If process represents a network, serial, or pipe connection, this function inhibits handling of the incoming data from the connection; for a network server, this means not accepting new connections. Use continue-process to resume normal execution.

Outside of Emacs, on systems with job control, the stop character (usually C-z) normally sends the SIGTSTP signal to a subprocess. When current-group is non-nil, you can think of this function as typing C-z on the terminal Emacs uses to communicate with the subprocess.

— Function: continue-process &optional process current-group
This function resumes execution of the process process. If it is a real subprocess running a program, it sends the signal SIGCONT to that subprocess; this presumes that process was stopped previously. If process represents a network, serial, or pipe connection, this function resumes handling of the incoming data from the connection. For serial connections, data that arrived during the time the process was stopped might be lost.

— Command: ==signal-process= process signal
This function sends a signal to process process. The argument signal specifies which signal to send; it should be an integer, or a symbol whose name is a signal.

The process argument can be a system process ID (an integer); that allows you to send signals to processes that are not children of Emacs. See System Processes.

Sometimes, it is necessary to send a signal to a non-local asynchronous process. This is possible by writing an own interrupt-process implementation. This function must be added then to interrupt-process-functions.

— Variable: interrupt-process-functions
This variable is a list of functions to be called for interrupt-process. The arguments of the functions are the same as for interrupt-process. These functions are called in the order of the list, until one of them returns non-nil. The default function, which shall always be the last in this list, is internal-default-interrupt-process.

This is the mechanism, how Tramp implements interrupt-process.

** 9.Output from Processes: Collecting output from an asynchronous subprocess.
The output that an asynchronous subprocess writes to its standard output stream is passed to a function called the filter function. The default filter function simply inserts the output into a buffer, which is called the associated buffer of the process (see Process Buffers). If the process has no buffer then the default filter discards the output.

If the subprocess writes to its standard error stream, by default the error output is also passed to the process filter function. If Emacs uses a pseudo-TTY (pty) for communication with the subprocess, then it is impossible to separate the standard output and standard error streams of the subprocess, because a pseudo-TTY has only one output channel. In that case, if you want to keep the output to those streams separate, you should redirect one of them to a file—for example, by using an appropriate shell command via start-process-shell-command or a similar function.

Alternatively, you could use the :stderr parameter with a non-nil value in a call to make-process (see make-process) to make the destination of the error output separate from the standard output; in that case, Emacs will use pipes for communicating with the subprocess.

When a subprocess terminates, Emacs reads any pending output, then stops reading output from that subprocess. Therefore, if the subprocess has children that are still live and still producing output, Emacs won't receive that output.

Output from a subprocess can arrive only while Emacs is waiting: when reading terminal input (see the function waiting-for-user-input-p), in sit-for and sleep-for (see Waiting), and in accept-process-output (see Accepting Output). This minimizes the problem of timing errors that usually plague parallel programming. For example, you can safely create a process and only then specify its buffer or filter function; no output can arrive before you finish, if the code in between does not call any primitive that waits.

— Variable: process-adaptive-read-buffering
On some systems, when Emacs reads the output from a subprocess, the output data is read in very small blocks, potentially resulting in very poor performance. This behavior can be remedied to some extent by setting the variable process-adaptive-read-buffering to a non-nil value (the default), as it will automatically delay reading from such processes, thus allowing them to produce more output before Emacs tries to read it.
;;
*1. Process Buffers: By default, output is put in a buffer.*

A process can (and usually does) have an associated buffer, which is an ordinary Emacs buffer that is used for two purposes: storing the output from the process, and deciding when to kill the process. You can also use the buffer to identify a process to operate on, since in normal practice only one process is associated with any given buffer. Many applications of processes also use the buffer for editing input to be sent to the process, but this is not built into Emacs Lisp.

By default, process output is inserted in the associated buffer. (You can change this by defining a custom filter function, see Filter Functions.) The position to insert the output is determined by the process-mark, which is then updated to point to the end of the text just inserted. Usually, but not always, the process-mark is at the end of the buffer.

Killing the associated buffer of a process also kills the process. Emacs asks for confirmation first, if the process's process-query-on-exit-flag is non-nil (see Query Before Exit). This confirmation is done by the function process-kill-buffer-query-function, which is run from kill-buffer-query-functions (see Killing Buffers).

— Function: =process-buffer= process
This function returns the associated buffer of the specified process.

          (process-buffer (get-process "shell"))
               ⇒ #<buffer *shell*>
— Function: process-mark process
This function returns the process marker for process, which is the marker that says where to insert output from the process.

If process does not have a buffer, process-mark returns a marker that points nowhere.

The default filter function uses this marker to decide where to insert process output, and updates it to point after the inserted text. That is why successive batches of output are inserted consecutively.

Custom filter functions normally should use this marker in the same fashion. For an example of a filter function that uses process-mark, see Process Filter Example.

When the user is expected to enter input in the process buffer for transmission to the process, the process marker separates the new input from previous output.

— Function: =set-process-buffer= process buffer
This function sets the buffer associated with process to buffer. If buffer is nil, the process becomes associated with no buffer.

— Function: get-buffer-process buffer-or-name
This function returns a nondeleted process associated with the buffer specified by buffer-or-name. If there are several processes associated with it, this function chooses one (currently, the one most recently created, but don't count on that). Deletion of a process (see delete-process) makes it ineligible for this function to return.

It is usually a bad idea to have more than one process associated with the same buffer.

          (get-buffer-process "*shell*")
               ⇒ #<process shell>
Killing the process's buffer deletes the process, which kills the subprocess with a SIGHUP signal (see Signals to Processes).

If the process's buffer is displayed in a window, your Lisp program may wish to tell the process the dimensions of that window, so that the process could adapt its output to those dimensions, much as it adapts to the screen dimensions. The following functions allow communicating this kind of information to processes; however, not all systems support the underlying functionality, so it is best to provide fallbacks, e.g., via command-line arguments or environment variables.

— Function: set-process-window-size process height width
Tell process that its logical window size has dimensions width by height, in character units. If this function succeeds in communicating this information to the process, it returns t; otherwise it returns nil.

When windows that display buffers associated with process change their dimensions, the affected processes should be told about these changes. By default, when the window configuration changes, Emacs will automatically call set-process-window-size on behalf of every process whose buffer is displayed in a window, passing it the smallest dimensions of all the windows displaying the process's buffer. This works via window-configuration-change-hook (see Window Hooks), which is told to invoke the function that is the value of the variable window-adjust-process-window-size-function for each process whose buffer is displayed in at least one window. You can customize this behavior by setting the value of that variable.

— User Option: window-adjust-process-window-size-function
The value of this variable should be a function of two arguments: a process and the list of windows displaying the process's buffer. When the function is called, the process's buffer is the current buffer. The function should return a cons cell (width . height) that describes the dimensions of the logical process window to be passed via a call to set-process-window-size. The function can also return nil, in which case Emacs will not call set-process-window-size for this process.

Emacs supplies two predefined values for this variable: window-adjust-process-window-size-smallest, which returns the smallest of all the dimensions of the windows that display a process's buffer; and window-adjust-process-window-size-largest, which returns the largest dimensions. For more complex strategies, write your own function.

This variable can be buffer-local.

If the process has the adjust-window-size-function property (see Process Information), its value overrides the global and buffer-local values of window-adjust-process-window-size-function.



*2. Filter Functions: Filter functions accept output from the process.**

   A process filter function is a function that receives the standard output from the associated process. All output from that process is passed to the filter. The default filter simply outputs directly to the process buffer.

By default, the error output from the process, if any, is also passed to the filter function, unless the destination for the standard error stream of the process was separated from the standard output when the process was created (see Output from Processes).

The filter function can only be called when Emacs is waiting for something, because process output arrives only at such times. Emacs waits when reading terminal input (see the function waiting-for-user-input-p), in sit-for and sleep-for (see Waiting), and in accept-process-output (see Accepting Output).

A filter function must accept two arguments: the associated process and a string, which is output just received from it. The function is then free to do whatever it chooses with the output.
Quitting is normally inhibited within a filter function—otherwise, the effect of typing C-g at command level or to quit a user command would be unpredictable. If you want to permit quitting inside a filter function, bind inhibit-quit to nil. In most cases, the right way to do this is with the macro with-local-quit. See Quitting.

If an error happens during execution of a filter function, it is caught automatically, so that it doesn't stop the execution of whatever program was running when the filter function was started. However, if debug-on-error is non-nil, errors are not caught. This makes it possible to use the Lisp debugger to debug filter functions. See Debugger.

Many filter functions sometimes (or always) insert the output in the process's buffer, mimicking the actions of the default filter. Such filter functions need to make sure that they save the current buffer, select the correct buffer (if different) before inserting output, and then restore the original buffer. They should also check whether the buffer is still alive, update the process marker, and in some cases update the value of point. Here is how to do these things:


     (defun ordinary-insertion-filter (proc string)
       (when (buffer-live-p (process-buffer proc))
         (with-current-buffer (process-buffer proc)
           (let ((moving (= (point) (process-mark proc))))
             (save-excursion
               ;; Insert the text, advancing the process marker.
               (goto-char (process-mark proc))
               (insert string)
               (set-marker (process-mark proc) (point)))
             (if moving (goto-char (process-mark proc)))))))
To make the filter force the process buffer to be visible whenever new text arrives, you could insert a line like the following just before the with-current-buffer construct:

     (display-buffer (process-buffer proc))
To force point to the end of the new output, no matter where it was previously, eliminate the variable moving from the example and call goto-char unconditionally.

Note that Emacs automatically saves and restores the match data while executing filter functions. See Match Data.

The output to the filter may come in chunks of any size. A program that produces the same output twice in a row may send it as one batch of 200 characters one time, and five batches of 40 characters the next. If the filter looks for certain text strings in the subprocess output, make sure to handle the case where one of these strings is split across two or more batches of output; one way to do this is to insert the received text into a temporary buffer, which can then be searched.

— Function: set-process-filter process filter
This function gives process the filter function filter. If filter is nil, it gives the process the default filter, which inserts the process output into the process buffer.

— Function: ==process-filter= process
This function returns the filter function of process.

In case the process's output needs to be passed to several filters, you can use add-function to combine an existing filter with a new one. See Advising Functions.

Here is an example of the use of a filter function:

     (defun keep-output (process output)
        (setq kept (cons output kept)))
          ⇒ keep-output
     (setq kept nil)
          ⇒ nil
     (set-process-filter (get-process "shell") 'keep-output)
          ⇒ keep-output
     (process-send-string "shell" "ls ~/other\n")
          ⇒ nil
     kept
          ⇒ ("lewis@slug:$ "
     "FINAL-W87-SHORT.MSS    backup.otl              kolstad.mss~
     address.txt             backup.psf              kolstad.psf
     backup.bib~             david.mss               resume-Dec-86.mss~
     backup.err              david.psf               resume-Dec.psf
     backup.mss              dland                   syllabus.mss
     "
     "#backups.mss#          backup.mss~             kolstad.mss
     ")


*3. Decoding Output: Filters can get unibyte or multibyte strings.*

When Emacs writes process output directly into a multibyte buffer, it decodes the output according to the process output coding system. If the coding system is raw-text or no-conversion, Emacs converts the unibyte output to multibyte using string-to-multibyte, and inserts the resulting multibyte text.

You can use set-process-coding-system to specify which coding system to use (see Process Information). Otherwise, the coding system comes from coding-system-for-read, if that is non-nil; or else from the defaulting mechanism (see Default Coding Systems). If the text output by a process contains null bytes, Emacs by default uses no-conversion for it; see inhibit-null-byte-detection, for how to control this behavior.

Warning: Coding systems such as undecided, which determine the coding system from the data, do not work entirely reliably with asynchronous subprocess output. This is because Emacs has to process asynchronous subprocess output in batches, as it arrives. Emacs must try to detect the proper coding system from one batch at a time, and this does not always work. Therefore, if at all possible, specify a coding system that determines both the character code conversion and the end of line conversion—that is, one like latin-1-unix, rather than undecided or latin-1.
When Emacs calls a process filter function, it provides the process output as a multibyte string or as a unibyte string according to the process's filter coding system. Emacs decodes the output according to the process output coding system, which usually produces a multibyte string, except for coding systems such as binary and raw-text.


4. Accepting Output: How to wait until process output arrives.

   Output from asynchronous subprocesses normally arrives only while Emacs is waiting for some sort of external event, such as elapsed time or terminal input. Occasionally it is useful in a Lisp program to explicitly permit output to arrive at a specific point, or even to wait until output arrives from a process.

— Function: =accept-process-output= &optional process seconds millisec just-this-one
This function allows Emacs to read pending output from processes. The output is given to their filter functions. If process is non-nil then this function does not return until some output has been received from process or process has closed the connection.

The arguments seconds and millisec let you specify timeout periods. The former specifies a period measured in seconds and the latter specifies one measured in milliseconds. The two time periods thus specified are added together, and accept-process-output returns after that much time, even if there is no subprocess output.

The argument millisec is obsolete (and should not be used), because seconds can be floating point to specify waiting a fractional number of seconds. If seconds is 0, the function accepts whatever output is pending but does not wait.
If process is a process, and the argument just-this-one is non-nil, only output from that process is handled, suspending output from other processes until some output has been received from that process or the timeout expires. If just-this-one is an integer, also inhibit running timers. This feature is generally not recommended, but may be necessary for specific applications, such as speech synthesis.

The function accept-process-output returns non-nil if it got output from process, or from any process if process is nil; this can occur even after a process has exited if the corresponding connection contains buffered data. The function returns nil if the timeout expired or the connection was closed before output arrived.


5. Processes and Threads: How processes and threads interact.

   Because threads were a relatively late addition to Emacs Lisp, and due to the way dynamic binding was sometimes used in conjunction with accept-process-output, by default a process is locked to the thread that created it. When a process is locked to a thread, output from the process can only be accepted by that thread.

A Lisp program can specify to which thread a process is to be locked, or instruct Emacs to unlock a process, in which case its output can be processed by any thread. Only a single thread will wait for output from a given process at one time—once one thread begins waiting for output, the process is temporarily locked until accept-process-output or sit-for returns.

If the thread exits, all the processes locked to it are unlocked.

— Function: process-thread process
Return the thread to which process is locked. If process is unlocked, return nil.

— Function: set-process-thread process thread
Set the locking thread of process to thread. thread may be nil, in which case the process is unlocked.


** 10.Sentinels: Sentinels run when process run-status changes.
A process sentinel is a function that is called whenever the associated process changes status for any reason, including signals (whether sent by Emacs or caused by the process's own actions) that terminate, stop, or continue the process. The process sentinel is also called if the process exits. The sentinel receives two arguments: the process for which the event occurred, and a string describing the type of event.

If no sentinel function was specified for a process, it will use the default sentinel function, which inserts a message in the process's buffer with the process name and the string describing the event.

The string describing the event looks like one of the following:

"finished\n".
"deleted\n".
"exited abnormally with code exitcode (core dumped)\n". The “core dumped” part is optional, and only appears if the process dumped core.
"failed with code fail-code\n".
"signal-description (core dumped)\n". The signal-description is a system-dependent textual description of a signal, e.g., "killed" for SIGKILL. The “core dumped” part is optional, and only appears if the process dumped core.
"open from host-name\n".
"open\n".
"connection broken by remote peer\n".
A sentinel runs only while Emacs is waiting (e.g., for terminal input, or for time to elapse, or for process output). This avoids the timing errors that could result from running sentinels at random places in the middle of other Lisp programs. A program can wait, so that sentinels will run, by calling sit-for or sleep-for (see Waiting), or accept-process-output (see Accepting Output). Emacs also allows sentinels to run when the command loop is reading input. delete-process calls the sentinel when it terminates a running process.

Emacs does not keep a queue of multiple reasons to call the sentinel of one process; it records just the current status and the fact that there has been a change. Therefore two changes in status, coming in quick succession, can call the sentinel just once. However, process termination will always run the sentinel exactly once. This is because the process status can't change again after termination.

Emacs explicitly checks for output from the process before running the process sentinel. Once the sentinel runs due to process termination, no further output can arrive from the process.

A sentinel that writes the output into the buffer of the process should check whether the buffer is still alive. If it tries to insert into a dead buffer, it will get an error. If the buffer is dead, (buffer-name (process-buffer process)) returns nil.
Quitting is normally inhibited within a sentinel—otherwise, the effect of typing C-g at command level or to quit a user command would be unpredictable. If you want to permit quitting inside a sentinel, bind inhibit-quit to nil. In most cases, the right way to do this is with the macro with-local-quit. See Quitting.

If an error happens during execution of a sentinel, it is caught automatically, so that it doesn't stop the execution of whatever programs was running when the sentinel was started. However, if debug-on-error is non-nil, errors are not caught. This makes it possible to use the Lisp debugger to debug the sentinel. See Debugger.

While a sentinel is running, the process sentinel is temporarily set to nil so that the sentinel won't run recursively. For this reason it is not possible for a sentinel to specify a new sentinel.

Note that Emacs automatically saves and restores the match data while executing sentinels. See Match Data.

— Function: set-process-sentinel process sentinel
This function associates sentinel with process. If sentinel is nil, then the process will have the default sentinel, which inserts a message in the process's buffer when the process status changes.

Changes in process sentinels take effect immediately—if the sentinel is slated to be run but has not been called yet, and you specify a new sentinel, the eventual call to the sentinel will use the new one.

          (defun msg-me (process event)
             (princ
               (format "Process: %s had the event '%s'" process event)))
          (set-process-sentinel (get-process "shell") 'msg-me)
               ⇒ msg-me
          (kill-process (get-process "shell"))
               -| Process: #<process shell> had the event 'killed'
               ⇒ #<process shell>
— Function: process-sentinel process
This function returns the sentinel of process.

In case a process status changes need to be passed to several sentinels, you can use add-function to combine an existing sentinel with a new one. See Advising Functions.

— Function: waiting-for-user-input-p
While a sentinel or filter function is running, this function returns non-nil if Emacs was waiting for keyboard input from the user at the time the sentinel or filter function was called, or nil if it was not.


** 11.Query Before Exit: Whether to query if exiting will kill a process.
When Emacs exits, it terminates all its subprocesses. For subprocesses that run a program, it sends them the SIGHUP signal; connections are simply closed. Because subprocesses may be doing valuable work, Emacs normally asks the user to confirm that it is ok to terminate them. Each process has a query flag, which, if non-nil, says that Emacs should ask for confirmation before exiting and thus killing that process. The default for the query flag is t, meaning do query.

— Function: process-query-on-exit-flag process
This returns the query flag of process.

— Function: set-process-query-on-exit-flag process flag
This function sets the query flag of process to flag. It returns flag.

Here is an example of using set-process-query-on-exit-flag on a shell process to avoid querying:

          (set-process-query-on-exit-flag (get-process "shell") nil)
               ⇒ nil
— User Option: confirm-kill-processes
If this user option is set to t (the default), then Emacs asks for confirmation before killing processes on exit. If it is nil, Emacs kills processes without confirmation, i.e., the query flag of all processes is ignored.


** 12.System Processes: Accessing other processes running on your system.
In addition to accessing and manipulating processes that are subprocesses of the current Emacs session, Emacs Lisp programs can also access other processes running on the same machine. We call these system processes, to distinguish them from Emacs subprocesses.

Emacs provides several primitives for accessing system processes. Not all platforms support these primitives; on those which don't, these primitives return nil.

— Function: list-system-processes
This function returns a list of all the processes running on the system. Each process is identified by its PID, a numerical process ID that is assigned by the OS and distinguishes the process from all the other processes running on the same machine at the same time.

— Function: process-attributes pid
This function returns an alist of attributes for the process specified by its process ID pid. Each association in the alist is of the form (key . value), where key designates the attribute and value is the value of that attribute. The various attribute keys that this function can return are listed below. Not all platforms support all of these attributes; if an attribute is not supported, its association will not appear in the returned alist. Values that are numbers can be either integer or floating point, depending on the magnitude of the value.

euid
The effective user ID of the user who invoked the process. The corresponding value is a number. If the process was invoked by the same user who runs the current Emacs session, the value is identical to what user-uid returns (see User Identification).
user
User name corresponding to the process's effective user ID, a string.
egid
The group ID of the effective user ID, a number.
group
Group name corresponding to the effective user's group ID, a string.
comm
The name of the command that runs in the process. This is a string that usually specifies the name of the executable file of the process, without the leading directories. However, some special system processes can report strings that do not correspond to an executable file of a program.
state
The state code of the process. This is a short string that encodes the scheduling state of the process. Here's a list of the most frequently seen codes:
"D"
uninterruptible sleep (usually I/O)
"R"
running
"S"
interruptible sleep (waiting for some event)
"T"
stopped, e.g., by a job control signal
"Z"
zombie: a process that terminated, but was not reaped by its parent
For the full list of the possible states, see the manual page of the ps command.

ppid
The process ID of the parent process, a number.
pgrp
The process group ID of the process, a number.
sess
The session ID of the process. This is a number that is the process ID of the process's session leader.
ttname
A string that is the name of the process's controlling terminal. On Unix and GNU systems, this is normally the file name of the corresponding terminal device, such as /dev/pts65.
tpgid
The numerical process group ID of the foreground process group that uses the process's terminal.
minflt
The number of minor page faults caused by the process since its beginning. (Minor page faults are those that don't involve reading from disk.)
majflt
The number of major page faults caused by the process since its beginning. (Major page faults require a disk to be read, and are thus more expensive than minor page faults.)
cminflt
cmajflt
Like minflt and majflt, but include the number of page faults for all the child processes of the given process.
utime
Time spent by the process in the user context, for running the application's code. The corresponding value is in the (high low microsec picosec) format, the same format used by functions current-time (see current-time) and file-attributes (see File Attributes).
stime
Time spent by the process in the system (kernel) context, for processing system calls. The corresponding value is in the same format as for utime.
time
The sum of utime and stime. The corresponding value is in the same format as for utime.
cutime
cstime
ctime
Like utime, stime, and time, but include the times of all the child processes of the given process.
pri
The numerical priority of the process.
nice
The nice value of the process, a number. (Processes with smaller nice values get scheduled more favorably.)
thcount
The number of threads in the process.
start
The time when the process was started, in the same (high low microsec picosec) format used by file-attributes and current-time.
etime
The time elapsed since the process started, in the format (high low microsec picosec).
vsize
The virtual memory size of the process, measured in kilobytes.
rss
The size of the process's resident set, the number of kilobytes occupied by the process in the machine's physical memory.
pcpu
The percentage of the CPU time used by the process since it started. The corresponding value is a floating-point number between 0 and 100.
pmem
The percentage of the total physical memory installed on the machine used by the process's resident set. The value is a floating-point number between 0 and 100.
args
The command-line with which the process was invoked. This is a string in which individual command-line arguments are separated by blanks; whitespace characters that are embedded in the arguments are quoted as appropriate for the system's shell: escaped by backslash characters on GNU and Unix, and enclosed in double quote characters on Windows. Thus, this command-line string can be directly used in primitives such as shell-command.


** 13.Transaction Queues: Transaction-based communication with subprocesses.
You can use a transaction queue to communicate with a subprocess using transactions. First use tq-create to create a transaction queue communicating with a specified process. Then you can call tq-enqueue to send a transaction.

— Function: tq-create process
This function creates and returns a transaction queue communicating with process. The argument process should be a subprocess capable of sending and receiving streams of bytes. It may be a child process, or it may be a TCP connection to a server, possibly on another machine.

— Function: tq-enqueue queue question regexp closure fn &optional delay-question
This function sends a transaction to queue queue. Specifying the queue has the effect of specifying the subprocess to talk to.

The argument question is the outgoing message that starts the transaction. The argument fn is the function to call when the corresponding answer comes back; it is called with two arguments: closure, and the answer received.

The argument regexp is a regular expression that should match text at the end of the entire answer, but nothing before; that's how tq-enqueue determines where the answer ends.

If the argument delay-question is non-nil, delay sending this question until the process has finished replying to any previous questions. This produces more reliable results with some processes.

— Function: tq-close queue
Shut down transaction queue queue, waiting for all pending transactions to complete, and then terminate the connection or child process.

Transaction queues are implemented by means of a filter function. See Filter Functions.

** 14.Network: Opening network connections.
Emacs Lisp programs can open stream (TCP) and datagram (UDP) network connections (see Datagrams) to other processes on the same machine or other machines. A network connection is handled by Lisp much like a subprocess, and is represented by a process object. However, the process you are communicating with is not a child of the Emacs process, has no process ID, and you can't kill it or send it signals. All you can do is send and receive data. delete-process closes the connection, but does not kill the program at the other end; that program must decide what to do about closure of the connection.

Lisp programs can listen for connections by creating network servers. A network server is also represented by a kind of process object, but unlike a network connection, the network server never transfers data itself. When it receives a connection request, it creates a new network connection to represent the connection just made. (The network connection inherits certain information, including the process plist, from the server.) The network server then goes back to listening for more connection requests.

Network connections and servers are created by calling make-network-process with an argument list consisting of keyword/argument pairs, for example :server t to create a server process, or :type 'datagram to create a datagram connection. See Low-Level Network, for details. You can also use the open-network-stream function described below.

To distinguish the different types of processes, the process-type function returns the symbol network for a network connection or server, serial for a serial port connection, pipe for a pipe connection, or real for a real subprocess.

The process-status function returns open, closed, connect, stop, or failed for network connections. For a network server, the status is always listen. Except for stop, none of those values is possible for a real subprocess. See Process Information.

You can stop and resume operation of a network process by calling stop-process and continue-process. For a server process, being stopped means not accepting new connections. (Up to 5 connection requests will be queued for when you resume the server; you can increase this limit, unless it is imposed by the operating system—see the :server keyword of make-network-process, Network Processes.) For a network stream connection, being stopped means not processing input (any arriving input waits until you resume the connection). For a datagram connection, some number of packets may be queued but input may be lost. You can use the function process-command to determine whether a network connection or server is stopped; a non-nil value means yes.

Emacs can create encrypted network connections, using either built-in or external support. The built-in support uses the GnuTLS Transport Layer Security Library; see the GnuTLS project page. If your Emacs was compiled with GnuTLS support, the function gnutls-available-p is defined and returns non-nil. For more details, see Overview. The external support uses the starttls.el library, which requires a helper utility such as gnutls-cli to be installed on the system. The open-network-stream function can transparently handle the details of creating encrypted connections for you, using whatever support is available.

— Function: open-network-stream name buffer host service &rest parameters
This function opens a TCP connection, with optional encryption, and returns a process object that represents the connection.

The name argument specifies the name for the process object. It is modified as necessary to make it unique.

The buffer argument is the buffer to associate with the connection. Output from the connection is inserted in the buffer, unless you specify your own filter function to handle the output. If buffer is nil, it means that the connection is not associated with any buffer.

The arguments host and service specify where to connect to; host is the host name (a string), and service is the name of a defined network service (a string) or a port number (an integer like 80 or an integer string like "80").

The remaining arguments parameters are keyword/argument pairs that are mainly relevant to encrypted connections:

:nowait boolean
If non-nil, try to make an asynchronous connection.
:type type
The type of connection. Options are:
plain
An ordinary, unencrypted connection.
tls
ssl
A TLS (Transport Layer Security) connection.
nil
network
Start with a plain connection, and if parameters ‘:success’ and ‘:capability-command’ are supplied, try to upgrade to an encrypted connection via STARTTLS. If that fails, retain the unencrypted connection.
starttls
As for nil, but if STARTTLS fails drop the connection.
shell
A shell connection.

:always-query-capabilities boolean
If non-nil, always ask for the server's capabilities, even when doing a ‘plain’ connection.
:capability-command capability-command
Command string to query the host capabilities.
:end-of-command regexp
:end-of-capability regexp
Regular expression matching the end of a command, or the end of the command capability-command. The latter defaults to the former.
:starttls-function function
Function of one argument (the response to capability-command), which returns either nil, or the command to activate STARTTLS if supported.
:success regexp
Regular expression matching a successful STARTTLS negotiation.
:use-starttls-if-possible boolean
If non-nil, do opportunistic STARTTLS upgrades even if Emacs doesn't have built-in TLS support.
:warn-unless-encrypted boolean
If non-nil, and :return-value is also non-nil, Emacs will warn if the connection isn't encrypted. This is useful for protocols like IMAP and the like, where most users would expect the network traffic to be encrypted.
:client-certificate list-or-t
Either a list of the form (key-file cert-file), naming the certificate key file and certificate file itself, or t, meaning to query auth-source for this information (see Overview). Only used for TLS or STARTTLS.
:return-list cons-or-nil
The return value of this function. If omitted or nil, return a process object. Otherwise, a cons of the form (process-object . plist), where plist has keywords:
:greeting string-or-nil
If non-nil, the greeting string returned by the host.
:capabilities string-or-nil
If non-nil, the host's capability string.
:type symbol
The connection type: ‘plain’ or ‘tls’.

:shell-command string-or-nil
If the connection type is shell, this parameter will be interpreted as a format-spec string that will be executed to make the connection. The specs available are ‘%s’ for the host name and ‘%p’ for the port number. For instance, if you want to first ssh to ‘gateway’ before making a plain connection, then this parameter could be something like ‘ssh gateway nc %s %p’.

** 15.Network Servers: Network servers let Emacs accept net connections.
You create a server by calling make-network-process (see Network Processes) with :server t. The server will listen for connection requests from clients. When it accepts a client connection request, that creates a new network connection, itself a process object, with the following parameters:

The connection's process name is constructed by concatenating the server process's name with a client identification string. The client identification string for an IPv4 connection looks like ‘<a.b.c.d:p>’, which represents an address and port number. Otherwise, it is a unique number in brackets, as in ‘<nnn>’. The number is unique for each connection in the Emacs session.
If the server has a non-default filter, the connection process does not get a separate process buffer; otherwise, Emacs creates a new buffer for the purpose. The buffer name is the server's buffer name or process name, concatenated with the client identification string.
The server's process buffer value is never used directly, but the log function can retrieve it and use it to log connections by inserting text there.

The communication type and the process filter and sentinel are inherited from those of the server. The server never directly uses its filter and sentinel; their sole purpose is to initialize connections made to the server.
The connection's process contact information is set according to the client's addressing information (typically an IP address and a port number). This information is associated with the process-contact keywords :host, :service, :remote.
The connection's local address is set up according to the port number used for the connection.
The client process's plist is initialized from the server's plist.

** 16.Datagrams: UDP network connections.
A datagram connection communicates with individual packets rather than streams of data. Each call to process-send sends one datagram packet (see Input to Processes), and each datagram received results in one call to the filter function.

The datagram connection doesn't have to talk with the same remote peer all the time. It has a remote peer address which specifies where to send datagrams to. Each time an incoming datagram is passed to the filter function, the peer address is set to the address that datagram came from; that way, if the filter function sends a datagram, it will go back to that place. You can specify the remote peer address when you create the datagram connection using the :remote keyword. You can change it later on by calling set-process-datagram-address.

— Function: process-datagram-address process
If process is a datagram connection or server, this function returns its remote peer address.

— Function: set-process-datagram-address process address
If process is a datagram connection or server, this function sets its remote peer address to address.

** 17.Low-Level Network: Lower-level but more general function to create connections and servers.
You can also create network connections by operating at a lower level than that of open-network-stream, using make-network-process.

1. Proc: Using make-network-process.
2. Options: Further control over network connections.
3. Features Determining which network features work on the machine you are using.

** 18.Misc Network: Additional relevant functions for net connections.
These additional functions are useful for creating and operating on network connections. Note that they are supported only on some systems.

— Function: network-interface-list
This function returns a list describing the network interfaces of the machine you are using. The value is an alist whose elements have the form (name . address). address has the same form as the local-address and remote-address arguments to make-network-process.

— Function: network-interface-info ifname
This function returns information about the network interface named ifname. The value is a list of the form (addr bcast netmask hwaddr flags).

addr
The Internet protocol address.
bcast
The broadcast address.
netmask
The network mask.
hwaddr
The layer 2 address (Ethernet MAC address, for instance).
flags
The current flags of the interface.
— Function: format-network-address address &optional omit-port
This function converts the Lisp representation of a network address to a string.

A five-element vector [a b c d p] represents an IPv4 address a.b.c.d and port number p. format-network-address converts that to the string "a.b.c.d:p".

A nine-element vector [a b c d e f g h p] represents an IPv6 address along with a port number. format-network-address converts that to the string "[a:b:c:d:e:f:g:h]:p".

If the vector does not include the port number, p, or if omit-port is non-nil, the result does not include the :p suffix.



** 19.Serial Ports: Communicating with serial ports.
Emacs can communicate with serial ports. For interactive use, M-x serial-term opens a terminal window. In a Lisp program, make-serial-process creates a process object.

The serial port can be configured at run-time, without having to close and re-open it. The function serial-process-configure lets you change the speed, bytesize, and other parameters. In a terminal window created by serial-term, you can click on the mode line for configuration.

A serial connection is represented by a process object, which can be used in a similar way to a subprocess or network process. You can send and receive data, and configure the serial port. A serial process object has no process ID, however, and you can't send signals to it, and the status codes are different from other types of processes. delete-process on the process object or kill-buffer on the process buffer close the connection, but this does not affect the device connected to the serial port.

The function process-type returns the symbol serial for a process object representing a serial port connection.

Serial ports are available on GNU/Linux, Unix, and MS Windows systems.

— Command: serial-term port speed
Start a terminal-emulator for a serial port in a new buffer. port is the name of the serial port to connect to. For example, this could be /dev/ttyS0 on Unix. On MS Windows, this could be COM1, or \\.\COM10 (double the backslashes in Lisp strings).
speed is the speed of the serial port in bits per second. 9600 is a common value. The buffer is in Term mode; see Term Mode, for the commands to use in that buffer. You can change the speed and the configuration in the mode line menu.

— Function: make-serial-process &rest args
This function creates a process and a buffer. Arguments are specified as keyword/argument pairs. Here's the list of the meaningful keywords, with the first two (port and speed) being mandatory:

:port port
This is the name of the serial port. On Unix and GNU systems, this is a file name such as /dev/ttyS0. On Windows, this could be COM1, or \\.\COM10 for ports higher than COM9 (double the backslashes in Lisp strings).
:speed speed
The speed of the serial port in bits per second. This function calls serial-process-configure to handle the speed; see the following documentation of that function for more details.
:name name
The name of the process. If name is not given, port will serve as the process name as well.
:buffer buffer
The buffer to associate with the process. The value can be either a buffer or a string that names a buffer. Process output goes at the end of that buffer, unless you specify an output stream or filter function to handle the output. If buffer is not given, the process buffer's name is taken from the value of the :name keyword.
:coding coding
If coding is a symbol, it specifies the coding system used for both reading and writing for this process. If coding is a cons (decoding . encoding), decoding is used for reading, and encoding is used for writing. If not specified, the default is to determine the coding systems from the data itself.
:noquery query-flag
Initialize the process query flag to query-flag. See Query Before Exit. The flags defaults to nil if unspecified.
:stop bool
Start process in the stopped state if bool is non-nil. In the stopped state, a serial process does not accept incoming data, but you can send outgoing data. The stopped state is cleared by continue-process and set by stop-process.
:filter filter
Install filter as the process filter.
:sentinel sentinel
Install sentinel as the process sentinel.
:plist plist
Install plist as the initial plist of the process.
:bytesize
:parity
:stopbits
:flowcontrol
These are handled by serial-process-configure, which is called by make-serial-process.
The original argument list, possibly modified by later configuration, is available via the function process-contact.

Here is an example:

          (make-serial-process :port "/dev/ttyS0" :speed 9600)
— Function: serial-process-configure &rest args
This function configures a serial port connection. Arguments are specified as keyword/argument pairs. Attributes that are not given are re-initialized from the process's current configuration (available via the function process-contact), or set to reasonable default values. The following arguments are defined:

:process process
:name name
:buffer buffer
:port port
Any of these arguments can be given to identify the process that is to be configured. If none of these arguments is given, the current buffer's process is used.
:speed speed
The speed of the serial port in bits per second, a.k.a. baud rate. The value can be any number, but most serial ports work only at a few defined values between 1200 and 115200, with 9600 being the most common value. If speed is nil, the function ignores all other arguments and does not configure the port. This may be useful for special serial ports such as Bluetooth-to-serial converters, which can only be configured through ‘AT’ commands sent through the connection. The value of nil for speed is valid only for connections that were already opened by a previous call to make-serial-process or serial-term.
:bytesize bytesize
The number of bits per byte, which can be 7 or 8. If bytesize is not given or nil, it defaults to 8.
:parity parity
The value can be nil (don't use parity), the symbol odd (use odd parity), or the symbol even (use even parity). If parity is not given, it defaults to no parity.
:stopbits stopbits
The number of stopbits used to terminate a transmission of each byte. stopbits can be 1 or 2. If stopbits is not given or nil, it defaults to 1.
:flowcontrol flowcontrol
The type of flow control to use for this connection, which is either nil (don't use flow control), the symbol hw (use RTS/CTS hardware flow control), or the symbol sw (use XON/XOFF software flow control). If flowcontrol is not given, it defaults to no flow control.
Internally, make-serial-process calls serial-process-configure for the initial configuration of the serial port.






** 20.Byte Packing: Using bindat to pack and unpack binary data.

This section describes how to pack and unpack arrays of bytes, usually for binary network protocols. These functions convert byte arrays to alists, and vice versa. The byte array can be represented as a unibyte string or as a vector of integers, while the alist associates symbols either with fixed-size objects or with recursive sub-alists. To use the functions referred to in this section, load the bindat library.
Conversion from byte arrays to nested alists is also known as deserializing or unpacking, while going in the opposite direction is also known as serializing or packing.

Bindat Spec: Describing data layout.
Bindat Functions: Doing the unpacking and packing.
Bindat Examples: Samples of what bindat.el can do for you!

* 39 Emacs Display
This chapter describes a number of features related to the display that Emacs presents to the user.

Refresh Screen: Clearing the screen and redrawing everything on it.
Forcing Redisplay: Forcing redisplay.
Truncation: Folding or wrapping long text lines.
The Echo Area: Displaying messages at the bottom of the screen.
Warnings: Displaying warning messages for the user.
Invisible Text: Hiding part of the buffer text.
Selective Display: Hiding part of the buffer text (the old way).
Temporary Displays: Displays that go away automatically.
Overlays: Use overlays to highlight parts of the buffer.
Size of Displayed Text: How large displayed text is.
Line Height: Controlling the height of lines.
Faces: A face defines a graphics style for text characters: font, colors, etc.
Fringes: Controlling window fringes.
Scroll Bars: Controlling scroll bars.
Window Dividers: Separating windows visually.
Display Property: Enabling special display features.
Images: Displaying images in Emacs buffers.
Xwidgets: Displaying native widgets in Emacs buffers.
Buttons: Adding clickable buttons to Emacs buffers.
Abstract Display: Emacs's Widget for Object Collections.
Blinking: How Emacs shows the matching open parenthesis.
Character Display: How Emacs displays individual characters.
Beeping: Audible signal to the user.
Window Systems: Which window system is being used.
Tooltips: Tooltip display in Emacs.
Bidirectional Display: Display of bidirectional scripts, such as Arabic and Farsi.



* 40 Operating System Interface
This chapter is about starting and getting out of Emacs, access to values in the operating system environment, and terminal input, output.

See Building Emacs, for related information. See Display, for additional operating system status information pertaining to the terminal and the screen.

1) Starting Up: Customizing Emacs startup processing.
2) Getting Out: How exiting works (permanent or temporary).
3) System Environment: Distinguish the name and kind of system.
4) User Identification: Finding the name and user id of the user.
5) Time of Day: Getting the current time.
6) Time Zone Rules: Rules for time zones and daylight saving time.
7) Time Conversion: Converting a time from numeric form to calendrical data and vice versa.
8) Time Parsing: Converting a time from numeric form to text and vice versa.
9) Processor Run Time: Getting the run time used by Emacs.
10) Time Calculations: Adding, subtracting, comparing times, etc.
11) Timers: Setting a timer to call a function at a certain time.
12) Idle Timers: Setting a timer to call a function when Emacs has been idle for a certain length of time.
13) Terminal Input: Accessing and recording terminal input.
14) Terminal Output: Controlling and recording terminal output.
15) Sound Output: Playing sounds on the computer's speaker.
16) X11 Keysyms: Operating on key symbols for X Windows.
17) Batch Mode: Running Emacs without terminal interaction.
18) Session Management: Saving and restoring state with X Session Management.
19) Desktop Notifications: Desktop notifications.
20) File Notifications: File notifications.
21) Dynamic Libraries: On-demand loading of support libraries.
22) Security Considerations: Running Emacs in an unfriendly environment.

* 41 Preparing Lisp code for distribution
Emacs provides a standard way to distribute Emacs Lisp code to users. A package is a collection of one or more files, formatted and bundled in such a way that users can easily download, install, uninstall, and upgrade it.

The following sections describe how to create a package, and how to put it in a package archive for others to download. See Packages, for a description of user-level features of the packaging system.

Packaging Basics: The basic concepts of Emacs Lisp packages.
Simple Packages: How to package a single .el file.
Multi-file Packages: How to package multiple files.
Package Archives: Maintaining package archives.


* Questions Raised
** Load Path
: (add-to-list 'load-path "~/.emacs.d/lisp/")
https://www.emacswiki.org/emacs/LoadPath

* Lexical Binding
- https://www.emacswiki.org/emacs/LexicalBindi
