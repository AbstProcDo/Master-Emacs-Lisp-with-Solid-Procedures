#+TITLE: 05.List
* 5 Lists
   :PROPERTIES:
   :CUSTOM_ID: lists
   :END:

A list represents a sequence of zero or more elements (which may be any Lisp objects). The important difference between lists and vectors is that two or more lists can share part of their structure; in addition, you can insert or delete elements in a list without copying the whole list.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cells][Cons Cells]]: How lists are made out of cons cells.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][List-related Predicates]]: Is this object a list? Comparing two lists.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List-Elements][List Elements]]: Extracting the pieces of a list.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Building-Lists][Building Lists]]: Creating list structure.
5) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List-Variables][List Variables]]: Modifying lists stored in variables.
6) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Modifying-Lists][Modifying Lists]]: Storing new pieces into an existing list.
7) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sets-And-Lists][Sets And Lists]]: A list can represent a finite mathematical set.
8) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Association-Lists][Association Lists]]: A list can represent a finite relation or mapping.
9) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Lists][Property Lists]]: A list of paired elements.

* 5.1 Lists and Cons Cells
    :PROPERTIES:
    :CUSTOM_ID: lists-and-cons-cells
    :END:

Lists in Lisp are not a primitive data type; they are built up from cons cells (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cell-Type][2.3.6 Cons Cell Type]]). A cons cell is a data object that represents an ordered pair. That is, it has two slots, and each slot holds, or refers to, some Lisp object. One slot is known as the car, and the other is known as the cdr. (These names are traditional; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cell-Type][2.3.6 Cons Cell Type]].) cdr is pronounced "could-er".

We say that "the car of this cons cell is" whatever object its car slot currently holds, and likewise for the cdr.

A list is a series of cons cells chained together, so that each cell refers to the next one. There is one cons cell for each element of the list. By convention, the cars of the cons cells hold the elements of the list, and the cdrs are used to chain the list (this asymmetry between car and cdr is entirely a matter of convention; at the level of cons cells, the car and cdr slots have similar properties). Hence, the cdr slot of each cons cell in a list refers to the following cons cell.

Also by convention, the cdr of the last cons cell in a list is =nil=. We call such a =nil-terminated= structure a proper list[[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#fn-2][2]]. In Emacs Lisp, the symbol =nil= is both a symbol and a list with no elements. For convenience, the symbol =nil= is considered to have =nil= as its cdr (and also as its car).

Hence, the cdr of a proper list is always a proper list. The cdr of a nonempty proper list is a proper list containing all the elements except the first.

If the cdr of a list's last cons cell is some value other than =nil=, we call the structure a dotted list, since its printed representation would use dotted pair notation (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dotted-Pair-Notation][2.3.6.2 Dotted Pair Notation]]). There is one other possibility: some cons cell's cdr could point to one of the previous cons cells in the list. We call that structure a circular list.

For some purposes, it does not matter whether a list is proper, circular or dotted. If a program doesn't look far enough down the list to see the cdr of the final cons cell, it won't care. However, some functions that operate on lists demand proper lists and signal errors if given a dotted list. Most functions that try to find the end of a list enter infinite loops if given a circular list.

Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a list structure.

* 5.2 Predicates on Lists
    :PROPERTIES:
    :CUSTOM_ID: predicates-on-lists
    :END:

The following predicates test whether a Lisp object is an atom, whether it is a cons cell or is a list, or whether it is the distinguished object =nil=. (Many of these predicates can be defined in terms of the others, but they are used so often that it is worth having them.)

--- Function: *consp* object


  This function returns =t= if object is a cons cell, =nil= otherwise. =nil= is not a cons cell, although it /is/ a list.


--- Function: *atom* object

# 短评: 有意思, 此处没有predicate 
  This function returns =t= if object is an atom, =nil= otherwise. All objects except cons cells are atoms. The symbol =nil= is an atom and is also a list; it is the only Lisp object that is both.

  #+begin_src elisp
                (atom object) == (not (consp object))
  #+end_src


--- Function: *listp* object


  This function returns =t= if object is a cons cell or =nil=. Otherwise, it returns =nil=.

  #+begin_src elisp
                (listp '(1))
                     ⇒ t
                (listp '())
                     ⇒ t
  #+end_src


--- Function: *nlistp* object


  This function is the opposite of =listp=: it returns =t= if object is not a list. Otherwise, it returns =nil=.

  #+begin_src elisp
                (listp object) == (not (nlistp object))
  #+end_src


--- Function: *null* object


  This function returns =t= if object is =nil=, and returns =nil= otherwise. This function is identical to =not=, but as a matter of clarity we use =null= when object is considered a list and =not= when it is considered a truth value (see =not= in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Combining-Conditions][Combining Conditions]]).

  #+begin_src elisp
                (null '(1))
                     ⇒ nil
                (null '())
                     ⇒ t
  #+end_src


* 5.3 Accessing Elements of Lists
    :PROPERTIES:
    :CUSTOM_ID: accessing-elements-of-lists
    :END:

--- Function: *car* cons-cell


  This function returns the value referred to by the first slot of the cons cell cons-cell. In other words, it returns the car of cons-cell.

  As a special case, if cons-cell is =nil=, this function returns =nil=. Therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or =nil=.

  #+begin_src elisp
                (car '(a b c))
                     ⇒ a
                (car '())
                     ⇒ nil
  #+end_src


--- Function: *cdr* cons-cell


  This function returns the value referred to by the second slot of the cons cell cons-cell. In other words, it returns the cdr of cons-cell.

  As a special case, if cons-cell is =nil=, this function returns =nil=; therefore, any list is a valid argument. An error is signaled if the argument is not a cons cell or =nil=.

  #+begin_src elisp
                (cdr '(a b c))
                     ⇒ (b c)
                (cdr '())
                     ⇒ nil
  #+end_src


--- Function: *car-safe* object


  This function lets you take the car of a cons cell while avoiding errors for other data types. It returns the car of object if object is a cons cell, =nil= otherwise. This is in contrast to =car=, which signals an error if object is not a list.

  #+begin_src elisp
                (car-safe object)
                ==
                (let ((x object))
                  (if (consp x)
                      (car x)
                    nil))
  #+end_src


--- Function: *cdr-safe* object


  This function lets you take the cdr of a cons cell while avoiding errors for other data types. It returns the cdr of object if object is a cons cell, =nil= otherwise. This is in contrast to =cdr=, which signals an error if object is not a list.

  #+begin_src elisp
                (cdr-safe object)
                ==
                (let ((x object))
                  (if (consp x)
                      (cdr x)
                    nil))
  #+end_src


--- Macro: *pop* listname


  This macro provides a convenient way to examine the car of a list, and take it off the list, all at once. It operates on the list stored in listname. It removes the first element from the list, saves the cdr into listname, then returns the removed element.

  In the simplest case, listname is an unquoted symbol naming a list; in that case, this macro is equivalent to =(prog1 (car listname) (setq listname (cdr listname)))=.

  #+begin_src elisp
                x
                     ⇒ (a b c)
                (pop x)
                     ⇒ a
                x
                     ⇒ (b c)
  #+end_src

  More generally, listname can be a generalized variable. In that case, this macro saves into listname using =setf=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Generalized-Variables][Generalized Variables]].

  For the =push= macro, which adds an element to a list, See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List-Variables][List Variables]].


--- Function: *nth* n list


  This function returns the nth element of list. Elements are numbered starting with zero, so the car of list is element number zero. If the length of list is n or less, the value is =nil=.

  #+begin_src elisp
                (nth 2 '(1 2 3 4))
                     ⇒ 3
                (nth 10 '(1 2 3 4))
                     ⇒ nil

                (nth n x) == (car (nthcdr n x))
  #+end_src

  The function =elt= is similar, but applies to any kind of sequence. For historical reasons, it takes its arguments in the opposite order. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequence-Functions][Sequence Functions]].


--- Function: *nthcdr* n list


  This function returns the nth cdr of list. In other words, it skips past the first n links of list and returns what follows.

  If n is zero, =nthcdr= returns all of list. If the length of list is n or less, =nthcdr= returns =nil=.

  #+begin_src elisp
                (nthcdr 1 '(1 2 3 4))
                     ⇒ (2 3 4)
                (nthcdr 10 '(1 2 3 4))
                     ⇒ nil
                (nthcdr 0 '(1 2 3 4))
                     ⇒ (1 2 3 4)
  #+end_src


--- Function: *last* list &optional n


  This function returns the last link of list. The =car= of this link is the list's last element. If list is null, =nil= is returned. If n is non-=nil=, the nth-to-last link is returned instead, or the whole of list if n is bigger than list's length.


--- Function: *safe-length* list


  This function returns the length of list, with no risk of either an error or an infinite loop. It generally returns the number of distinct cons cells in the list. However, for circular lists, the value is just an upper bound; it is often too large.

  If list is not =nil= or a cons cell, =safe-length= returns 0.


The most common way to compute the length of a list, when you are not worried that it may be circular, is with =length=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequence-Functions][Sequence Functions]].

--- Function: *caar* cons-cell


  This is the same as =(car (car=cons-cell=))=.


--- Function: *cadr* cons-cell


  This is the same as =(car (cdr=cons-cell=))= or =(nth 1=cons-cell=)=.


--- Function: *cdar* cons-cell


  This is the same as =(cdr (car=cons-cell=))=.


--- Function: *cddr* cons-cell


  This is the same as =(cdr (cdr=cons-cell=))= or =(nthcdr 2=cons-cell=)=.


In addition to the above, 24 additional compositions of =car= and =cdr= are defined as =c=xxx=r= and =c=xxxx=r=, where each x is either =a= or =d=. =cadr=, =caddr=, and =cadddr= pick out the second, third or fourth elements of a list, respectively. cl-lib provides the same under the names =cl-second=, =cl-third=, and =cl-fourth=. See [[https://www.gnu.org/software/emacs/manual/html_mono/cl.html#List-Functions][List Functions]].
# 短评: 这些都没有什么意思.
--- Function: *butlast* x &optional n


  This function returns the list x with the last element, or the last n elements, removed. If n is greater than zero it makes a copy of the list so as not to damage the original list. In general, =(append (butlast=x n=) (last=x n=))= will return a list equal to x.


--- Function: *nbutlast* x &optional n


  This is a version of =butlast= that works by destructively modifying the =cdr= of the appropriate element, rather than making a copy of the list.

* 5.4 Building Cons Cells and Lists
    :PROPERTIES:
    :CUSTOM_ID: building-cons-cells-and-lists
    :END:

Many functions build lists, as lists reside at the very heart of Lisp. =cons= is the fundamental list-building function; however, it is interesting to note that =list= is used more times in the source code for Emacs than =cons=.

--- Function: *cons* object1 object2


  This function is the most basic function for building new list structure. It creates a new cons cell, making object1 the car, and object2 the cdr. It then returns the new cons cell. The arguments object1 and object2 may be any Lisp objects, but most often object2 is a list.

  #+begin_src elisp
                (cons 1 '(2))
                     ⇒ (1 2)
                (cons 1 '())
                     ⇒ (1)
                (cons 1 2)
                     ⇒ (1 . 2)
  #+end_src

  =cons= is often used to add a single element to the front of a list. This is called consing the element onto the list. [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#fn-3][3]] For example:

  #+begin_src elisp
                (setq list (cons newelt list))
  #+end_src

  Note that there is no conflict between the variable named =list= used in this example and the function named =list= described below; any symbol can serve both purposes.


--- Function: *list* &rest objects


  This function creates a list with objects as its elements. The resulting list is always =nil=-terminated. If no objects are given, the empty list is returned.

  #+begin_src elisp
                (list 1 2 3 4 5)
                     ⇒ (1 2 3 4 5)
                (list 1 2 '(3 4 5) 'foo)
                     ⇒ (1 2 (3 4 5) foo)
                (list)
                     ⇒ nil
  #+end_src


--- Function: *make-list* length object


  This function creates a list of length elements, in which each element is object. Compare =make-list= with =make-string= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Strings][Creating Strings]]).

  #+begin_src elisp
                (make-list 3 'pigs)
                     ⇒ (pigs pigs pigs)
                (make-list 0 'pigs)
                     ⇒ nil
                (setq l (make-list 3 '(a b)))
                     ⇒ ((a b) (a b) (a b))
                (eq (car l) (cadr l))
                     ⇒ t
  #+end_src


--- Function: *append* &rest sequences


  This function returns a list containing all the elements of sequences. The sequences may be lists, vectors, bool-vectors, or strings, but the last one should usually be a list. All arguments except the last one are copied, so none of the arguments is altered. (See =nconc= in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Rearrangement][Rearrangement]], for a way to join lists with no copying.)

  More generally, the final argument to =append= may be any Lisp object. The final argument is not copied or converted; it becomes the cdr of the last cons cell in the new list. If the final argument is itself a list, then its elements become in effect elements of the result list. If the final element is not a list, the result is a dotted list since its final cdr is not =nil= as required in a proper list (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cells][Cons Cells]]).


Here is an example of using =append=:

#+begin_src elisp
         (setq trees '(pine oak))
              ⇒ (pine oak)
         (setq more-trees (append '(maple birch) trees))
              ⇒ (maple birch pine oak)

         trees
              ⇒ (pine oak)
         more-trees
              ⇒ (maple birch pine oak)
         (eq trees (cdr (cdr more-trees)))
              ⇒ t
#+end_src

You can see how =append= works by looking at a box diagram. The variable =trees= is set to the list =(pine oak)= and then the variable =more-trees= is set to the list =(maple birch pine oak)=. However, the variable =trees= continues to refer to the original list:

#+begin_src elisp
         more-trees                trees
         |                           |
         |     --- ---      --- ---   -> --- ---      --- ---
          --> |   |   |--> |   |   |--> |   |   |--> |   |   |--> nil
               --- ---      --- ---      --- ---      --- ---
                |            |            |            |
                |            |            |            |
                 --> maple    -->birch     --> pine     --> oak
#+end_src

An empty sequence contributes nothing to the value returned by =append=. As a consequence of this, a final =nil= argument forces a copy of the previous argument:

#+begin_src elisp
         trees
              ⇒ (pine oak)
         (setq wood (append trees nil))
              ⇒ (pine oak)
         wood
              ⇒ (pine oak)
         (eq wood trees)
              ⇒ nil
#+end_src

This once was the usual way to copy a list, before the function =copy-sequence= was invented. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequences-Arrays-Vectors][Sequences Arrays Vectors]].

Here we show the use of vectors and strings as arguments to =append=:

#+begin_src elisp
         (append [a b] "cd" nil)
              ⇒ (a b 99 100)
#+end_src

With the help of =apply= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Calling-Functions][Calling Functions]]), we can append all the lists in a list of lists:

#+begin_src elisp
         (apply 'append '((a b c) nil (x y z) nil))
              ⇒ (a b c x y z)
#+end_src

If no sequences are given, =nil= is returned:

#+begin_src elisp
         (append)
              ⇒ nil
#+end_src

Here are some examples where the final argument is not a list:

#+begin_src elisp
         (append '(x y) 'z)
              ⇒ (x y . z)
         (append '(x y) [z])
              ⇒ (x y . [z])
#+end_src

The second example shows that when the final argument is a sequence but not a list, the sequence's elements do not become elements of the resulting list. Instead, the sequence becomes the final cdr, like any other non-list final argument.

--- Function: *copy-tree* tree &optional vecp


  This function returns a copy of the tree tree. If tree is a cons cell, this makes a new cons cell with the same car and cdr, then recursively copies the car and cdr in the same way.

  Normally, when tree is anything other than a cons cell, =copy-tree= simply returns tree. However, if vecp is non-=nil=, it copies vectors too (and operates recursively on their elements).


--- Function: *number-sequence* from &optional to separation


  This returns a list of numbers starting with from and incrementing by separation, and ending at or just before to. separation can be positive or negative and defaults to 1. If to is =nil= or numerically equal to from, the value is the one-element list =(=from=)=. If to is less than from with a positive separation, or greater than from with a negative separation, the value is =nil= because those arguments specify an empty sequence.

  If separation is 0 and to is neither =nil= nor numerically equal to from, =number-sequence= signals an error, since those arguments specify an infinite sequence.

  All arguments are numbers. Floating-point arguments can be tricky, because floating-point arithmetic is inexact. For instance, depending on the machine, it may quite well happen that =(number-sequence 0.4 0.6 0.2)= returns the one element list =(0.4)=, whereas =(number-sequence 0.4 0.8 0.2)= returns a list with three elements. The nth element of the list is computed by the exact formula =(+=from=(*=n separation=))=. Thus, if one wants to make sure that to is included in the list, one can pass an expression of this exact type for to. Alternatively, one can replace to with a slightly larger value (or a slightly more negative value if separation is negative).

  Some examples:

  #+begin_src elisp
(number-sequence 4 9)
⇒ (4 5 6 7 8 9)
(number-sequence 9 4 -1)
⇒ (9 8 7 6 5 4)
(number-sequence 9 4 -2)
⇒ (9 7 5)
(number-sequence 8)
⇒ (8)
(number-sequence 8 5)
⇒ nil
(number-sequence 5 8 -1)
⇒ nil
(number-sequence 1.5 6 2)
⇒ (1.5 3.5 5.5)
  #+end_src

* 5.5 Modifying List Variables
    :PROPERTIES:
    :CUSTOM_ID: modifying-list-variables
    :END:

These functions, and one macro, provide convenient ways to modify a list which is stored in a variable.

--- Macro: *push* element listname


  This macro creates a new list whose car is element and whose cdr is the list specified by listname, and saves that list in listname. In the simplest case, listname is an unquoted symbol naming a list, and this macro is equivalent to =(setq=listname=(cons=element==listname=))=.

  #+begin_src elisp
                (setq l '(a b))
                     ⇒ (a b)
                (push 'c l)
                     ⇒ (c a b)
                l
                     ⇒ (c a b)
  #+end_src

  More generally, =listname= can be a generalized variable. In that case, this macro does the equivalent of =(setf=listname=(cons=element==listname=))=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Generalized-Variables][Generalized Variables]].

  For the =pop= macro, which removes the first element from a list, See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List-Elements][List Elements]].


Two functions modify lists that are the values of variables.

--- Function: *add-to-list* symbol element &optional append compare-fn


  This function sets the variable symbol by consing element onto the old value, if element is not already a member of that value. It returns the resulting list, whether updated or not. The value of symbol had better be a list already before the call. =add-to-list= uses compare-fn to compare element against existing list members; if compare-fn is =nil=, it uses =equal=.

  Normally, if element is added, it is added to the front of symbol, but if the optional argument append is non-=nil=, it is added at the end.

  The argument symbol is not implicitly quoted; =add-to-list= is an ordinary function, like =set= and unlike =setq=. Quote the argument yourself if that is what you want.


Here's a scenario showing how to use =add-to-list=:

#+begin_src elisp
         (setq foo '(a b))
              ⇒ (a b)

         (add-to-list 'foo 'c)     ;; Add c.
              ⇒ (c a b)

         (add-to-list 'foo 'b)     ;; No effect.
              ⇒ (c a b)

         foo                       ;; foo was changed.
              ⇒ (c a b)
#+end_src

An equivalent expression for =(add-to-list '=var value=)= is this:

#+begin_src elisp
         (or (member value var)
             (setq var (cons value var)))
#+end_src

--- Function: *add-to-ordered-list* symbol element &optional order


  This function sets the variable symbol by inserting element into the old value, which must be a list, at the position specified by order. If element is already a member of the list, its position in the list is adjusted according to order. Membership is tested using =eq=. This function returns the resulting list, whether updated or not.

  The order is typically a number (integer or float), and the elements of the list are sorted in non-decreasing numerical order.

  order may also be omitted or =nil=. Then the numeric order of element stays unchanged if it already has one; otherwise, element has no numeric order. Elements without a numeric list order are placed at the end of the list, in no particular order.

  Any other value for order removes the numeric order of element if it already has one; otherwise, it is equivalent to =nil=.

  The argument symbol is not implicitly quoted; =add-to-ordered-list= is an ordinary function, like =set= and unlike =setq=. Quote the argument yourself if necessary.

  The ordering information is stored in a hash table on symbol's =list-order= property.


Here's a scenario showing how to use =add-to-ordered-list=:

#+begin_src elisp
         (setq foo '())
              ⇒ nil

         (add-to-ordered-list 'foo 'a 1)     ;; Add a.
              ⇒ (a)

         (add-to-ordered-list 'foo 'c 3)     ;; Add c.
              ⇒ (a c)

         (add-to-ordered-list 'foo 'b 2)     ;; Add b.
              ⇒ (a b c)

         (add-to-ordered-list 'foo 'b 4)     ;; Move b.
              ⇒ (a c b)

         (add-to-ordered-list 'foo 'd)       ;; Append d.
              ⇒ (a c b d)

         (add-to-ordered-list 'foo 'e)       ;; Add e.
              ⇒ (a c b e d)

         foo                       ;; foo was changed.
              ⇒ (a c b e d)
#+end_src

* 5.6 Modifying Existing List Structure
    :PROPERTIES:
    :CUSTOM_ID: modifying-existing-list-structure
    :END:

You can modify the car and cdr contents of a cons cell with the primitives =setcar= and =setcdr=. These are destructive operations because they change existing list structure.


  *Common Lisp note:* Common Lisp uses functions =rplaca= and =rplacd= to alter list structure; they change structure the same way as =setcar= and =setcdr=, but the Common Lisp functions return the cons cell while =setcar= and =setcdr= return the new car or cdr.


1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Setcar][Setcar]]: Replacing an element in a list.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Setcdr][Setcdr]]: Replacing part of the list backbone. This can be used to remove or add elements.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Rearrangement][Rearrangement]]: Reordering the elements in a list; combining lists.


** 5.6.1 Altering List Elements with =setcar=
     :PROPERTIES:
     :CUSTOM_ID: altering-list-elements-with-setcar
     :END:

Changing the car of a cons cell is done with =setcar=. When used on a list, =setcar= replaces one element of a list with a different element.

--- Function: *setcar* cons object


  This function stores object as the new car of cons, replacing its previous car. In other words, it changes the car slot of cons to refer to object. It returns the value object. For example:

  #+begin_src elisp
                (setq x '(1 2))
                     ⇒ (1 2)
                (setcar x 4)
                     ⇒ 4
                x
                     ⇒ (4 2)
  #+end_src


When a cons cell is part of the shared structure of several lists, storing a new car into the cons changes one element of each of these lists. Here is an example:

#+begin_src elisp
         ;; Create two lists that are partly shared.
         (setq x1 '(a b c))
              ⇒ (a b c)
         (setq x2 (cons 'z (cdr x1)))
              ⇒ (z b c)

         ;; Replace the car of a shared link.
         (setcar (cdr x1) 'foo)
              ⇒ foo
         x1                           ; Both lists are changed.
              ⇒ (a foo c)
         x2
              ⇒ (z foo c)

         ;; Replace the car of a link that is not shared.
         (setcar x1 'baz)
              ⇒ baz
         x1                           ; Only one list is changed.
              ⇒ (baz foo c)
         x2
              ⇒ (z foo c)
#+end_src

Here is a graphical depiction of the shared structure of the two lists in the variables =x1= and =x2=, showing why replacing =b= changes them both:

#+begin_src elisp
                 --- ---        --- ---      --- ---
         x1---> |   |   |----> |   |   |--> |   |   |--> nil
                 --- ---        --- ---      --- ---
                  |        -->   |            |
                  |       |      |            |
                   --> a  |       --> b        --> c
                          |
                --- ---   |
         x2--> |   |   |--
                --- ---
                 |
                 |
                  --> z
#+end_src

Here is an alternative form of box diagram, showing the same relationship:

#+begin_src elisp
         x1:
          --------------       --------------       --------------
         | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
         |   a   |   o------->|   b   |   o------->|   c   |  nil |
         |       |      |  -->|       |      |     |       |      |
          --------------  |    --------------       --------------
                          |
         x2:              |
          --------------  |
         | car   | cdr  | |
         |   z   |   o----
         |       |      |
          --------------
#+end_src


** 5.6.2 Altering the CDR of a List
     :PROPERTIES:
     :CUSTOM_ID: altering-the-cdr-of-a-list
     :END:

The lowest-level primitive for modifying a cdr is =setcdr=:

--- Function: *setcdr* cons object


  This function stores object as the new cdr of cons, replacing its previous cdr. In other words, it changes the cdr slot of cons to refer to object. It returns the value object.


Here is an example of replacing the cdr of a list with a different list. All but the first element of the list are removed in favor of a different sequence of elements. The first element is unchanged, because it resides in the car of the list, and is not reached via the cdr.

#+begin_src elisp
         (setq x '(1 2 3))
              ⇒ (1 2 3)
         (setcdr x '(4))
              ⇒ (4)
         x
              ⇒ (1 4)
#+end_src

You can delete elements from the middle of a list by altering the cdrs of the cons cells in the list. For example, here we delete the second element, =b=, from the list =(a b c)=, by changing the cdr of the first cons cell:

#+begin_src elisp
         (setq x1 '(a b c))
              ⇒ (a b c)
         (setcdr x1 (cdr (cdr x1)))
              ⇒ (c)
         x1
              ⇒ (a c)
#+end_src

Here is the result in box notation:

#+begin_src elisp
                            --------------------
                           |                    |
          --------------   |   --------------   |    --------------
         | car   | cdr  |  |  | car   | cdr  |   -->| car   | cdr  |
         |   a   |   o-----   |   b   |   o-------->|   c   |  nil |
         |       |      |     |       |      |      |       |      |
          --------------       --------------        --------------
#+end_src

The second cons cell, which previously held the element =b=, still exists and its car is still =b=, but it no longer forms part of this list.

It is equally easy to insert a new element by changing cdrs:

#+begin_src elisp
         (setq x1 '(a b c))
              ⇒ (a b c)
         (setcdr x1 (cons 'd (cdr x1)))
              ⇒ (d b c)
         x1
              ⇒ (a d b c)
#+end_src

Here is this result in box notation:

#+begin_src elisp
          --------------        -------------       -------------
         | car  | cdr   |      | car  | cdr  |     | car  | cdr  |
         |   a  |   o   |   -->|   b  |   o------->|   c  |  nil |
         |      |   |   |  |   |      |      |     |      |      |
          --------- | --   |    -------------       -------------
                    |      |
              -----         --------
             |                      |
             |    ---------------   |
             |   | car   | cdr   |  |
              -->|   d   |   o------
                 |       |       |
                  ---------------
#+end_src


** 5.6.3 Functions that Rearrange Lists
     :PROPERTIES:
     :CUSTOM_ID: functions-that-rearrange-lists
     :END:

Here are some functions that rearrange lists destructively by modifying the cdrs of their component cons cells. These functions are destructive because they chew up the original lists passed to them as arguments, relinking their cons cells to form a new list that is the returned value.

See =delq=, in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sets-And-Lists][Sets And Lists]], for another function that modifies cons cells.

--- Function: *nconc* &rest lists


  This function returns a list containing all the elements of lists. Unlike =append= (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Building-Lists][Building Lists]]), the lists are /not/ copied. Instead, the last cdr of each of the lists is changed to refer to the following list. The last of the lists is not altered. For example:

  #+begin_src elisp
(setq x '(1 2 3))
⇒ (1 2 3)
(nconc x '(4 5))
⇒ (1 2 3 4 5)
x
⇒ (1 2 3 4 5)
  #+end_src

  Since the last argument of =nconc= is not itself modified, it is reasonable to use a constant list, such as ='(4 5)=, as in the above example. For the same reason, the last argument need not be a list:

  #+begin_src elisp
                (setq x '(1 2 3))
                     ⇒ (1 2 3)
                (nconc x 'z)
                     ⇒ (1 2 3 . z)
                x
                     ⇒ (1 2 3 . z)
  #+end_src

  However, the other arguments (all but the last) must be lists.

  A common pitfall is to use a quoted constant list as a non-last argument to =nconc=. If you do this, your program will change each time you run it! Here is what happens:

  #+begin_src elisp
                (defun add-foo (x)            ; We want this function to add
                  (nconc '(foo) x))           ;   foo to the front of its arg.

                (symbol-function 'add-foo)
                     ⇒ (lambda (x) (nconc (quote (foo)) x))

                (setq xx (add-foo '(1 2)))    ; It seems to work.
                     ⇒ (foo 1 2)
                (setq xy (add-foo '(3 4)))    ; What happened?
                     ⇒ (foo 1 2 3 4)
                (eq xx xy)
                     ⇒ t

                (symbol-function 'add-foo)
                     ⇒ (lambda (x) (nconc (quote (foo 1 2 3 4) x)))
  #+end_src


Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Association-Lists][Association Lists]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Modifying-Lists][Modifying Lists]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lists][Lists]]

* 5.7 Using Lists as Sets
    :PROPERTIES:
    :CUSTOM_ID: using-lists-as-sets
    :END:

A list can represent an unordered mathematical set---simply consider a value an element of a set if it appears in the list, and ignore the order of the list. To form the union of two sets, use =append= (as long as you don't mind having duplicate elements). You can remove =equal= duplicates using =delete-dups=. Other useful functions for sets include =memq= and =delq=, and their =equal= versions, =member= and =delete=.


  *Common Lisp note:* Common Lisp has functions =union= (which avoids duplicate elements) and =intersection= for set operations. Although standard GNU Emacs Lisp does not have them, the cl-lib library provides versions. See [[https://www.gnu.org/software/emacs/manual/html_mono/cl.html#Lists-as-Sets][Lists as Sets]].


--- Function: *memq* object list


  This function tests to see whether object is a member of list. If it is, =memq= returns a list starting with the first occurrence of object. Otherwise, it returns =nil=. The letter 'q' in =memq= says that it uses =eq= to compare object against the elements of the list. For example:

  #+begin_src elisp
                (memq 'b '(a b c b a))
                     ⇒ (b c b a)
                (memq '(2) '((1) (2)))    ; (2) and (2) are not eq.
                     ⇒ nil
  #+end_src


--- Function: *delq* object list


  This function destructively removes all elements =eq= to object from list, and returns the resulting list. The letter 'q' in =delq= says that it uses =eq= to compare object against the elements of the list, like =memq= and =remq=.

  Typically, when you invoke =delq=, you should use the return value by assigning it to the variable which held the original list. The reason for this is explained below.


The =delq= function deletes elements from the front of the list by simply advancing down the list, and returning a sublist that starts after those elements. For example:

#+begin_src elisp
         (delq 'a '(a b c)) == (cdr '(a b c))
#+end_src

When an element to be deleted appears in the middle of the list, removing it involves changing the cdrs (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Setcdr][Setcdr]]).

#+begin_src elisp
         (setq sample-list '(a b c (4)))
              ⇒ (a b c (4))
         (delq 'a sample-list)
              ⇒ (b c (4))
         sample-list
              ⇒ (a b c (4))
         (delq 'c sample-list)
              ⇒ (a b (4))
         sample-list
              ⇒ (a b (4))
#+end_src
#+begin_src emacs-lisp :tangle yes
(setq sample-list '(a b c (4)))
(delq 'a sample-list)
(print sample-list)
(delq 'c sample-list)
(print sample-list)
#+end_src

#+RESULTS:
| a | b | (4) |

Note that =(delq 'c sample-list)= modifies =sample-list= to splice out the third element, but =(delq 'a sample-list)= does not splice anything---it just returns a shorter list. Don't assume that a variable which formerly held the argument list now has fewer elements, or that it still holds the original list! Instead, save the result of =delq= and use that. Most often we store the result back into the variable that held the original list:

#+begin_src elisp
         (setq flowers (delq 'rose flowers))
#+end_src

In the following example, the =(4)= that =delq= attempts to match and the =(4)= in the =sample-list= are not =eq=:

#+begin_src elisp
         (delq '(4) sample-list)
              ⇒ (a c (4))
#+end_src

If you want to delete elements that are =equal= to a given value, use =delete= (see below).

--- Function: *remq* object list


  This function returns a copy of list, with all elements removed which are =eq= to object. The letter 'q' in =remq= says that it uses =eq= to compare object against the elements of =list=.

  #+begin_src elisp
                (setq sample-list '(a b c a b c))
                     ⇒ (a b c a b c)
                (remq 'a sample-list)
                     ⇒ (b c b c)
                sample-list
                     ⇒ (a b c a b c)
  #+end_src


-- Function: *memql* object list


  The function =memql= tests to see whether object is a member of list, comparing members with object using =eql=, so floating-point elements are compared by value. If object is a member, =memql= returns a list starting with its first occurrence in list. Otherwise, it returns =nil=.

  Compare this with =memq=:

  #+begin_src elisp
                (memql 1.2 '(1.1 1.2 1.3))  ; 1.2 and 1.2 are eql.
                     ⇒ (1.2 1.3)
                (memq 1.2 '(1.1 1.2 1.3))  ; 1.2 and 1.2 are not eq.
                     ⇒ nil
  #+end_src


The following three functions are like =memq=, =delq= and =remq=, but use =equal= rather than =eq= to compare elements. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Equality-Predicates][Equality Predicates]].

--- Function: *member* object list


  The function =member= tests to see whether object is a member of list, comparing members with object using =equal=. If object is a member, =member= returns a list starting with its first occurrence in list. Otherwise, it returns =nil=.

  Compare this with =memq=:

  #+begin_src elisp
                (member '(2) '((1) (2)))  ; (2) and (2) are equal.
                     ⇒ ((2))
                (memq '(2) '((1) (2)))    ; (2) and (2) are not eq.
                     ⇒ nil
                ;; Two strings with the same contents are equal.
                (member "foo" '("foo" "bar"))
                     ⇒ ("foo" "bar")
  #+end_src


--- Function: *delete* object sequence


  This function removes all elements =equal= to object from sequence, and returns the resulting sequence.

  If sequence is a list, =delete= is to =delq= as =member= is to =memq=: it uses =equal= to compare elements with object, like =member=; when it finds an element that matches, it cuts the element out just as =delq= would. As with =delq=, you should typically use the return value by assigning it to the variable which held the original list.

  If =sequence= is a vector or string, =delete= returns a copy of =sequence= with all elements =equal= to =object= removed.

  For example:

  #+begin_src elisp
                (setq l '((2) (1) (2)))
                (delete '(2) l)
                     ⇒ ((1))
                l
                     ⇒ ((2) (1))
                ;; If you want to change l reliably,
                ;; write (setq l (delete '(2) l)).
                (setq l '((2) (1) (2)))
                (delete '(1) l)
                     ⇒ ((2) (2))
                l
                     ⇒ ((2) (2))
                ;; In this case, it makes no difference whether you set l,
                ;; but you should do so for the sake of the other case.
                (delete '(2) [(2) (1) (2)])
                     ⇒ [(1)]
  #+end_src


--- Function: *remove* object sequence


  This function is the non-destructive counterpart of =delete=. It returns a copy of =sequence=, a list, vector, or string, with elements =equal= to =object= removed. For example:

  #+begin_src elisp
                (remove '(2) '((2) (1) (2)))
                     ⇒ ((1))
                (remove '(2) [(2) (1) (2)])
                     ⇒ [(1)]
  #+end_src



  *Common Lisp note:* The functions =member=, =delete= and =remove= in GNU Emacs Lisp are derived from Maclisp, not Common Lisp. The Common Lisp versions do not use =equal= to compare elements.


--- Function: *member-ignore-case* object list


  This function is like =member=, except that object should be a string and that it ignores differences in letter-case and text representation: upper-case and lower-case letters are treated as equal, and unibyte strings are converted to multibyte prior to comparison.


--- Function: *delete-dups* list


  This function destructively removes all =equal= duplicates from list, stores the result in list and returns it. Of several =equal= occurrences of an element in list, =delete-dups= keeps the first one.


See also the function =add-to-list=, in [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List-Variables][List Variables]], for a way to add an element to a list stored in a variable and used as a set.

* 5.8 Association Lists
    :PROPERTIES:
    :CUSTOM_ID: association-lists
    :END:

An association list, or alist for short, records a mapping from keys to values. It is a list of cons cells called associations: the car of each cons cell is the key, and the cdr is the associated value.[[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#fn-4][4]]

Here is an example of an alist. The key =pine= is associated with the value =cones=; the key =oak= is associated with =acorns=; and the key =maple= is associated with =seeds=.

#+begin_src elisp
((pine . cones)
 (oak . acorns)
 (maple . seeds))
#+end_src

Both the values and the keys in an alist may be any Lisp objects. For example, in the following alist, the symbol =a= is associated with the number =1=, and the string ="b"= is associated with the /list/ =(2 3)=, which is the cdr of the alist element:

#+begin_src elisp
         ((a . 1) ("b" 2 3))
#+end_src

Sometimes it is better to design an alist to store the associated value in the car of the cdr of the element. Here is an example of such an alist:

#+begin_src elisp
         ((rose red) (lily white) (buttercup yellow))
#+end_src

Here we regard =red= as the value associated with =rose=. One advantage of this kind of alist is that you can store other related information---even a list of other items---in the cdr of the cdr. One disadvantage is that you cannot use =rassq= (see below) to find the element containing a given value. When neither of these considerations is important, the choice is a matter of taste, as long as you are consistent about it for any given alist.

The same alist shown above could be regarded as having the associated value in the cdr of the element; the value associated with =rose= would be the list =(red)=.

Association lists are often used to record information that you might otherwise keep on a stack, since new associations may be added easily to the front of the list. When searching an association list for an association with a given key, the first one found is returned, if there is more than one.

In Emacs Lisp, it is /not/ an error if an element of an association list is not a cons cell. The alist search functions simply ignore such elements. Many other versions of Lisp signal errors in such cases.

Note that property lists are similar to association lists in several respects. A property list behaves like an association list in which each key can occur only once. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Property-Lists][5.9.Property Lists]], for a comparison of property lists and association lists.

--- Function: *assoc* key alist &optional testfn


  This function returns the first association for key in alist, comparing key against the alist elements using testfn if it is =non-nil= and =equal= otherwise (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Equality-Predicates][Equality Predicates]]). It returns =nil= if no association in alist has a car equal to key. For example:

  #+begin_src elisp
(setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
⇒ ((pine . cones) (oak . acorns) (maple . seeds))
(assoc 'oak trees)
⇒ (oak . acorns)
(cdr (assoc 'oak trees))
⇒ acorns
(assoc 'birch trees)
⇒ nil
  #+end_src

  Here is another example, in which the keys and values are not symbols:

  #+begin_src elisp
(setq needles-per-cluster
      '((2 "Austrian Pine" "Red Pine")
        (3 "Pitch Pine")
        (5 "White Pine")))

(cdr (assoc 3 needles-per-cluster))
⇒ ("Pitch Pine")
(cdr (assoc 2 needles-per-cluster))
⇒ ("Austrian Pine" "Red Pine")
  #+end_src


The function =assoc-string= is much like =assoc= except that it ignores certain differences between strings. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Comparison][Text Comparison]].

--- Function: *rassoc* value alist


  This function returns the first association with value value in alist. It returns =nil= if no association in alist has a cdr =equal= to value.

  =rassoc= is like =assoc= except that it compares the cdr of each alist association instead of the car. You can think of this as reverse =assoc=, finding the key for a given value.


--- Function: *assq* key alist


  This function is like =assoc= in that it returns the first association for key in alist, but it makes the comparison using =eq=. =assq= returns =nil= if no association in alist has a car =eq= to key. This function is used more often than =assoc=, since =eq= is faster than =equal= and most alists use symbols as keys. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Equality-Predicates][Equality Predicates]].

  #+begin_src elisp
                (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))
                     ⇒ ((pine . cones) (oak . acorns) (maple . seeds))
                (assq 'pine trees)
                     ⇒ (pine . cones)
  #+end_src

  On the other hand, =assq= is not usually useful in alists where the keys may not be symbols:

  #+begin_src elisp
                (setq leaves
                      '(("simple leaves" . oak)
                        ("compound leaves" . horsechestnut)))

                (assq "simple leaves" leaves)
                     ⇒ nil
                (assoc "simple leaves" leaves)
                     ⇒ ("simple leaves" . oak)
  #+end_src


--- Function: *alist-get* key alist &optional default remove testfn


  This function is similar to =assq=. It finds the first association =(=key=.=value=)= by comparing key with alist elements, and, if found, returns the value of that association. If no association is found, the function returns default. Comparison of key against alist elements uses the function specified by testfn, defaulting to =eq=.

  This is a generalized variable (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Generalized-Variables][Generalized Variables]]) that can be used to change a value with =setf=. When using it to set a value, optional argument remove non-=nil= means to remove key's association from alist if the new value is =eql= to default.


--- Function: *rassq* value alist


  This function returns the first association with value value in alist. It returns =nil= if no association in alist has a cdr =eq= to value.

  =rassq= is like =assq= except that it compares the cdr of each alist association instead of the car. You can think of this as reverse =assq=, finding the key for a given value.

  For example:

  #+begin_src elisp
                (setq trees '((pine . cones) (oak . acorns) (maple . seeds)))

                (rassq 'acorns trees)
                     ⇒ (oak . acorns)
                (rassq 'spores trees)
                     ⇒ nil
  #+end_src

  =rassq= cannot search for a value stored in the car of the cdr of an element:

  #+begin_src elisp
                (setq colors '((rose red) (lily white) (buttercup yellow)))

                (rassq 'white colors)
                     ⇒ nil
  #+end_src

  In this case, the cdr of the association =(lily white)= is not the symbol =white=, but rather the list =(white)=. This becomes clearer if the association is written in dotted pair notation:

  #+begin_src elisp
                (lily white) == (lily . (white))
  #+end_src


--- Function: *assoc-default* key alist &optional test default


  This function searches alist for a match for key. For each element of alist, it compares the element (if it is an atom) or the element's car (if it is a cons) against key, by calling test with two arguments: the element or its car, and key. The arguments are passed in that order so that you can get useful results using =string-match= with an alist that contains regular expressions (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Regexp-Search][Regexp Search]]). If test is omitted or =nil=, =equal= is used for comparison.

  If an alist element matches key by this criterion, then =assoc-default= returns a value based on this element. If the element is a cons, then the value is the element's cdr. Otherwise, the return value is default.

  If no alist element matches key, =assoc-default= returns =nil=.


--- Function: *copy-alist* alist


  This function returns a two-level deep copy of alist: it creates a new copy of each association, so that you can alter the associations of the new alist without changing the old one.

  #+begin_src elisp
                (setq needles-per-cluster
                      '((2 . ("Austrian Pine" "Red Pine"))
                        (3 . ("Pitch Pine"))
                        (5 . ("White Pine"))))
                ⇒
                ((2 "Austrian Pine" "Red Pine")
                 (3 "Pitch Pine")
                 (5 "White Pine"))

                (setq copy (copy-alist needles-per-cluster))
                ⇒
                ((2 "Austrian Pine" "Red Pine")
                 (3 "Pitch Pine")
                 (5 "White Pine"))

                (eq needles-per-cluster copy)
                     ⇒ nil
                (equal needles-per-cluster copy)
                     ⇒ t
                (eq (car needles-per-cluster) (car copy))
                     ⇒ nil
                (cdr (car (cdr needles-per-cluster)))
                     ⇒ ("Pitch Pine")
                (eq (cdr (car (cdr needles-per-cluster)))
                    (cdr (car (cdr copy))))
                     ⇒ t
  #+end_src

  This example shows how =copy-alist= makes it possible to change the associations of one copy without affecting the other:

  #+begin_src elisp
                (setcdr (assq 3 copy) '("Martian Vacuum Pine"))
                (cdr (assq 3 needles-per-cluster))
                     ⇒ ("Pitch Pine")
  #+end_src


--- Function: *assq-delete-all* key alist


  This function deletes from alist all the elements whose car is =eq= to key, much as if you used =delq= to delete each such element one by one. It returns the shortened alist, and often modifies the original list structure of alist. For correct results, use the return value of =assq-delete-all= rather than looking at the saved value of alist.

  #+begin_src elisp
                (setq alist '((foo 1) (bar 2) (foo 3) (lose 4)))
                     ⇒ ((foo 1) (bar 2) (foo 3) (lose 4))
                (assq-delete-all 'foo alist)
                     ⇒ ((bar 2) (lose 4))
                alist
                     ⇒ ((foo 1) (bar 2) (lose 4))
  #+end_src


--- Function: *assoc-delete-all* key alist


  This function deletes from alist all the elements whose car is =equal= to key. It works like =assq-delete-all=, except for the predicate used for comparing alist elements with key.


--- Function: *rassq-delete-all* value alist


  This function deletes from alist all the elements whose cdr is =eq= to value. It returns the shortened alist, and often modifies the original list structure of alist. =rassq-delete-all= is like =assq-delete-all= except that it compares the cdr of each alist association instead of the car.


* 5.9 Property Lists
    :PROPERTIES:
    :CUSTOM_ID: property-lists
    :END:

A property list (plist for short) is a list of paired elements. Each of the pairs associates a property name (usually a symbol) with a property or value. Here is an example of a property list:

#+begin_src elisp
         (pine cones numbers (1 2 3) color "blue")
#+end_src

This property list associates =pine= with =cones=, =numbers= with =(1 2 3)=, and =color= with ="blue"=. The property names and values can be any Lisp objects, but the names are usually symbols (as they are in this example).

Property lists are used in several contexts. For instance, the function =put-text-property= takes an argument which is a property list, specifying text properties and associated values which are to be applied to text in a string or buffer. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]].

Another prominent use of property lists is for storing symbol properties. Every symbol possesses a list of properties, used to record miscellaneous information about the symbol; these properties are stored in the form of a property list. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Symbol-Properties][Symbol Properties]].

1. [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Plists-and-Alists][Plists and Alists]]: Comparison of the advantages of property lists and association lists.
2. [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Plist-Access][Plist Access]]: Accessing property lists stored elsewhere.


** 5.9.1 Property Lists and Association Lists
     :PROPERTIES:
     :CUSTOM_ID: property-lists-and-association-lists
     :END:

Association lists (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Association-Lists][Association Lists]]) are very similar to property lists. In contrast to association lists, the order of the pairs in the property list is not significant, since the property names must be distinct.

Property lists are better than association lists for attaching information to various Lisp function names or variables. If your program keeps all such information in one association list, it will typically need to search that entire list each time it checks for an association for a particular Lisp function name or variable, which could be slow. By contrast, if you keep the same information in the property lists of the function names or variables themselves, each search will scan only the length of one property list, which is usually short. This is why the documentation for a variable is recorded in a property named =variable-documentation=. The byte compiler likewise uses properties to record those functions needing special treatment.

However, association lists have their own advantages. Depending on your application, it may be faster to add an association to the front of an association list than to update a property. All properties for a symbol are stored in the same property list, so there is a possibility of a conflict between different uses of a property name. (For this reason, it is a good idea to choose property names that are probably unique, such as by beginning the property name with the program's usual name-prefix for variables and functions.) An association list may be used like a stack where associations are pushed on the front of the list and later discarded; this is not possible with a property list.



** 5.9.2 Property Lists Outside Symbols
     :PROPERTIES:
     :CUSTOM_ID: property-lists-outside-symbols
     :END:

The following functions can be used to manipulate property lists. They all compare property names using =eq=.

--- Function: *plist-get* plist property


  This returns the value of the property property stored in the property list plist. It accepts a malformed plist argument. If property is not found in the plist, it returns =nil=. For example,

  #+begin_src elisp
                (plist-get '(foo 4) 'foo)
                     ⇒ 4
                (plist-get '(foo 4 bad) 'foo)
                     ⇒ 4
                (plist-get '(foo 4 bad) 'bad)
                     ⇒ nil
                (plist-get '(foo 4 bad) 'bar)
                     ⇒ nil
  #+end_src


--- Function: *plist-put* plist property value


  This stores value as the value of the property property in the property list plist. It may modify plist destructively, or it may construct a new list structure without altering the old. The function returns the modified property list, so you can store that back in the place where you got plist. For example,

  #+begin_src elisp
                (setq my-plist '(bar t foo 4))
                     ⇒ (bar t foo 4)
                (setq my-plist (plist-put my-plist 'foo 69))
                     ⇒ (bar t foo 69)
                (setq my-plist (plist-put my-plist 'quux '(a)))
                     ⇒ (bar t foo 69 quux (a))
  #+end_src


--- Function: *lax-plist-get* plist property


  Like =plist-get= except that it compares properties using =equal= instead of =eq=.


--- Function: *lax-plist-put* plist property value


  Like =plist-put= except that it compares properties using =equal= instead of =eq=.


--- Function: *plist-member* plist property


  This returns non-=nil= if plist contains the given property. Unlike =plist-get=, this allows you to distinguish between a missing property and a property with the value =nil=. The value is actually the tail of plist whose =car= is property.


Next: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Records][Records]], Previous: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lists][Lists]], Up: [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Top][Top]]
g
