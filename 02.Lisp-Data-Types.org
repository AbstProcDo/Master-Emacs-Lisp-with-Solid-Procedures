#+TITLE: 02.Lisp-Data-Types
* 2 Lisp Data Types
   :PROPERTIES:
   :CUSTOM_ID: lisp-data-types
   :END:
   :LOGBOOK:
   CLOCK: [2020-03-14 Sat 09:40]--[2020-03-14 Sat 09:50] =>  0:10
   :END:

A Lisp object is a piece of data used and manipulated by Lisp programs. For our purposes, a type or data type is a set of possible objects.

Every object belongs to at least one type. Objects of the same type have similar structures and may usually be used in the same contexts. Types can overlap, and objects can belong to two or more types. Consequently, we can ask whether an object belongs to a particular type, but not for /the/ type of an object.

A few fundamental object types are built into Emacs. These, from which all other types are constructed, are called primitive types. Each object belongs to one and only one primitive type. These types include integer, float, cons, symbol, string, vector, hash-table, =rsubr=, byte-code function, and record, plus several special types, such as buffer, that are related to editing. (See [[2.4 Editing Types]].)

Each primitive type has a corresponding Lisp function that checks whether an object is a member of that type.

Lisp is unlike many other languages in that its objects are self-typing: the primitive type of each object is implicit in the object itself. For example, if an object is a vector, nothing can treat it as a number; Lisp knows it is a vector, not a number.

In most languages, the programmer must declare the data type of each variable, and the type is known by the compiler but not represented in the data. Such type declarations do not exist in Emacs Lisp. A Lisp variable can have any type of value, and it remembers whatever value you store in it, type and all. (Actually, a small number of Emacs Lisp variables can only take on values of a certain type. (See [[file:12.Variables.org::12.16 Variables with Restricted Values]])

This chapter describes the purpose, printed representation, and read syntax of each of the standard types in GNU Emacs Lisp. Details on how to use these types can be found in later chapters.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Printed-Representation][Printed Representation]]: How Lisp objects are represented as text.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Comments][Comments]]: Comments and their formatting conventions.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Programming-Types][Programming Types]]: Types found in all Lisp systems.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Editing-Types][Editing Types]]: Types specific to Emacs.
5) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Circular-Objects][Circular Objects]]: Read syntax for circular structure.
6) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Type-Predicates][Type Predicates]]: Tests related to types.
7) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Equality-Predicates][Equality Predicates]]: Tests of equality between any two objects.

* 2.1 Printed Representation and Read Syntax
    :PROPERTIES:
    :CUSTOM_ID: printed-representation-and-read-syntax
    :END:

The printed representation of an object is the format of the output generated by the Lisp printer (the function =prin1=) for that object. Every data type has a unique printed representation. The read syntax of an object is the format of the input accepted by the Lisp reader (the function =read=) for that object. This is not necessarily unique; many kinds of object have more than one syntax. See [[file:19.Reading-and-Printing-Lisp-Objects.org][19 Reading and Printing Lisp Objects]].

In most cases, an object's printed representation is also a read syntax for the object.
# 问题?: 此话怎讲呢?
However, some types have no read syntax, since it does not make sense to enter objects of these types as constants in a Lisp program. These objects are printed in hash notation, which consists of the characters '#<', a descriptive string (typically the type name followed by the name of the object), and a closing '>'. For example:

#+BEGIN_SRC elisp
         (current-buffer)
              ⇒ #<buffer objects.texi>
#+END_SRC
# 短评: 这是第几次浪费时间在这上面了呢? 
Hash notation cannot be read at all, so the Lisp reader signals the error =invalid-read-syntax= whenever it encounters '#<'. In other languages, an expression is text; it has no other form. In Lisp, an expression is primarily a Lisp object and only secondarily the text that is the object's read syntax. Often there is no need to emphasize this distinction, but you must keep it ~in the back of your mind~, or you will occasionally be very confused.
# 得到-词汇: in the back of your mind,
# 问题? 这种read的区别, 之前没有接触到. 打通各个系统之间的壁垒.
When you evaluate an expression interactively, the Lisp interpreter first reads the textual representation of it, producing a Lisp object, and then evaluates that object (see [[file:10.Evaluation.org][10 Evaluation]]).
# 洞见: 逻辑清晰,
However, evaluation and reading are separate activities. Reading returns the Lisp object represented by the text that is read; the object may or may not be evaluated later. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Input-Functions][Input Functions]], for a description of =read=, the basic function for reading objects.

* 2.2 Comments
    :PROPERTIES:
    :CUSTOM_ID: comments
    :END:

A comment is text that is written in a program only ~for the sake of humans~ that read the program, and that has no effect on the meaning of the program. In Lisp, an unescaped semicolon (';') starts a comment if it is not within a string or character constant. The comment continues to the end of line. The Lisp reader discards comments; they do not become part of the Lisp objects which represent the program within the Lisp system.

The '#@count' construct, which skips the next count characters, is useful for program-generated comments containing binary data. The Emacs Lisp byte compiler uses this in its output files (see [[file:17.Byte Compilation.org][17.Byte Compilation]]). It isn't meant for source files, however.

See [[file:Appendix-D-Tips-and-Conventions.org::D.7 Tips on Writing Comments][D.7 Tips on Writing Comments]] for conventions for formatting comments.

* 2.3 Programming Types
    :PROPERTIES:
    :CUSTOM_ID: programming-types
    :END:

There are two general categories of types in Emacs Lisp:
- those having to do with Lisp programming,
- and those having to do with editing.
# 得到：如此划分比较有意思.
# 问题? 这两项的区分到底在哪里呢? 
The former exist in many Lisp implementations, in one form or another. The latter are unique to Emacs Lisp.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Integer-Type][Integer Type]]: Numbers without fractional parts.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Floating_002dPoint-Type][Floating-Point Type]]: Numbers with fractional parts and with a large range.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]]: The representation of letters, numbers and control characters.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Symbol-Type][Symbol Type]]: A multi-use object that refers to a function, variable, or property list, and has a unique identity.
5) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequence-Type][Sequence Type]]: Both lists and arrays are classified as sequences.
6) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Cons-Cell-Type][Cons Cell Type]]: Cons cells, and lists (which are made from cons cells).
7) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Array-Type][Array Type]]: Arrays include strings and vectors.
8) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#String-Type][String Type]]: An (efficient) array of characters.
9) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vector-Type][Vector Type]]: One-dimensional arrays.
10) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Char_002dTable-Type][Char-Table Type]]: One-dimensional sparse arrays indexed by characters.
11) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Bool_002dVector-Type][Bool-Vector Type]]: One-dimensional arrays of =t= or =nil=.
12) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Hash-Table-Type][Hash Table Type]]: Super-fast lookup tables.
13) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Function-Type][Function Type]]: A piece of executable code you can call from elsewhere.
14) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Macro-Type][Macro Type]]: A method of expanding an expression into another expression, more fundamental but less pretty.
15) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Primitive-Function-Type][Primitive Function Type]]: A function written in C, callable from Lisp.
16) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Byte_002dCode-Type][Byte-Code Type]]: A function written in Lisp, then compiled.
17) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Record-Type][Record Type]]: Compound objects with programmer-defined types.
18) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Type-Descriptors][Type Descriptors]]: Objects holding information about types.
19) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Autoload-Type][Autoload Type]]: A type used for automatically loading seldom-used functions.
20) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Finalizer-Type][Finalizer Type]]: Runs code when no longer reachable.


** 2.3.1 Integer Type
     :PROPERTIES:
     :CUSTOM_ID: integer-type
     :END:

The range of values for an integer depends on the machine. The minimum range is −536,870,912 to 536,870,911 (30 bits; i.e., −2*29 to 2*29 − 1) but many machines provide a wider range. Emacs Lisp arithmetic functions do not check for integer overflow. Thus =(1+ 536870911)= is −536,870,912 if Emacs integers are 30 bits.

The read syntax for integers is a sequence of (base ten) digits with an optional sign at the beginning and an optional period at the end. The printed representation produced by the Lisp interpreter never has a leading '+' or a final '.'.

#+BEGIN_SRC elisp
         -1               ; The integer −1.
         1                ; The integer 1.
         1.               ; Also the integer 1.
         +1               ; Also the integer 1.
#+END_SRC

As a special exception, if a sequence of digits specifies an integer too large or too small to be a valid integer object, the Lisp reader reads it as a floating-point number (see [[2.3.2 Floating-Point Type]]). For instance, if Emacs integers are 30 bits, =536870912= is read as the floating-point number =536870912.0=.

See [[file:03.Numbers.org][03.Numbers]], for more information.

** 2.3.2 Floating-Point Type
     :PROPERTIES:
     :CUSTOM_ID: floating-point-type
     :END:

Floating-point numbers are the computer equivalent of scientific notation; you can think of a floating-point number as a fraction together with a power of ten. The precise number of significant figures and the range of possible exponents is machine-specific; Emacs uses the C data type =double= to store the value, and internally this records a power of 2 rather than a power of 10.

The printed representation for floating-point numbers requires either a decimal point (with at least one digit following), an exponent, or both. For example, '1500.0', '+15e2', '15.0e+2', '+1500000e-3', and '.15e4' are five ways of writing a floating-point number whose value is 1500. They are all equivalent.

See [[file:03.Numbers.org][03.Numbers]], for more information.

** 2.3.3 Character Type
     :PROPERTIES:
     :CUSTOM_ID: character-type
     :END:

A character in Emacs Lisp is nothing more than an integer. In other words, characters are represented by their character codes. For example, the character A is represented as the integer 65.
# 洞见: 此处说得好哇, 源于此, integter与character是都是整型, 此处为重要的过度节点.

Individual characters are used occasionally in programs, but it is more common to work with /strings/, which are sequences composed of characters. See [[2.3.8 String Type]].

Characters in strings and buffers are currently limited to the range of 0 to 4194303---twenty two bits (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Codes][Character Codes]]). Codes 0 through 127 are ASCII codes; the rest are non-ASCII (see [[file:33.Non-ASCII-Characters.org][33 Non-ASCII Characters]]). Characters that represent keyboard input have a much wider range, to encode modifier keys such as Control, Meta and Shift.
#+begin_src ipython :session elisp :results output
import math
print(math.log2(4194303))
#+end_src

#+RESULTS:
: 21.999999656034657

There are special functions for producing a human-readable textual description of a character for the sake of messages. See [[file:24.Documentation.org::24.5 Describing Characters for Help Messages][24.5 Describing Characters for Help Messages]].

1. [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Char-Syntax][Basic Char Syntax]]: Syntax for regular characters.
2. [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#General-Escape-Syntax][General Escape Syntax]]: How to specify characters by their codes.
3. [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Ctl_002dChar-Syntax][Ctl-Char Syntax]]: Syntax for control characters.
4. [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Meta_002dChar-Syntax][Meta-Char Syntax]]: Syntax for meta-characters.
5. [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Other-Char-Bits][Other Char Bits]]: Syntax for hyper-, super-, and alt-characters.


*** 2.3.3.1 Basic Char Syntax
      :PROPERTIES:
      :CUSTOM_ID: basic-char-syntax
      :END:

Since characters are really integers, the printed representation of a character is a decimal number. This is also a possible read syntax for a character, but writing characters that way in Lisp programs is not clear programming. You should /always/ use the special read syntax formats that Emacs Lisp provides for characters. These syntax formats start with a question mark.

The usual read syntax for alphanumeric characters is a question mark followed by the character; thus, '?A' for the character A, '?B' for the character B, and '?a' for the character a.

For example:

#+BEGIN_SRC elisp
?Q  # 这种查询方法比较有意思.
#+END_SRC

#+RESULTS:
: 81

#+begin_src ipython :session elisp :results value
chr(81)
#+end_src

#+RESULTS:
: # Out[4]:
: : 'Q'
#+begin_src ipython :session elisp :results value
ord("Q")
#+end_src

#+RESULTS:
: # Out[6]:
: : 81

You can use the same syntax for punctuation characters. However, if the punctuation character has a special syntactic meaning in Lisp, you must quote it with a ''. For example, ‘?(' is the way to write the open-paren character. Likewise, if the character is '', you must use a second ‘' to quote it: ‘?\'.

You can express the characters control-g, backspace, tab, newline, vertical tab, formfeed, space, return, del, and escape as '?\a', '?\b', '?\t', '?\n', '?\v’, ‘?\f', '?\s', '?\r', '?\d', and '?\e', respectively. ('?\s' followed by a dash has a different meaning---it applies the Super modifier to the following character.) Thus,

#+BEGIN_SRC elisp
         ?\a ⇒ 7                 ; control-g, C-g
         ?\b ⇒ 8                 ; backspace, <BS>, C-h
         ?\t ⇒ 9                 ; tab, <TAB>, C-i
         ?\n ⇒ 10                ; newline, C-j
         ?\v ⇒ 11                ; vertical tab, C-k
         ?\f ⇒ 12                ; formfeed character, C-l
         ?\r ⇒ 13                ; carriage return, <RET>, C-m
         ?\e ⇒ 27                ; escape character, <ESC>, C-[
         ?\s ⇒ 32                ; space character, <SPC>
         ?\\ ⇒ 92                ; backslash character, \
         ?\d ⇒ 127               ; delete character, <DEL>
#+END_SRC
# 短评: 直观而且简单.
These sequences which start with backslash are also known as escape sequences, because backslash plays the role of an escape character; this has nothing to do with the character . '\s' is meant for use in character constants; in string constants, just write the space.

A backslash is allowed, and harmless, preceding any character without a special escape meaning; thus, '?+' is equivalent to '?+'. There is no reason to add a backslash before most characters. However, you must add a backslash before any of the characters '()[];"', and you should add a backslash before any of the characters '|'`#.,' to avoid confusing the Emacs commands for editing Lisp code. You can also add a backslash before whitespace characters such as space, tab, newline and formfeed. However, it is cleaner to use one of the easily readable escape sequences, such as '\t' or '\s', instead of an actual whitespace character such as a tab or a space. (If you do write backslash followed by a space, you should write an extra space after the character constant to separate it from the following text.)



*** 2.3.3.2 General Escape Syntax
      :PROPERTIES:
      :CUSTOM_ID: general-escape-syntax
      :END:

In addition to the specific escape sequences for special important control characters, Emacs provides several types of escape syntax that you can use to specify non-ASCII text characters.

1. You can specify characters by their Unicode names, if any. =?\N{=NAME=}= represents the Unicode character named NAME. Thus, '?\N{LATIN SMALL LETTER A WITH GRAVE}' is equivalent to =?à= and denotes the Unicode character U+00E0. To simplify entering multi-line strings, you can replace spaces in the names by non-empty sequences of whitespace (e.g., newlines).
   #+begin_src emacs-lisp :tangle yes
?\N{LATIN SMALL LETTER A WITH GRAVE}
?à
   #+end_src

   #+RESULTS:
   : 224
# 短评: 此处有意思.
2. You can specify characters by their Unicode values. =?\N{U+=X=}= represents a character with Unicode code point X, where X is a hexadecimal number. Also, =?\uxxxx= and =?\Uxxxxxxxx= represent code points xxxx and xxxxxxxx, respectively, where each x is a single hexadecimal digit. For example, =?\N{U+E0}=, =?\u00e0= and =?\U000000E0= are all equivalent to =?à= and to '?\N{LATIN SMALL LETTER A WITH GRAVE}'. The Unicode Standard defines code points only up to 'U+10ffff', so if you specify a code point higher than that, Emacs signals an error.\\
3. You can specify characters by their hexadecimal character codes. A hexadecimal escape sequence consists of a backslash, 'x', and the hexadecimal character code. Thus, '?\x41' is the character A, '?\x1' is the character C-a, and =?\xe0= is the character à (a with grave accent). You can use any number of hex digits, so you can represent any character code in this way.\\
4. You can specify characters by their character code in octal. An octal escape sequence consists of a backslash followed by up to three octal digits; thus, '?\101' for the character A, '?\001' for the character C-a, and =?\002= for the character C-b. Only characters up to octal code 777 can be specified this way.

These escape sequences may also be used in strings. See [[2.3.8.2 Non-ASCII Characters in Strings]].


*** 2.3.3.3 Control-Character Syntax
      :PROPERTIES:
      :CUSTOM_ID: control-character-syntax
      :END:

Control characters can be represented using yet another read syntax. This consists of a question mark followed by a backslash, caret, and the corresponding non-control character, in either upper or lower case. For example, both '?\^I' and '?\^i' are valid read syntax for the character C-i, the character whose value is 9.

Instead of the '\^', you can use 'C-'; thus, '?\C-i' is equivalent to '?\^I' and to '?\^i':

#+BEGIN_SRC elisp
         ?\^I ⇒ 9     ?\C-I ⇒ 9
#+END_SRC
# 得到: 此处为kbd键盘绑定的基础．
In strings and buffers, the only control characters allowed are those that exist in ASCII; but for keyboard input purposes, you can turn any character into a control character with 'C-'. The character codes for these non-ASCII control characters include the 2**26 bit as well as the code for the corresponding non-control character. Ordinary text terminals have no way of generating non-ASCII control characters, but you can generate them straightforwardly using X and other window systems.

For historical reasons, Emacs treats the character as the control equivalent of ?:

#+BEGIN_SRC elisp
         ?\^? ⇒ 127     ?\C-? ⇒ 127
#+END_SRC

As a result, it is currently not possible to represent the character Control-?, which is a meaningful input character under X, using '\C-'. It is not easy to change this, as various Lisp files refer to in this way.

For representing control characters to be found in files or strings, we recommend the '\^' syntax; for control characters in keyboard input, we prefer the 'C-' syntax. Which one you use does not affect the meaning of the program, but may guide the understanding of people who read it.

# 得到: \^ 此处也算是给caveat找到了归处.

*** 2.3.3.4 Meta-Character Syntax
      :PROPERTIES:
      :CUSTOM_ID: meta-character-syntax
      :END:

A meta character is a character typed with the

#+BEGIN_HTML
  <META>
#+END_HTML

modifier key. The integer that represents such a character has the 2**27 bit set. We use high bits for this and other modifiers to make possible a wide range of basic character codes.

In a string, the 2**7 bit attached to an ASCII character indicates a meta character; thus, the meta characters that can fit in a string have codes in the range from 128 to 255, and are the meta versions of the ordinary ASCII characters. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Strings-of-Events][Strings of Events]], for details about  <META>.


-handling in strings.

The read syntax for meta characters uses '\M-'. For example, '?\M-A' stands for M-A. You can use '\M-' together with octal character codes (see below), with '\C-', or with any other syntax for a character. Thus, you can write M-A as '?\M-A', or as '?\M-\101'. Likewise, you can write C-M-b as '?\M-\C-b', '?\C-\M-b', or '?\M-\002'.

# 短评: 确实应该找到"理论支撑", 如此, 才能得心应手的应用.

*** 2.3.3.5 Other Character Modifier Bits
      :PROPERTIES:
      :CUSTOM_ID: other-character-modifier-bits
      :END:

The case of a graphic character is indicated by its character code; for example, ASCII distinguishes between the characters 'a' and 'A'. But ASCII has no way to represent whether a control character is upper case or lower case. Emacs uses the 2**25 bit to indicate that the shift key was used in typing a control character. This distinction is possible only when you use X terminals or other special terminals; ordinary text terminals do not report the distinction. The Lisp syntax for the shift bit is '\S-'; thus, '?\C-\S-o' or '?\C-\S-O' represents the shifted-control-o character.
# 短评: 想起来之前还提问"\S-", Super还是Shift的问题.
The X Window System defines three other modifier bits that can be set in a character: hyper, super and alt. The syntaxes for these bits are '\H-', '\s-' and '\A-'. (Case is significant in these prefixes.) Thus, '?\H-\M-\A-x' represents Alt-Hyper-Meta-x. (Note that '\s' with no following '-' represents the space character.) Numerically, the bit values are 2*22 for alt, 2*23 for super and 2**24 for hyper.

# 得到: 总算找到了, super在这里.

** 2.3.4 Symbol Type
     :PROPERTIES:
     :CUSTOM_ID: symbol-type
     :END:
# 短评: symbol是lisp的核心之处.
A symbol in GNU Emacs Lisp is an object with a name. The symbol name serves as the ~printed representation of the symbol~. In ordinary Lisp use, with one single obarray (see [[file:09.Symbols.org::9.3 Creating and Interning Symbols][9.3 Creating and Interning Symbols]]), a symbol's name is unique---no two symbols have the same name.

A symbol can serve as a variable, as a function name, or to hold a property list. Or it may serve only to be distinct from all other Lisp objects, so that its presence in a data structure may be recognized reliably. In a given context, usually only one of these uses is intended. But you can use one symbol in all of these ways, independently.

A symbol whose name starts with a colon (':') is called a keyword symbol. These symbols automatically act as constants, and are normally used only by comparing an unknown symbol with a few specific alternatives. See [[file:12.Variables.org::12.2 Variables that Never Change][12.2 Variables that Never Change]].

A symbol name can contain any characters whatever. Most symbol names are written with letters, digits, and the punctuation characters ‘-+=*/'. Such names require no special punctuation; the characters of the name suffice as long as the name does not look like a number. (If it does, write a ‘' at the beginning of the name to force interpretation as a symbol.) The characters ‘\_~!@$%\^&:<>{}?' are less often used but also require no special punctuation. Any other characters may be included in a symbol's name by escaping them with a backslash. In contrast to its use in strings, however, a backslash in the name of a symbol simply quotes the single character that follows the backslash. For example, in a string, '\t' represents a tab character; in the name of a symbol, however, '\t' merely quotes the letter 't'. To have a symbol with a tab character in its name, you must actually use a tab (preceded with a backslash). But it's rare to do such a thing.

#+BEGIN_QUOTE
  *Common Lisp note:* In Common Lisp, lower case letters are always folded to upper case, unless they are explicitly escaped. In Emacs Lisp, upper case and lower case letters are distinct.
#+END_QUOTE

Here are several examples of symbol names. Note that the '+' in the fourth example is escaped to prevent it from being read as a number. This is not necessary in the sixth example because the rest of the name makes it invalid as a number.

#+BEGIN_SRC elisp
         foo                 ; A symbol named ‘foo’.
         FOO                 ; A symbol named ‘FOO’, different from ‘foo’.
         1+                  ; A symbol named ‘1+’
                             ;   (not ‘+1’, which is an integer).
         \+1                 ; A symbol named ‘+1’
                             ;   (not a very readable name).
         \(*\ 1\ 2\)         ; A symbol named ‘(* 1 2)’ (a worse name).


         +-*/_~!@$%^&=:<>{}  ; A symbol named ‘+-*/_~!@$%^&=:<>{}’.
                             ;   These characters need not be escaped.
#+END_SRC

As an exception to the rule that a symbol's name serves as its printed representation, '##' is the printed representation for an interned symbol whose name is an empty string. Furthermore, '#:foo' is the printed representation for an uninterned symbol whose name is foo. (Normally, the Lisp reader interns all symbols; see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Symbols][Creating Symbols]].)

** 2.3.5 Sequence Types
     :PROPERTIES:
     :CUSTOM_ID: sequence-types
     :END:

A sequence is a Lisp object that represents an ordered set of elements. There are two kinds of sequence in Emacs Lisp: lists and arrays.

Lists are the most commonly-used sequences. A list can hold elements of any type, and its length can be easily changed by adding or removing elements. See the next subsection for more about lists.

Arrays are fixed-length sequences.
# 短评: 区别是在这里呀, array fixed-length
They are further subdivided into strings, vectors, char-tables and bool-vectors. Vectors can hold elements of any type, whereas string elements must be characters, and bool-vector elements must be =t= or =nil=. Char-tables are like vectors except that they are indexed by any valid character code. The characters in a string can have text properties like characters in a buffer (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]), but vectors do not support text properties, even when their elements happen to be characters.

Lists, strings and the other array types also share important similarities. For example, all have a length l, and all have elements which can be indexed from zero to l minus one. Several functions, called sequence functions, accept any kind of sequence. For example, the function =length= reports the length of any kind of sequence. See [[file:06.Sequences-Arrays-and-Vectors.org][6 Sequences, Arrays, and Vectors]] .

It is generally impossible to read the same sequence twice,
since sequences are always created anew upon reading. If you read the read syntax for a sequence twice, you get two sequences with equal contents. There is one exception: the empty list =()= always stands for the same object, =nil=.
# 洞见: 有点意思, 此处是与python编程过程的本质区别.

** 2.3.6 Cons Cell and List Types
     :PROPERTIES:
     :CUSTOM_ID: cons-cell-and-list-types
     :END:

A cons cell is an object that consists of two slots, called the car slot and the cdr slot. Each slot can hold any Lisp object. We also say that the car of this cons cell is whatever object its car slot currently holds, and likewise for the cdr.

A list is a series of cons cells, linked together so that the cdr slot of each cons cell holds either the next cons cell or the empty list. The empty list is actually the symbol =nil=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lists][Lists]], for details. Because most cons cells are used as part of lists, we refer to any structure made out of cons cells as a list structure.

#+BEGIN_QUOTE
  A note to C programmers: a Lisp list thus works as a linked list built up of cons cells. Because pointers in Lisp are implicit, we do not distinguish between a cons cell slot holding a value versus pointing to the value.
#+END_QUOTE
# 洞见: 此乃lisp的关键点, implicit pointers

Because cons cells are so central to Lisp, we also have a word for an object which is not a cons cell. These objects are called atoms.

The read syntax and printed representation for lists are identical, and consist of a left parenthesis, an arbitrary number of elements, and a right parenthesis. Here are examples of lists:

#+BEGIN_SRC elisp
         (A 2 "A")            ; A list of three elements.
         ()                   ; A list of no elements (the empty list).
         nil                  ; A list of no elements (the empty list).
         ("A ()")             ; A list of one element: the string "A ()".
         (A ())               ; A list of two elements: A and the empty list.
         (A nil)              ; Equivalent to the previous.
         ((A B C))            ; A list of one element
                              ;   (which is a list of three elements).
#+END_SRC

Upon reading, each object inside the parentheses becomes an element of the list. That is, a cons cell is made for each element. The car slot of the cons cell holds the element, and its cdr slot refers to the next cons cell of the list, which holds the next element in the list. The cdr slot of the last cons cell is set to hold =nil=.

The names car and cdr derive from the history of Lisp. The original Lisp implementation ran on an IBM 704 computer which divided words into two parts, the address and the decrement; car was an instruction to extract the contents of the address part of a register, and cdr an instruction to extract the contents of the decrement. By contrast, cons cells are named for the function =cons= that creates them, which in turn was named for its purpose, the construction of cells.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Box-Diagrams][Box Diagrams]]: Drawing pictures of lists.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Dotted-Pair-Notation][Dotted Pair Notation]]: A general syntax for cons cells.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Association-List-Type][Association List Type]]: A specially constructed list.


*** 2.3.6.1 Drawing Lists as Box Diagrams
      :PROPERTIES:
      :CUSTOM_ID: drawing-lists-as-box-diagrams
      :END:

A list can be illustrated by a diagram in which the cons cells are shown as pairs of boxes, like ~dominoes~. (The Lisp reader cannot read such an illustration; unlike the textual notation, which can be understood by both humans and computers, the box illustrations can be understood only by humans.) This picture represents the three-element list =(rose violet buttercup)=:

#+BEGIN_SRC elisp
             --- ---      --- ---      --- ---
            |   |   |--> |   |   |--> |   |   |--> nil
             --- ---      --- ---      --- ---
              |            |            |
              |            |            |
               --> rose     --> violet   --> buttercup
#+END_SRC

In this diagram, each box represents a slot that can hold or refer to any Lisp object. Each pair of boxes represents a cons cell. Each arrow represents a reference to a Lisp object, either an atom or another cons cell.

In this example, the first box, which holds the car of the first cons cell, refers to or holds =rose= (a symbol). The second box, holding the cdr of the first cons cell, refers to the next pair of boxes, the second cons cell. The car of the second cons cell is =violet=, and its cdr is the third cons cell. The cdr of the third (and last) cons cell is =nil=.

Here is another diagram of the same list, =(rose violet buttercup)=, sketched in a different manner:

#+BEGIN_SRC elisp
      ---------------       ----------------       -------------------
     | car   | cdr   |     | car    | cdr   |     | car       | cdr   |
     | rose  |   o-------->| violet |   o-------->| buttercup |  nil  |
     |       |       |     |        |       |     |           |       |
      ---------------       ----------------       -------------------
#+END_SRC

A list with no elements in it is the empty list; it is identical to the symbol =nil=. In other words, =nil= is both a symbol and a list.

Here is the list =(A ())=, or equivalently =(A nil)=, depicted with boxes and arrows:

#+BEGIN_SRC elisp
             --- ---      --- ---
            |   |   |--> |   |   |--> nil
             --- ---      --- ---
              |            |
              |            |
               --> A        --> nil
#+END_SRC

Here is a more complex illustration, showing the three-element list, =((pine needles) oak maple)=, the first element of which is a two-element list:

#+BEGIN_SRC elisp
             --- ---      --- ---      --- ---
            |   |   |--> |   |   |--> |   |   |--> nil
             --- ---      --- ---      --- ---
              |            |            |
              |            |            |
              |             --> oak      --> maple
              |
              |     --- ---      --- ---
               --> |   |   |--> |   |   |--> nil
                    --- ---      --- ---
                     |            |
                     |            |
                      --> pine     --> needles
#+END_SRC

The same list represented in the second box notation looks like this:

#+BEGIN_SRC elisp
          --------------       --------------       --------------
         | car   | cdr  |     | car   | cdr  |     | car   | cdr  |
         |   o   |   o------->| oak   |   o------->| maple |  nil |
         |   |   |      |     |       |      |     |       |      |
          -- | ---------       --------------       --------------
             |
             |
             |        --------------       ----------------
             |       | car   | cdr  |     | car     | cdr  |
              ------>| pine  |   o------->| needles |  nil |
                     |       |      |     |         |      |
                      --------------       ----------------
#+END_SRC


*** 2.3.6.2 Dotted Pair Notation
      :PROPERTIES:
      :CUSTOM_ID: dotted-pair-notation
      :END:

Dotted pair notation is a general syntax for cons cells that represents the car and cdr explicitly. In this syntax, =(a.b)= stands for a cons cell whose car is the object a and whose cdr is the object b. Dotted pair notation is more general than list syntax because the cdr does not have to be a list. However, it is more cumbersome in cases where list syntax would work. In dotted pair notation, the list '(1 2 3)' is written as '(1 . (2 . (3 . nil)))'. For =nil-terminated= lists, you can use either notation, but list notation is usually clearer and more convenient. When printing a list, the dotted pair notation is only used if the cdr of a cons cell is not a list.

Here's an example using boxes to illustrate dotted pair notation. This example shows the pair =(rose . violet)=:

#+BEGIN_SRC elisp
             --- ---
            |   |   |--> violet
             --- ---
              |
              |
               --> rose
#+END_SRC

You can combine dotted pair notation with list notation to represent conveniently a chain of cons cells with a =non-nil= final cdr. You write a dot after the last element of the list, followed by the cdr of the final cons cell. For example, =(rose violet . buttercup)= is equivalent to =(rose . (violet . buttercup))=. The object looks like this:
# 洞见: =(rose violet . buttercup)= 与 =(rose . (violet . buttercup)) 相同, 

#+BEGIN_SRC elisp
             --- ---      --- ---
            |   |   |--> |   |   |--> buttercup
             --- ---      --- ---
              |            |
              |            |
               --> rose     --> violet
#+END_SRC

The syntax =(rose . violet . buttercup)= is invalid because there is nothing that it could mean. If anything, it would say to put =buttercup= in the cdr of a cons cell whose cdr is already used for =violet=.

The list =(rose violet)= is equivalent to =(rose . (violet))=, and looks like this:

#+BEGIN_SRC elisp
             --- ---      --- ---
            |   |   |--> |   |   |--> nil
             --- ---      --- ---
              |            |
              |            |
               --> rose     --> violet
#+END_SRC

Similarly, the three-element list =(rose violet buttercup)= is equivalent to =(rose . (violet . (buttercup)))=. It looks like this:

#+BEGIN_SRC elisp
             --- ---      --- ---      --- ---
            |   |   |--> |   |   |--> |   |   |--> nil
             --- ---      --- ---      --- ---
              |            |            |
              |            |            |
               --> rose     --> violet   --> buttercup
#+END_SRC

# 短评: 讲解得清楚明了.
*** 2.3.6.3 Association List Type
      :PROPERTIES:
      :CUSTOM_ID: association-list-type
      :END:

An association list or alist is a specially-constructed list whose elements are cons cells. In each element, the car is considered a key, and the cdr is considered an associated value. (In some cases, the associated value is stored in the car of the cdr.)
# 洞见: value存储在car of the cdr.
Association lists are often used as stacks, since it is easy to add or remove associations at the front of the list.

For example,

#+BEGIN_SRC elisp
         (setq alist-of-colors
               '((rose . red) (lily . white) (buttercup . yellow)))
#+END_SRC

sets the variable =alist-of-colors= to an alist of three elements. In the first element, =rose= is the key and =red= is the value.

See [[file:05.List.org::5.8 Association Lists][5.8 Association List]] a further explanation of alists and for functions that work on alists. See [[file:08.Hash-Tables.org][08.Hash-Tables]] for another kind of lookup table, which is much faster for handling a large number of keys.
# 短评: python中的tuple

** 2.3.7 Array Type
     :PROPERTIES:
     :CUSTOM_ID: array-type
     :END:

An array is composed of an arbitrary number of slots for holding or referring to other Lisp objects, arranged in a contiguous block of memory. Accessing any element of an array takes approximately the same amount of time. In contrast, accessing an element of a list requires time ~proportional~ to the position of the element in the list. (Elements at the end of a list take longer to access than elements at the beginning of a list.)

Emacs defines four types of array:
1) strings, 2) vectors, 3) bool-vectors, and 4) char-tables.
# 洞见: 所以, python的数据全部都是array.

A string is an array of characters and
a vector is an array of arbitrary objects.
A bool-vector can hold only =t= or =nil=.
These kinds of array may have any length up to the largest integer.
Char-tables are sparse arrays indexed by any valid character code; they can hold arbitrary objects.

The first element of an array has index zero, the second element has index 1, and so on. This is called zero-origin indexing. For example, an array of four elements has indices 0, 1, 2, and 3. The largest possible index value is one less than the length of the array. Once an array is created, its length is fixed.

All Emacs Lisp arrays are one-dimensional. (Most other programming languages support multidimensional arrays, but they are not essential; you can get the same effect with nested one-dimensional arrays.) Each type of array has its own read syntax; see the following sections for details.
# 问题? read syntax这个提法其实很奇怪.
The array type is a subset of the sequence type, and contains the string type, the vector type, the bool-vector type, and the char-table type.

** 2.3.8 String Type
     :PROPERTIES:
     :CUSTOM_ID: string-type
     :END:

A string is an array of characters. Strings are used for many purposes in Emacs, as can be expected in a text editor; for example, as the names of Lisp symbols, as messages for the user, and to represent text extracted from buffers. Strings in Lisp are constants: evaluation of a string returns the same string.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Strings-and-Characters][Strings and Characters]], for functions that operate on strings.

1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-for-Strings][Syntax for Strings]]: How to specify Lisp strings.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Non_002dASCII-in-Strings][Non-ASCII in Strings]]: International characters in strings.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Nonprinting-Characters][Nonprinting Characters]]: Literal unprintable characters in strings.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Props-and-Strings][Text Props and Strings]]: Strings with text properties.


*** 2.3.8.1 Syntax for Strings
      :PROPERTIES:
      :CUSTOM_ID: syntax-for-strings
      :END:

The read syntax for a string is a double-quote, an arbitrary number of characters, and another double-quote, ="like this"= . To include a double-quote in a string, precede it with a backslash; thus, ="\""= is a string containing just one double-quote character. Likewise, you can include a backslash by preceding it with another backslash, like this: ="this \\ is a single embedded backslash"=.

The newline character is not special in the read syntax for strings; if you write a new line between the double-quotes, it becomes a character in the string. But an escaped newline---one that is preceded by ''---does not become part of the string; i.e., the Lisp reader ignores an escaped newline while reading a string. An escaped space ‘ ' is likewise ignored.

#+BEGIN_SRC elisp
         "It is useful to include newlines
         in documentation strings,
         but the newline is \
         ignored if escaped."
#+END_SRC

#+RESULTS:
: It is useful to include newlines
:          in documentation strings,
:          but the newline is          ignored if escaped.


*** 2.3.8.2 Non-ASCII Characters in Strings
      :PROPERTIES:
      :CUSTOM_ID: non-ascii-characters-in-strings
      :END:

There are two text representations for non-ASCII characters in Emacs strings: multibyte and unibyte (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Representations][Text Representations]]). Roughly speaking, unibyte strings store raw bytes, while multibyte strings store human-readable text. Each character in a unibyte string is a byte, i.e., its value is between 0 and 255. By contrast, each character in a multibyte string may have a value between 0 to 4194303 (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Character-Type][Character Type]]). In both cases, characters above 127 are non-ASCII.

You can include a non-ASCII character in a string constant by writing it literally. If the string constant is read from a multibyte source, such as a multibyte buffer or string, or a file that would be visited as multibyte, then Emacs reads each non-ASCII character as a multibyte character and automatically makes the string a multibyte string. If the string constant is read from a unibyte source, then Emacs reads the non-ASCII character as unibyte, and makes the string unibyte.

Instead of writing a character literally into a multibyte string, you can write it as its character code using an escape sequence. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#General-Escape-Syntax][General Escape Syntax]], for details about escape sequences.

If you use any Unicode-style escape sequence '\uNNNN' or '\U00NNNNNN' in a string constant (even for an ASCII character), Emacs automatically assumes that it is multibyte.

You can also use hexadecimal escape sequences ('\xn') and octal escape sequences ('\n') in string constants. *But beware:* If a string constant contains hexadecimal or octal escape sequences, and these escape sequences all specify unibyte characters (i.e., less than 256), and there are no other literal non-ASCII characters or Unicode-style escape sequences in the string, then Emacs automatically assumes that it is a unibyte string. That is to say, it assumes that all non-ASCII characters occurring in the string are 8-bit raw bytes.

In hexadecimal and octal escape sequences, the escaped character code may contain a variable number of digits, so the first subsequent character which is not a valid hexadecimal or octal digit terminates the escape sequence. If the next character in a string could be interpreted as a hexadecimal or octal digit, write ' ' (backslash and space) to terminate the escape sequence. For example, '\xe0 ' represents one character, 'a' with grave accent. ' ' in a string constant is just like backslash-newline; it does not contribute any character to the string, but it does terminate any preceding hex escape.


*** 2.3.8.3 Nonprinting Characters in Strings
      :PROPERTIES:
      :CUSTOM_ID: nonprinting-characters-in-strings
      :END:

You can use the same backslash escape-sequences in a string constant as in character literals (but do not use the question mark that begins a character constant). For example, you can write a string containing the nonprinting characters tab and C-a, with commas and spaces between them, like this: ="\t, \C-a"=. See [[2.3.3 Character Type]], for a description of the read syntax for characters.

However, not all of the characters you can write with backslash escape-sequences are valid in strings. The only control characters that a string can hold are the ASCII control characters. Strings do not distinguish case in ASCII control characters.

Properly speaking, strings cannot hold meta characters; but when a string is to be used as a key sequence, there is a special convention that provides a way to represent meta versions of ASCII characters in a string. If you use the '\M-' syntax to indicate a meta character in a string constant, this sets the 2**7 bit of the character in the string. If the string is used in =define-key= or =lookup-key=, this numeric code is translated into the equivalent meta character. See [[2.3.3 Character Type]].

Strings cannot hold characters that have the hyper, super, or alt modifiers.


*** 2.3.8.4 Text Properties in Strings
      :PROPERTIES:
      :CUSTOM_ID: text-properties-in-strings
      :END:

A string can hold properties for the characters it contains, in addition to the characters themselves. This enables programs that copy text between strings and buffers to copy the text's properties with no special effort. See [[file:32.Text.org::32.19 Text Properties][32.19 Text Properties]], for an explanation of what text properties mean. Strings with text properties use a special read and print syntax:

#+BEGIN_SRC elisp
#("characters" property-data...)
#+END_SRC

where property-data consists of zero or more elements, in groups of three as follows:

#+BEGIN_SRC elisp
beg end plist
#+END_SRC

The elements beg and end are integers, and together specify a range of indices in the string; plist is the property list for that range. For example,

#+BEGIN_SRC elisp
#("foo bar" 0 3 (face bold) 3 4 nil 4 7 (face italic))
#+END_SRC

#+RESULTS:
: foo bar
# 得到:

represents a string whose textual contents are 'foo bar', in which the first three characters have a =face= property with value =bold=, and the last three have a =face= property with value =italic=. (The fourth character has no text properties, so its property list is =nil=. It is not actually necessary to mention ranges with =nil= as the property list, since any characters not mentioned in any range will default to having no properties.)

** 2.3.9 Vector Type
     :PROPERTIES:
     :CUSTOM_ID: vector-type
     :END:

A vector is a one-dimensional array of elements of any type. It takes a constant amount of time to access any element of a vector. (In a list, the access time of an element is proportional to the distance of the element from the beginning of the list.)

The printed representation of a vector consists of a left square bracket, the elements, and a right square bracket. This is also the read syntax. Like numbers and strings, vectors are considered constants for evaluation.

#+BEGIN_SRC elisp
         [1 "two" (three)]      ; A vector of three elements.
              ⇒ [1 "two" (three)]
#+END_SRC

#+begin_src emacs-lisp :tangle yes
[1 "two" (three)]
#+end_src

#+RESULTS:
: [1 "two" (three)]

See [[file:06.Sequences-Arrays-and-Vectors.org::6.4 Vectors][6.4 Vectors]], for functions that work with vectors.

** 2.3.10 Char-Table Type
     :PROPERTIES:
     :CUSTOM_ID: char-table-type
     :END:

A char-table is a one-dimensional array of elements of any type, indexed by character codes. Char-tables have certain extra features to make them more useful for many jobs that involve assigning information to character codes---for example, a char-table can have a parent to inherit from, a default value, and a small number of extra slots to use for special purposes. A char-table can also specify a single value for a whole character set.

The printed representation of a char-table is like a vector except that there is an extra '#\^' at the beginning.[[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#fn-1][1]]

See [[file:06.Sequences-Arrays-and-Vectors.org::6.6 Char-Tables][6.6 Char-Tablle]] for special functions to operate on char-tables. Uses of char-tables include:

1) Case tables (see [[file:04.String-and-Characters.org::4.9 The Case Table][4.9 The Case Table]]).\\
2) Character category tables (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Categories][Categories]]).\\
3) Display tables (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Display-Tables][Display Tables]]).\\
4) Syntax tables (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Tables][Syntax Tables]]).

** 2.3.11 Bool-Vector Type
     :PROPERTIES:
     :CUSTOM_ID: bool-vector-type
     :END:

A bool-vector is a one-dimensional array whose elements must be =t= or =nil=.

The printed representation of a bool-vector is like a string, except that it begins with '#&' followed by the length. The string constant that follows actually specifies the contents of the bool-vector as a bitmap---each character in the string contains 8 bits, which specify the next 8 elements of the bool-vector (1 stands for =t=, and 0 for =nil=). The least significant bits of the character correspond to the lowest indices in the bool-vector.
# 问题? 没有太看明白是怎么回事? 
#+BEGIN_SRC elisp
         (make-bool-vector 3 t)
              ⇒ #&3"^G"
         (make-bool-vector 3 nil)
              ⇒ #&3"^@"
#+END_SRC

These results make sense, because the binary code for 'C-g' is 111 and 'C-@' is the character with code 0.

If the length is not a multiple of 8, the printed representation shows extra elements, but these extras really make no difference. For instance, in the next example, the two bool-vectors are equal, because only the first 3 bits are used:

#+BEGIN_SRC elisp
         (equal #&3"\377" #&3"\007")
              ⇒ t
#+END_SRC

** 2.3.12 Hash Table Type
     :PROPERTIES:
     :CUSTOM_ID: hash-table-type
     :END:

A hash table is a very fast kind of lookup table, somewhat like an alist in that it maps keys to corresponding values, but much faster. The printed representation of a hash table specifies its properties and contents, like this:

#+BEGIN_SRC elisp
         (make-hash-table)
              ⇒ #s(hash-table size 65 test eql rehash-size 1.5
                                      rehash-threshold 0.8125 data ())
#+END_SRC

#+begin_src emacs-lisp :tangle yes
(make-hash-table)
#+end_src

#+RESULTS:
: #s(hash-table size 65 test eql rehash-size 1.5 rehash-threshold 0.8125 data ())

See [[file:08.Hash-Tables.org][08.Hash-Table]], for more information about hash tables.

** 2.3.13 Function Type
     :PROPERTIES:
     :CUSTOM_ID: function-type
     :END:

Lisp functions are executable code, just like functions in other programming languages. In Lisp, unlike most languages, functions are also Lisp objects. A non-compiled function in Lisp is a lambda expression: that is, a list whose first element is the symbol =lambda= (see [[file:13.Functions.org::13.2 Lambda Expressions][13.2 Lambda Expressions]]).

In most programming languages, it is impossible to have a function without a name. In Lisp, a function has no ~intrinsic~ name. A lambda expression can be called as a function even though it has no name; to emphasize this, we also call it an anonymous function (see [[file:13.Functions.org::13.7 Anonymous Functions][13.7 Anonymous Functions]]). A named function in Lisp is just a symbol with a valid function in its function cell (see [[file:13.Functions.org::13.4 Defining Functions][13.4 Defining Functions]]).

Most of the time, functions are called when their names are written in Lisp expressions in Lisp programs. However, you can construct or obtain a function object at run time and then call it with the primitive functions =funcall= and =apply=. See [[file:13.Functions.org::13.5 Calling Functions][13.5 Calling Functions]].

** 2.3.14 Macro Type
     :PROPERTIES:
     :CUSTOM_ID: macro-type
     :END:

A Lisp macro is a user-defined construct that extends the Lisp language. It is represented as an object much like a function, but with different argument-passing semantics. A Lisp macro has the form of a list whose first element is the symbol =macro= and whose cdr is a Lisp function object, including the =lambda= symbol.

Lisp macro objects are usually defined with the built-in =defmacro= macro, but any list that begins with =macro= is a macro as far as Emacs is concerned. See [[file:14.Macros.org][14.Macros]], for an explanation of how to write a macro.

*Warning*: Lisp macros and keyboard macros (see [[file:21.Command-Loop.org::21.16 Keyboard Macros][21.16 Keyboard Macros]]) are entirely different things. When we use the word "macro" without qualification, we mean a Lisp macro, not a keyboard macro.

** 2.3.15 Primitive Function Type
     :PROPERTIES:
     :CUSTOM_ID: primitive-function-type
     :END:

A primitive function is a function callable from Lisp but written in the C programming language. Primitive functions are also called subrs or built-in functions.
# 短评: subrs如此缩写, 匪夷所思
(The word "subr" is derived from "subroutine".) Most primitive functions evaluate all their arguments when they are called. A primitive function that does not evaluate all its arguments is called a special form (see [[file:10.Evaluation.org::10.2 Kinds of Forms][10.2 Kinds of Forms]]).

It does not matter to the caller of a function whether the function is primitive. However, this does matter if you try to redefine a primitive with a function written in Lisp. The reason is that the primitive function may be called directly from C code. Calls to the redefined function from Lisp will use the new definition, but calls from C code may still use the built-in definition. Therefore, *we discourage redefinition of primitive functions*.

The term function refers to all Emacs functions, whether written in Lisp or C. See [[2.3.13 Function Type]]
 for information about the functions written in Lisp.

Primitive functions have no read syntax and print in hash notation with the name of the subroutine.

#+BEGIN_SRC elisp
         (symbol-function 'car)          ; Access the function cell
                                         ;   of the symbol.
              ⇒ #<subr car>
         (subrp (symbol-function 'car))  ; Is this a primitive function?
              ⇒ t                       ; Yes.
#+END_SRC
#+begin_src emacs-lisp :tangle yes
(symbol-function 'current-time)
#+end_src

** 2.3.16 Byte-Code Function Type
     :PROPERTIES:
     :CUSTOM_ID: byte-code-function-type
     :END:

Byte-code function objects are produced by byte-compiling Lisp code (see [[file:17.Byte Compilation.org][17 Byte Compilation]]  ). Internally, a byte-code function object is much like a vector; however, the evaluator handles this data type specially when it appears in a function call. See [[file:17.Byte Compilation.org::17.7 Byte-Code Function Objects][17.7 Byte-Code Function Objects]].

The printed representation and read syntax for a byte-code function object is like that for a vector, with an additional '#' before the opening '['.

** 2.3.17 Record Type
     :PROPERTIES:
     :CUSTOM_ID: record-type
     :END:

A record is much like a =vector=. However, the first element is used to hold its type as returned by =type-of=. The purpose of records is to allow programmers to create objects with new types that are not built into Emacs.

See [[file:07.Records.org][07.Records]] , for functions that work with records.


** 2.3.18 Type Descriptors
     :PROPERTIES:
     :CUSTOM_ID: type-descriptors
     :END:

A type descriptor is a =record= which holds information about a type. Slot 1 in the record must be a symbol naming the type, and =type-of= relies on this to return the type of =record= objects. No other type descriptor slot is used by Emacs; they are free for use by Lisp extensions.

An example of a type descriptor is any instance of =cl-structure-class=.

** 2.3.19 Autoload Type
     :PROPERTIES:
     :CUSTOM_ID: autoload-type
     :END:

An autoload object is a list whose first element is the symbol =autoload=. It is stored as the function definition of a symbol, where it serves as a placeholder for the real definition. The autoload object says that the real definition is found in a file of Lisp code that should be loaded when necessary. It contains the name of the file, plus some other information about the real definition.

After the file has been loaded, the symbol should have a new function definition that is not an autoload object. The new definition is then called as if it had been there to begin with. From the user's point of view, the function call works as expected, using the function definition in the loaded file.

An autoload object is usually created with the function =autoload=, which stores the object in the function cell of a symbol. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Autoload][Autoload]], for more details.


** 2.3.20 Finalizer Type
     :PROPERTIES:
     :CUSTOM_ID: finalizer-type
     :END:

A finalizer object helps Lisp code clean up after objects that are no longer needed. A finalizer holds a Lisp function object. When a finalizer object becomes unreachable after a garbage collection pass, Emacs calls the finalizer's associated function object. When deciding whether a finalizer is reachable, Emacs does not count references from finalizer objects themselves, allowing you to use finalizers without having to worry about accidentally capturing references to finalized objects themselves.

Errors in finalizers are printed to =*Messages*=. Emacs runs a given finalizer object's associated function exactly once, even if that function fails.

--- Function: *make-finalizer* function

#+BEGIN_QUOTE
  Make a finalizer that will run function. function will be called after garbage collection when the returned finalizer object becomes unreachable. If the finalizer object is reachable only through references from finalizer objects, it does not count as reachable for the purpose of deciding whether to run function. function will be run once per finalizer object.
#+END_QUOTE

* 2.4 Editing Types
    :PROPERTIES:
    :CUSTOM_ID: editing-types
    :END:

The types in the previous section are used for general programming purposes, and most of them are common to most Lisp dialects. Emacs Lisp provides several additional data types for purposes connected with editing.
# 洞见: 此处是elisp有意思的之处.
1) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Type][Buffer Type]]: The basic object of editing.
2) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Marker-Type][Marker Type]]: A position in a buffer.
3) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Type][Window Type]]: Buffers are displayed in windows.
4) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Type][Frame Type]]: Windows subdivide frames.
5) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Terminal-Type][Terminal Type]]: A terminal device displays frames.
6) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configuration-Type][Window Configuration Type]]: Recording the way a frame is subdivided.
7) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configuration-Type][Frame Configuration Type]]: Recording the status of all frames.
8) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Process-Type][Process Type]]: A subprocess of Emacs running on the underlying OS.
9) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Thread-Type][Thread Type]]: A thread of Emacs Lisp execution.
10) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mutex-Type][Mutex Type]]: An exclusive lock for thread synchronization.
11) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Condition-Variable-Type][Condition Variable Type]]: Condition variable for thread synchronization.
12) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Stream-Type][Stream Type]]: Receive or send characters.
13) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymap-Type][Keymap Type]]: What function a keystroke invokes.
14) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlay-Type][Overlay Type]]: How an overlay is represented.
15) [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Font-Type][Font Type]]: Fonts for displaying text.

** 2.4.1 Buffer Type
     :PROPERTIES:
     :CUSTOM_ID: buffer-type
     :END:

A buffer is an object that holds text that can be edited (see [[file:27.Buffer.org][27.Buffers]]). Most buffers hold the contents of a disk file (see [[file:25.Files.org][25.Files]]) so they can be edited, but some are used for other purposes. Most buffers are also meant to be seen by the user, and therefore displayed, at some time, in a window (see [[file:28.Windows.org][28.Windows]]). But a buffer need not be displayed in any window. Each buffer has a designated position called point (see [[file:30.Position.org][30.Positions]]); most editing commands act on the contents of the current buffer in the neighborhood of point. At any time, one buffer is the current buffer.

The contents of a buffer are much like a string,
# 洞见: 学python第一天, 教程里就开宗明义阐明这一点该有多好呢.
but buffers are not used like strings in Emacs Lisp, and the available operations are different. For example, you can insert text efficiently into an existing buffer, altering the buffer's contents, whereas inserting text into a string requires concatenating substrings, and the result is an entirely new string object.
# 洞见: 此处的解说实在是愚笨得可爱.

Many of the standard Emacs functions manipulate or test the characters in the current buffer; a whole chapter in this manual is devoted to describing these functions (see [[file:32.Text.org][32.Text]]).

Several other data structures are associated with each buffer:

1) a local syntax [[file:35.Syntax-Tables.org][35.Syntax-Tables]]);\\
2) a local keymap (see [[file:22.Keymaps.org][22.Keymaps]]); and,\\
3) a list of buffer-local variable bindings (see [[file:12.Variables.org][12.11.Buffer-Local Variables]]).\\
4) overlays (see [[file:39.Emacs-Display.org][39.9.Overlays]]).\\
5) text properties for the text in the buffer (see [[file:32.Text.org][32.19.Text Properties]]).

The local keymap and variable list contain entries that individually override global bindings or values. These are used to customize the behavior of programs in different buffers, without actually changing the programs.

A buffer may be indirect, which means it shares the text of another buffer, but presents it differently. See [[file:27.Buffer.org::27.11 Indirect Buffers][27.11 Indirect Buffers]].

Buffers have no read syntax. They print in hash notation, showing the buffer name.

#+BEGIN_SRC elisp
(current-buffer)
#+END_SRC

#+RESULTS:
: #<buffer 02.Lisp-Data-Types.org>

** 2.4.2 Marker Type
     :PROPERTIES:
     :CUSTOM_ID: marker-type
     :END:

A marker denotes a position in a specific buffer. Markers therefore have two components: one for the buffer, and one for the position. Changes in the buffer's text automatically relocate the position value as necessary to ensure that the marker always points between the same two characters in the buffer.

Markers have no read syntax. They print in hash notation, giving the current character position and the name of the buffer.

#+BEGIN_SRC elisp
(point-marker)
#+END_SRC

#+RESULTS:
: #<marker at 66341 in 02.Lisp-Data-Types.org>
# 得到: marker是两点, 意料之中, 也是意料之外.

See [[file:31.Marker.org][31.Marker]], for information on how to test, create, copy, and move markers.

** 2.4.3 Window Type
     :PROPERTIES:
     :CUSTOM_ID: window-type
     :END:

A window describes the portion of the terminal screen that Emacs uses to display a buffer. Every window has one associated buffer, whose contents appear in the window. By contrast, a given buffer may appear in one window, no window, or several windows.

Though many windows may exist simultaneously, at any time one window is designated the selected window. This is the window where the cursor is (usually) displayed when Emacs is ready for a command. The selected window usually displays the current buffer (see [[file:27.Buffer.org::27.2 The Current Buffer][27.2 The Current Buffer]]), but this is not necessarily the case.

Windows are grouped on the screen into frames; each window belongs to one and only one frame. See [[2.4.4 Frame Type]].

Windows have no read syntax. They print in hash notation, giving the window number and the name of the buffer being displayed. The window numbers exist to identify windows uniquely, since the buffer displayed in any given window can change frequently.

#+BEGIN_SRC elisp
(selected-window)
#+END_SRC

#+RESULTS:
: #<window 112 on 02.Lisp-Data-Types.org>

See [[file:28.Windows.org][28.Windows]], for a description of the functions that work on windows.

** 2.4.4 Frame Type
     :PROPERTIES:
     :CUSTOM_ID: frame-type
     :END:

A frame is a screen area that contains one or more Emacs windows; we also use the term "frame" to refer to the Lisp object that Emacs uses to refer to the screen area.

Frames have no read syntax. They print in hash notation, giving the frame's title, plus its address in core (useful to identify the frame uniquely).

#+BEGIN_SRC elisp
(selected-frame)
#+END_SRC

#+RESULTS:
: #<frame 02.Lisp-Data-Types.org – Doom Emacs 0x11b9c30>

See [[file:29.Frame.org][29.Frames]], for a description of the functions that work on frames.

** 2.4.5 Terminal Type
     :PROPERTIES:
     :CUSTOM_ID: terminal-type
     :END:

A terminal is a device capable of displaying one or more Emacs frames (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Type][Frame Type]]).

Terminals have no read syntax. They print in hash notation giving the terminal's ordinal number and its TTY device file name.

#+BEGIN_SRC elisp
(get-device-terminal nil)
#+END_SRC

#+RESULTS:
: #<terminal 1 on :0>

** 2.4.6 Window Configuration Type
     :PROPERTIES:
     :CUSTOM_ID: window-configuration-type
     :END:

A window configuration stores information about the positions, sizes, and contents of the windows in a frame, so you can recreate the same arrangement of windows later.

Window configurations do not have a read syntax; their print syntax looks like '#'. See [[file:28.Windows.org::28.26 Window Configurations][28.26 Window Configurations]], for a description of several functions related to window configurations.

** 2.4.7 Frame Configuration Type
     :PROPERTIES:
     :CUSTOM_ID: frame-configuration-type
     :END:

A frame configuration stores information about the positions, sizes, and contents of the windows in all frames. It is not a primitive type---it is actually a list whose car is =frame-configuration= and whose cdr is an alist. Each alist element describes one frame, which appears as the car of that element.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configurations][29.13.Frame Configurations]], for a description of several functions related to frame configurations.

** 2.4.8 Process Type
     :PROPERTIES:
     :CUSTOM_ID: process-type
     :END:

The word process usually means a running program. Emacs itself runs in a process of this sort. However, in Emacs Lisp, a process is a Lisp object that designates a subprocess created by the Emacs process. Programs such as shells, GDB, ftp, and compilers, running in subprocesses of Emacs, extend the capabilities of Emacs. An Emacs subprocess takes textual input from Emacs and returns textual output to Emacs for further manipulation. Emacs can also send signals to the subprocess.

Process objects have no read syntax. They print in hash notation, giving the name of the process:

#+BEGIN_SRC elisp
(process-list)
#+END_SRC

#+RESULTS:
| fanyi.youdao.com | server |

See [[file:38.Processes.org][38.Processes]],for information about functions that create, delete, return information about, send input or signals to, and receive output from processes.

** 2.4.9 Thread Type
     :PROPERTIES:
     :CUSTOM_ID: thread-type
     :END:

A thread in Emacs represents a separate thread of Emacs Lisp execution. It runs its own Lisp program, has its own current buffer, and can have subprocesses locked to it, i.e. subprocesses whose output only this thread can accept. [[file:37.Thread.org][37.Threads]].

Thread objects have no read syntax. They print in hash notation, giving the name of the thread (if it has been given a name) or its address in core:

#+BEGIN_SRC elisp
(all-threads)
#+END_SRC

#+RESULTS:
| #<thread 0x9fe8e0> |

** 2.4.10 Mutex Type
     :PROPERTIES:
     :CUSTOM_ID: mutex-type
     :END:

A mutex is an exclusive lock that threads can own and disown, in order to synchronize between them. See [[file:37.Thread.org::37.2 Mutexes][37.2 Mutexes]].

Mutex objects have no read syntax. They print in hash notation, giving the name of the mutex (if it has been given a name) or its address in core:

#+BEGIN_SRC elisp
         (make-mutex "my-mutex")
             ⇒ #<mutex my-mutex>
         (make-mutex)
             ⇒ #<mutex 01c7e4e0>
#+END_SRC

** 2.4.11 Condition Variable Type
     :PROPERTIES:
     :CUSTOM_ID: condition-variable-type
     :END:

A condition variable is a device for a more complex thread synchronization than the one supported by a mutex. A thread can wait on a condition variable, to be woken up when some other thread notifies the condition.

Condition variable objects have no read syntax. They print in hash notation, giving the name of the condition variable (if it has been given a name) or its address in core:

#+BEGIN_SRC elisp
(make-condition-variable (make-mutex))
#+END_SRC

#+RESULTS:
: #<condvar 0x77bee60>

** 2.4.12 Stream Type
     :PROPERTIES:
     :CUSTOM_ID: stream-type
     :END:

A stream is an object that can be used as a source or sink for characters---either to supply characters for input or to accept them as output. Many different types can be used this way: markers, buffers, strings, and functions. Most often, input streams (character sources) obtain characters from the keyboard, a buffer, or a file, and output streams (character sinks) send characters to a buffer, such as a /Help/ buffer, or to the echo area.

The object =nil=, in addition to its other meanings, may be used as a stream. It stands for the value of the variable =standard-input= or =standard-output=. Also, the object =t= as a stream specifies input using the minibuffer (see [[file:20.Minibuffers.org]]  or output in the echo area (see [[file:39.Emacs-Display.org::39.4 The Echo Area][39.4 The Echo Area]] .

Streams have no special printed representation or read syntax, and print as whatever primitive type they are.

See [[file:19.Reading-and-Printing-Lisp-Objects.org][19.Read and Print]], for a description of functions related to streams, including parsing and printing functions.

** 2.4.13 Keymap Type
     :PROPERTIES:
     :CUSTOM_ID: keymap-type
     :END:

A keymap maps keys typed by the user to commands. This mapping controls how the user's command input is executed. A keymap is actually a list whose car is the symbol =keymap=.

See [[file:22.Keymaps.org][22.Keymaps]], for information about creating keymaps, handling prefix keys, local as well as global keymaps, and changing key bindings.

** 2.4.14 Overlay Type
     :PROPERTIES:
     :CUSTOM_ID: overlay-type
     :END:

An overlay specifies properties that apply to a part of a buffer. Each overlay applies to a specified range of the buffer, and contains a property list (a list whose elements are alternating property names and values). Overlay properties are used to present parts of the buffer temporarily in a different display style. Overlays have no read syntax, and print in hash notation, giving the buffer name and range of positions.

See [[file:39.Emacs-Display.org::39.9 Overlays][39.9 Overlays]], for information on how you can create and use overlays.

** 2.4.15 Font Type
     :PROPERTIES:
     :CUSTOM_ID: font-type
     :END:

A font specifies how to display text on a graphical terminal. There are actually three separate font types---font objects, font specs, and font entities---each of which has slightly different properties. None of them have a read syntax; their print syntax looks like '#', '#', and '#' respectively. See [[file:39.Emacs-Display.org::39.12.12 Low-Level Font Representation][39.12.12 Low-Level Font Representation]], for a description of these Lisp objects.
 
* 2.5 Read Syntax for Circular Objects
    :PROPERTIES:
    :CUSTOM_ID: read-syntax-for-circular-objects
    :END:

To represent shared or circular structures within a complex of Lisp objects, you can use the reader constructs '#n=' and '#n#'.

Use =#n=== before an object to label it for later reference; subsequently, you can use =#n#= to refer the same object in another place. Here, n is some integer. For example, here is how to make a list in which the first element recurs as the third element:

#+BEGIN_SRC elisp
(#1=(a) b #1#)
#+END_SRC

This differs from ordinary syntax such as this

#+BEGIN_SRC elisp
((a) b (a))
#+END_SRC

which would result in a list whose first and third elements look alike but are not the same Lisp object. This shows the difference:

#+BEGIN_SRC elisp
         (prog1 nil
           (setq x '(#1=(a) b #1#)))
         (eq (nth 0 x) (nth 2 x))
              ⇒ t
         (setq x '((a) b (a)))
         (eq (nth 0 x) (nth 2 x))
              ⇒ nil
#+END_SRC

You can also use the same syntax to make a circular structure, which appears as an element within itself. Here is an example:

#+BEGIN_SRC elisp
         #1=(a #1#)
#+END_SRC

This makes a list whose second element is the list itself. Here's how you can see that it really works:

#+BEGIN_SRC elisp
         (prog1 nil
           (setq x '#1=(a #1#)))
         (eq x (cadr x))
              ⇒ t
#+END_SRC

The Lisp printer can produce this syntax to record circular and shared structure in a Lisp object, if you bind the variable =print-circle= to a =non-nil= value. See [[file:19.Reading-and-Printing-Lisp-Objects.org::19.6 Variables Affecting Output][19.6 Variables Affecting Output]].

* 2.6 Type Predicates
    :PROPERTIES:
    :CUSTOM_ID: type-predicates
    :END:

The Emacs Lisp interpreter itself does not perform type checking on the actual arguments passed to functions when they are called. It could not do so, since function arguments in Lisp do not have declared data types, as they do in other programming languages. It is therefore up to the individual function to test whether each actual argument belongs to a type that the function can use.

All built-in functions do check the types of their actual arguments when appropriate, and signal a =wrong-type-argument= error if an argument is of the wrong type. For example, here is what happens if you pass an argument to =+= that it cannot handle:

#+BEGIN_SRC elisp
(+ 2 'a)
              error--> Wrong type argument: number-or-marker-p, a
#+END_SRC

If you want your program to handle different types differently, you must do explicit type checking. The most common way to check the type of an object is to call a type predicate function. Emacs has a type predicate for each type, as well as some predicates for combinations of types.

A type predicate function takes one argument; it returns =t= if the argument belongs to the appropriate type, and =nil= otherwise. Following a general Lisp convention for predicate functions, most type predicates' names end with 'p'.

Here is an example which uses the predicates =listp= to check for a list and =symbolp= to check for a symbol.

#+BEGIN_SRC elisp
(defun add-on (x)
  (cond ((symbolp x)
         ;; If X is a symbol, put it on LIST.
         (setq list (cons x list)))
        ((listp x)
         ;; If X is a list, add its elements to LIST.
         (setq list (append x list)))
        (t
         ;; We handle only symbols and lists.
         (error "Invalid argument %s in add-on" x))))
#+END_SRC

Here is a table of predefined type predicates, in alphabetical order, with references to further information.

#+name: 类型检查表格

1) =atom=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][atom]].

2) =arrayp=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Array-Functions][arrayp]].

3) =bool-vector-p=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Bool_002dVectors][bool-vector-p]].

4) =booleanp=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#nil-and-t][booleanp]].

5) =bufferp=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Buffer-Basics][bufferp]].

6) =byte-code-function-p=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Byte_002dCode-Type][byte-code-function-p]].

7) =case-table-p=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Case-Tables][case-table-p]].

8) =char-or-string-p=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-for-Strings][char-or-string-p]].

9) =char-table-p=
   See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Char_002dTables][char-table-p]].

10) =commandp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Interactive-Call][commandp]].

11) =condition-variable-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Condition-Variables][condition-variable-p]].

12) =consp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][consp]].

13) =custom-variable-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Variable-Definitions][custom-variable-p]].

14) =floatp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Numbers][floatp]].

15) =fontp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Low_002dLevel-Font][Low-Level Font]].

16) =frame-configuration-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frame-Configurations][frame-configuration-p]].

17) =frame-live-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Frames][frame-live-p]].

18) =framep=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Frames][framep]].

19) =functionp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Functions][functionp]].

20) =hash-table-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Other-Hash][hash-table-p]].

21) =integer-or-marker-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Markers][integer-or-marker-p]].

22) =integerp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Numbers][integerp]].

23) =keymapp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Keymaps][keymapp]].

24) =keywordp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Constant-Variables][Constant Variables]].

25) =listp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][listp]].

26) =markerp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Markers][markerp]].

27) =mutexp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mutexes][mutexp]].

28) =nlistp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#List_002drelated-Predicates][nlistp]].

29) =number-or-marker-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Markers][number-or-marker-p]].

30) =numberp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Numbers][numberp]].

31) =overlayp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Overlays][overlayp]].

32) =processp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Processes][processp]].

33) =recordp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Record-Type][recordp]].

34) =sequencep=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Sequence-Functions][sequencep]].

35) =string-or-null-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-for-Strings][string-or-null-p]].

36) =stringp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-for-Strings][stringp]].

37) =subrp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Function-Cells][subrp]].

38) =symbolp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Symbols][symbolp]].

39) =syntax-table-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Syntax-Tables][syntax-table-p]].

40) =threadp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Thread-Functions][threadp]].

41) =vectorp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Vectors][vectorp]].

42) =wholenump=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Predicates-on-Numbers][wholenump]].

43) =window-configuration-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Window-Configurations][window-configuration-p]].

44) =window-live-p=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Deleting-Windows][window-live-p]].

45) =windowp=
    See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Basic-Windows][windowp]].

The most general way to check the type of an object is to call the function =type-of=. Recall that each object belongs to one and only one primitive type; =type-of= tells you which one (see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Lisp-Data-Types][Lisp Data Types]]). But =type-of= knows nothing about non-primitive types. In most cases, it is more convenient to use type predicates than =type-of=.

--- Function: *type-of* object

#+BEGIN_QUOTE
  This function returns a symbol naming the primitive type of object. The value is one of the symbols =bool-vector=, =buffer=, =char-table=, =compiled-function=, =condition-variable=, =cons=, =finalizer=, =float=, =font-entity=, =font-object=, =font-spec=, =frame=, =hash-table=, =integer=, =marker=, =mutex=, =overlay=, =process=, =string=, =subr=, =symbol=, =thread=, =vector=, =window=, or =window-configuration=. However, if object is a record, the type specified by its first slot is returned; [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Records][Records]].

  #+BEGIN_SRC elisp
                (type-of 1)
                     ⇒ integer
                (type-of 'nil)
                     ⇒ symbol
                (type-of '())    ; () is nil.
                     ⇒ symbol
                (type-of '(x))
                     ⇒ cons
                (type-of (record 'foo))
                     ⇒ foo
  #+END_SRC
#+END_QUOTE

* 2.7 Equality Predicates
    :PROPERTIES:
    :CUSTOM_ID: equality-predicates
    :END:

Here we describe functions that test for equality between two objects. Other functions test equality of contents between objects of specific types, e.g., strings. For these predicates, see the appropriate chapter describing the data type.

--- Function: *eq* object1 object2


  This function returns =t= if object1 and object2 are the same object, and =nil= otherwise.

  If object1 and object2 are integers with the same value, they are considered to be the same object (i.e., =eq= returns =t=). If object1 and object2 are symbols with the same name, they are normally the same object---but see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Symbols][Creating Symbols]] for exceptions. For other types (e.g., lists, vectors, strings), two arguments with the same contents or elements are not necessarily =eq= to each other: they are =eq= only if they are the same object, meaning that a change in the contents of one will be reflected by the same change in the contents of the other.

  #+BEGIN_SRC elisp
(eq 'foo 'foo)
⇒ t
(eq 456 456)
⇒ t

(eq "asdf" "asdf")
⇒ nil

(eq "" "")
⇒ t
;; This exception occurs because Emacs Lisp
;; makes just one multibyte empty string, to save space.

(eq '(1 (2 (3))) '(1 (2 (3))))
⇒ nil

(setq foo '(1 (2 (3))))
⇒ (1 (2 (3)))
(eq foo foo)
⇒ t
(eq foo '(1 (2 (3))))
⇒ nil

(eq [(1 2) 3] [(1 2) 3])
⇒ nil

(eq (point-marker) (point-marker))
⇒ nil
  #+END_SRC

  The =make-symbol= function returns an uninterned symbol, distinct from the symbol that is used if you write the name in a Lisp expression. Distinct symbols with the same name are not =eq=. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Creating-Symbols][Creating Symbols]].

  #+BEGIN_SRC elisp
                (eq (make-symbol "foo") 'foo)
                     ⇒ nil
  #+END_SRC

  The Emacs Lisp byte compiler may collapse identical literal objects, such as literal strings, into references to the same object, with the effect that the byte-compiled code will compare such objects as =eq=, while the interpreted version of the same code will not. Therefore, your code should never rely on objects with the same literal contents being either =eq= or not =eq=, it should instead use functions that compare object contents such as =equal=, described below. Similarly, your code should not modify literal objects (e.g., put text properties on literal strings), since doing that might affect other literal objects of the same contents, if the byte compiler collapses them.


--- Function: *equal* object1 object2


  This function returns =t= if object1 and object2 have equal components, and =nil= otherwise. Whereas =eq= tests if its arguments are the same object, =equal= looks inside nonidentical arguments to see if their elements or contents are the same. So, if two objects are =eq=, they are =equal=, but the converse is not always true.
# 短评: 这是python中的is

  #+BEGIN_SRC elisp
(equal 'foo 'foo)
⇒ t
(equal 456 456)
⇒ t

(equal "asdf" "asdf")
⇒ t
(eq "asdf" "asdf")
⇒ nil

(equal '(1 (2 (3))) '(1 (2 (3))))
⇒ t
(eq '(1 (2 (3))) '(1 (2 (3))))
⇒ nil

(equal [(1 2) 3] [(1 2) 3])
⇒ t
(eq [(1 2) 3] [(1 2) 3])
⇒ nil

(equal (point-marker) (point-marker))
⇒ t

(eq (point-marker) (point-marker))
⇒ nil
  #+END_SRC

  Comparison of strings is case-sensitive, but does not take account of text properties---it compares only the characters in the strings. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]]. Use =equal-including-properties= to also compare text properties. For technical reasons, a unibyte string and a multibyte string are =equal= if and only if they contain the same sequence of character codes and all these codes are in the range 0 through 127 (ASCII).

  #+BEGIN_SRC elisp
(equal "asdf" "ASDF")
                     ⇒ nil
  #+END_SRC

  However, two distinct buffers are never considered =equal=, even if their textual contents are the same.


The test for equality is implemented recursively; for example, given two cons cells x and y, =(equal=x y=)= returns =t= if and only if both the expressions below return =t=:

#+BEGIN_SRC elisp
(equal (car x) (car y))
(equal (cdr x) (cdr y))
#+END_SRC

Because of this recursive method, circular lists may therefore cause infinite recursion (leading to an error).

--- Function: *equal-including-properties* object1 object2


  This function behaves like =equal= in all cases but also requires that for two strings to be equal, they have the same text properties.

  #+BEGIN_SRC elisp
(equal "asdf" (propertize "asdf" 'asdf t))
⇒ t
(equal-including-properties "asdf"
                            (propertize "asdf" 'asdf t))
⇒ nil
  #+END_SRC
* 总结
  终于看完了所有的基本类型．
