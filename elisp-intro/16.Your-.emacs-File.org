#+TITLE: 16.Your-.emacs-File
* 16 Your .emacs File
   :PROPERTIES:
   :CUSTOM_ID: your-.emacs-file
   :CLASS: chapter
   :END:

 “You don't have to like Emacs to like it”---this seemingly paradoxical statement is the secret of GNU Emacs. The plain, out-of-the-box Emacs is a generic tool. Most people who use it customize it to suit themselves.

GNU Emacs is mostly written in Emacs Lisp; this means that by writing expressions in Emacs Lisp you can change or extend Emacs.

1) [[#Default-Configuration][Default Configuration]]
2) [[#Site_002dwide-Init][Site-wide Init]]: You can write site-wide init files.
3) [[#defcustom][defcustom]]: Emacs will write code for you.
4) [[#Beginning-init-File][Beginning init File]]: How to write a .emacs init file.
5) [[#Text-and-Auto_002dfill][Text and Auto-fill]]: Automatically wrap lines.
6) [[#Mail-Aliases][Mail Aliases]]: Use abbreviations for email addresses.
7) [[#Indent-Tabs-Mode][Indent Tabs Mode]]: Don't use tabs with TeX
8) [[#Keybindings][Keybindings]]: Create some personal keybindings.
9) [[#Keymaps][Keymaps]]: More about key binding.
10) [[#Loading-Files][Loading Files]]: Load (i.e., evaluate) files automatically.
11) [[#Autoload][Autoload]]: Make functions available.
12) [[#Simple-Extension][Simple Extension]]: Define a function; bind it to a key.
13) [[#X11-Colors][X11 Colors]]: Colors in X.
14) [[#Miscellaneous][Miscellaneous]]
15) [[#Mode-Line][Mode Line]]: How to customize your mode line.



* Emacs's Default Configuration
    :PROPERTIES:
    :CUSTOM_ID: emacss-default-configuration
    :CLASS: unnumberedsec
    :END:

There are those who appreciate Emacs's default configuration. After all, Emacs starts you in C mode when you edit a C file, starts you in Fortran mode when you edit a Fortran file, and starts you in Fundamental mode when you edit an unadorned file. This all makes sense, if you do not know who is going to use Emacs. Who knows what a person hopes to do with an unadorned file? Fundamental mode is the right default for such a file, just as C mode is the right default for editing C code. (Enough programming languages have syntaxes that enable them to share or nearly share features, so C mode is now provided by CC mode, the C Collection.)

But when you do know who is going to use Emacs---you, yourself---then it makes sense to customize Emacs.

For example, I seldom want Fundamental mode when I edit an otherwise undistinguished file; I want Text mode. This is why I customize Emacs: so it suits me.

You can customize and extend Emacs by writing or adapting a ~/.emacs file. This is your personal initialization file; its contents, written in Emacs Lisp, tell Emacs what to do.[[#fn-16][^{16}]]

A ~/.emacs file contains Emacs Lisp code. You can write this code yourself; or you can use Emacs's =customize= feature to write the code for you. You can combine your own expressions and auto-written Customize expressions in your .emacs file.

(I myself prefer to write my own expressions, except for those, particularly fonts, that I find easier to manipulate using the =customize= command. I combine the two methods.)

Most of this chapter is about writing expressions yourself. It describes a simple .emacs file; for more information, see [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Init-File][The Init File]], and [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Init-File][The Init File]].


Next: [[#defcustom][defcustom]], Previous: [[#Default-Configuration][Default Configuration]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.1 Site-wide Initialization Files
    :PROPERTIES:
    :CUSTOM_ID: site-wide-initialization-files
    :CLASS: section
    :END:

In addition to your personal initialization file, Emacs automatically loads various site-wide initialization files, if they exist. These have the same form as your .emacs file, but are loaded by everyone.

Two site-wide initialization files, site-load.el and site-init.el, are loaded into Emacs and then dumped if a dumped version of Emacs is created, as is most common. (Dumped copies of Emacs load more quickly. However, once a file is loaded and dumped, a change to it does not lead to a change in Emacs unless you load it yourself or re-dump Emacs. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Building-Emacs][Building Emacs]], and the INSTALL file.)

Three other site-wide initialization files are loaded automatically each time you start Emacs, if they exist. These are site-start.el, which is loaded /before/ your .emacs file, and default.el, and the terminal type file, which are both loaded /after/ your .emacs file.

Settings and definitions in your .emacs file will overwrite conflicting settings and definitions in a site-start.el file, if it exists; but the settings and definitions in a default.el or terminal type file will overwrite those in your .emacs file. (You can prevent interference from a terminal type file by setting =term-file-prefix= to =nil=. See [[#Simple-Extension][A Simple Extension]].)

The INSTALL file that comes in the distribution contains descriptions of the site-init.el and site-load.el files.

The loadup.el, startup.el, and loaddefs.el files control loading. These files are in the lisp directory of the Emacs distribution and are worth perusing.

The loaddefs.el file contains a good many suggestions as to what to put into your own .emacs file, or into a site-wide initialization file.


Next: [[#Beginning-init-File][Beginning init File]], Previous: [[#Site_002dwide-Init][Site-wide Init]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.2 Specifying Variables using =defcustom=
    :PROPERTIES:
    :CUSTOM_ID: specifying-variables-using-defcustom
    :CLASS: section
    :END:

 You can specify variables using =defcustom= so that you and others can then use Emacs's =customize= feature to set their values. (You cannot use =customize= to write function definitions; but you can write =defuns= in your .emacs file. Indeed, you can write any Lisp expression in your .emacs file.)

The =customize= feature depends on the =defcustom= macro. Although you can use =defvar= or =setq= for variables that users set, the =defcustom= macro is designed for the job.

You can use your knowledge of =defvar= for writing the first three arguments for =defcustom=. The first argument to =defcustom= is the name of the variable. The second argument is the variable's initial value, if any; and this value is set only if the value has not already been set. The third argument is the documentation.

The fourth and subsequent arguments to =defcustom= specify types and options; these are not featured in =defvar=. (These arguments are optional.)

Each of these arguments consists of a keyword followed by a value. Each keyword starts with the colon character ‘:'.

For example, the customizable user option variable =text-mode-hook= looks like this:

#+begin_src elisp
         (defcustom text-mode-hook nil
           "Normal hook run when entering Text mode and many related modes."
           :type 'hook
           :options '(turn-on-auto-fill flyspell-mode)
           :group 'wp)
#+end_src

The name of the variable is =text-mode-hook=; it has no default value; and its documentation string tells you what it does.

The =:type= keyword tells Emacs the kind of data to which =text-mode-hook= should be set and how to display the value in a Customization buffer.

The =:options= keyword specifies a suggested list of values for the variable. Usually, =:options= applies to a hook. The list is only a suggestion; it is not exclusive; a person who sets the variable may set it to other values; the list shown following the =:options= keyword is intended to offer convenient choices to a user.

Finally, the =:group= keyword tells the Emacs Customization command in which group the variable is located. This tells where to find it.

The =defcustom= macro recognizes more than a dozen keywords. For more information, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Customization][Writing Customization Definitions]].

Consider =text-mode-hook= as an example.

There are two ways to customize this variable. You can use the customization command or write the appropriate expressions yourself.

Using the customization command, you can type:

#+begin_src elisp
         M-x customize
#+end_src

and find that the group for editing files of text is called “Text”. Enter that group. Text Mode Hook is the first member. You can click on its various options, such as =turn-on-auto-fill=, to set the values. After you click on the button to

#+begin_src elisp
         Save for Future Sessions
#+end_src

Emacs will write an expression into your .emacs file. It will look like this:

#+begin_src elisp
         (custom-set-variables
           ;; custom-set-variables was added by Custom.
           ;; If you edit it by hand, you could mess it up, so be careful.
           ;; Your init file should contain only one such instance.
           ;; If there is more than one, they won't work right.
          '(text-mode-hook (quote (turn-on-auto-fill text-mode-hook-identify))))
#+end_src

(The =text-mode-hook-identify= function tells =toggle-text-mode-auto-fill= which buffers are in Text mode. It comes on automatically.)

The =custom-set-variables= function works somewhat differently than a =setq=. While I have never learned the differences, I modify the =custom-set-variables= expressions in my .emacs file by hand: I make the changes in what appears to me to be a reasonable manner and have not had any problems. Others prefer to use the Customization command and let Emacs do the work for them.

Another =custom-set-...= function is =custom-set-faces=. This function sets the various font faces. Over time, I have set a considerable number of faces. Some of the time, I re-set them using =customize=; other times, I simply edit the =custom-set-faces= expression in my .emacs file itself.

The second way to customize your =text-mode-hook= is to set it yourself in your .emacs file using code that has nothing to do with the =custom-set-...= functions.

When you do this, and later use =customize=, you will see a message that says

#+begin_src elisp
         CHANGED outside Customize; operating on it here may be unreliable.
#+end_src

This message is only a warning. If you click on the button to

#+begin_src elisp
         Save for Future Sessions
#+end_src

Emacs will write a =custom-set-...= expression near the end of your .emacs file that will be evaluated after your hand-written expression. It will, therefore, overrule your hand-written expression. No harm will be done. When you do this, however, be careful to remember which expression is active; if you forget, you may confuse yourself.

So long as you remember where the values are set, you will have no trouble. In any event, the values are always set in your initialization file, which is usually called .emacs.

I myself use =customize= for hardly anything. Mostly, I write expressions myself.

Incidentally, to be more complete concerning defines: =defsubst= defines an inline function. The syntax is just like that of =defun=. =defconst= defines a symbol as a constant. The intent is that neither programs nor users should ever change a value set by =defconst=. (You can change it; the value set is a variable; but please do not.)


Next: [[#Text-and-Auto_002dfill][Text and Auto-fill]], Previous: [[#defcustom][defcustom]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.3 Beginning a .emacs File
    :PROPERTIES:
    :CUSTOM_ID: beginning-a-.emacs-file
    :CLASS: section
    :END:

 When you start Emacs, it loads your .emacs file unless you tell it not to by specifying ‘-q' on the command line. (The =emacs -q= command gives you a plain, out-of-the-box Emacs.)

A .emacs file contains Lisp expressions. Often, these are no more than expressions to set values; sometimes they are function definitions.

See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Init-File][The Init File ~/.emacs]], for a short description of initialization files.

This chapter goes over some of the same ground, but is a walk among extracts from a complete, long-used .emacs file---my own.

The first part of the file consists of comments: reminders to myself. By now, of course, I remember these things, but when I started, I did not.

#+begin_src elisp
         ;;;; Bob's .emacs file
         ; Robert J. Chassell
         ; 26 September 1985
#+end_src

Look at that date! I started this file a long time ago. I have been adding to it ever since.

#+begin_src elisp
         ; Each section in this file is introduced by a
         ; line beginning with four semicolons; and each
         ; entry is introduced by a line beginning with
         ; three semicolons.
#+end_src

This describes the usual conventions for comments in Emacs Lisp. Everything on a line that follows a semicolon is a comment. Two, three, and four semicolons are used as subsection and section markers. (See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Comments][Comments]], for more about comments.)

#+begin_src elisp
         ;;;; The Help Key
         ; Control-h is the help key;
         ; after typing control-h, type a letter to
         ; indicate the subject about which you want help.
         ; For an explanation of the help facility,
         ; type control-h two times in a row.
#+end_src

Just remember: type C-h two times for help.

#+begin_src elisp
         ; To find out about any mode, type control-h m
         ; while in that mode.  For example, to find out
         ; about mail mode, enter mail mode and then type
         ; control-h m.
#+end_src

“Mode help”, as I call this, is very helpful. Usually, it tells you all you need to know.

Of course, you don't need to include comments like these in your .emacs file. I included them in mine because I kept forgetting about Mode help or the conventions for comments---but I was able to remember to look here to remind myself.


Next: [[#Mail-Aliases][Mail Aliases]], Previous: [[#Beginning-init-File][Beginning init File]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.4 Text and Auto Fill Mode
    :PROPERTIES:
    :CUSTOM_ID: text-and-auto-fill-mode
    :CLASS: section
    :END:

Now we come to the part that turns on Text mode and Auto Fill mode.

#+begin_src elisp
         ;;; Text mode and Auto Fill mode
         ;; The next two lines put Emacs into Text mode
         ;; and Auto Fill mode, and are for writers who
         ;; want to start writing prose rather than code.
         (setq-default major-mode 'text-mode)
         (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+end_src

Here is the first part of this .emacs file that does something besides remind a forgetful human!

The first of the two lines in parentheses tells Emacs to turn on Text mode when you find a file, /unless/ that file should go into some other mode, such as C mode.

When Emacs reads a file, it looks at the extension to the file name, if any. (The extension is the part that comes after a ‘.'.) If the file ends with a ‘.c' or ‘.h' extension then Emacs turns on C mode. Also, Emacs looks at first nonblank line of the file; if the line says ‘-*- C -*-', Emacs turns on C mode. Emacs possesses a list of extensions and specifications that it uses automatically. In addition, Emacs looks near the last page for a per-buffer, local variables list, if any.

Now, back to the .emacs file.

Here is the line again; how does it work?



#+begin_src elisp
         (setq major-mode 'text-mode)
#+end_src

This line is a short, but complete Emacs Lisp expression.

We are already familiar with =setq=. It sets the following variable, =major-mode=, to the subsequent value, which is =text-mode=. The single-quote before =text-mode= tells Emacs to deal directly with the =text-mode= symbol, not with whatever it might stand for. See [[#set-_0026-setq][Setting the Value of a Variable]], for a reminder of how =setq= works. The main point is that there is no difference between the procedure you use to set a value in your .emacs file and the procedure you use anywhere else in Emacs.

Here is the next line:



#+begin_src elisp
         (add-hook 'text-mode-hook 'turn-on-auto-fill)
#+end_src

In this line, the =add-hook= command adds =turn-on-auto-fill= to the variable.

=turn-on-auto-fill= is the name of a program, that, you guessed it!, turns on Auto Fill mode.

Every time Emacs turns on Text mode, Emacs runs the commands hooked onto Text mode. So every time Emacs turns on Text mode, Emacs also turns on Auto Fill mode.

In brief, the first line causes Emacs to enter Text mode when you edit a file, unless the file name extension, a first non-blank line, or local variables to tell Emacs otherwise.

Text mode among other actions, sets the syntax table to work conveniently for writers. In Text mode, Emacs considers an apostrophe as part of a word like a letter; but Emacs does not consider a period or a space as part of a word. Thus, M-f moves you over ‘it's'. On the other hand, in C mode, M-f stops just after the ‘t' of ‘it's'.

The second line causes Emacs to turn on Auto Fill mode when it turns on Text mode. In Auto Fill mode, Emacs automatically breaks a line that is too wide and brings the excessively wide part of the line down to the next line. Emacs breaks lines between words, not within them.

When Auto Fill mode is turned off, lines continue to the right as you type them. Depending on how you set the value of =truncate-lines=, the words you type either disappear off the right side of the screen, or else are shown, in a rather ugly and unreadable manner, as a continuation line on the screen.

In addition, in this part of my .emacs file, I tell the Emacs fill commands to insert two spaces after a colon:

#+begin_src elisp
         (setq colon-double-space t)
#+end_src


Next: [[#Indent-Tabs-Mode][Indent Tabs Mode]], Previous: [[#Text-and-Auto_002dfill][Text and Auto-fill]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.5 Mail Aliases
    :PROPERTIES:
    :CUSTOM_ID: mail-aliases
    :CLASS: section
    :END:

Here is a =setq= that turns on mail aliases, along with more reminders.

#+begin_src elisp
         ;;; Mail mode
         ; To enter mail mode, type 'C-x m'
         ; To enter RMAIL (for reading mail),
         ; type 'M-x rmail'
         (setq mail-aliases t)
#+end_src

This =setq= command sets the value of the variable =mail-aliases= to =t=. Since =t= means true, the line says, in effect, “Yes, use mail aliases.”

Mail aliases are convenient short names for long email addresses or for lists of email addresses. The file where you keep your aliases is ~/.mailrc. You write an alias like this:

#+begin_src elisp
         alias geo george@foobar.wiz.edu
#+end_src

When you write a message to George, address it to ‘geo'; the mailer will automatically expand ‘geo' to the full address.


Next: [[#Keybindings][Keybindings]], Previous: [[#Mail-Aliases][Mail Aliases]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.6 Indent Tabs Mode
    :PROPERTIES:
    :CUSTOM_ID: indent-tabs-mode
    :CLASS: section
    :END:

 By default, Emacs inserts tabs in place of multiple spaces when it formats a region. (For example, you might indent many lines of text all at once with the =indent-region= command.) Tabs look fine on a terminal or with ordinary printing, but they produce badly indented output when you use TeX or Texinfo since TeX ignores tabs.

The following turns off Indent Tabs mode:

#+begin_src elisp
         ;;; Prevent Extraneous Tabs
         (setq-default indent-tabs-mode nil)
#+end_src

Note that this line uses =setq-default= rather than the =setq= command that we have seen before. The =setq-default= command sets values only in buffers that do not have their own local values for the variable.


Next: [[#Keymaps][Keymaps]], Previous: [[#Indent-Tabs-Mode][Indent Tabs Mode]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.7 Some Keybindings
    :PROPERTIES:
    :CUSTOM_ID: some-keybindings
    :CLASS: section
    :END:

Now for some personal keybindings:

#+begin_src elisp
         ;;; Compare windows
         (global-set-key "\C-cw" 'compare-windows)
#+end_src

=compare-windows= is a nifty command that compares the text in your current window with text in the next window. It makes the comparison by starting at point in each window, moving over text in each window as far as they match. I use this command all the time.

This also shows how to set a key globally, for all modes.

The command is =global-set-key=. It is followed by the keybinding. In a .emacs file, the keybinding is written as shown: =\C-c= stands for Control-C, which means to press the control key and the c key at the same time. The =w= means to press the w key. The keybinding is surrounded by double quotation marks. In documentation, you would write this as C-c w. (If you were binding a <META> key, such as M-c, rather than a <CTRL> key, you would write =\M-c= in your .emacs file. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Init-Rebinding][Rebinding Keys in Your Init File]], for details.)

The command invoked by the keys is =compare-windows=. Note that =compare-windows= is preceded by a single-quote; otherwise, Emacs would first try to evaluate the symbol to determine its value.

These three things, the double quotation marks, the backslash before the ‘C', and the single-quote are necessary parts of keybinding that I tend to forget. Fortunately, I have come to remember that I should look at my existing .emacs file, and adapt what is there.

As for the keybinding itself: C-c w. This combines the prefix key, C-c, with a single character, in this case, w. This set of keys, C-c followed by a single character, is strictly reserved for individuals' own use. (I call these own keys, since these are for my own use.) You should always be able to create such a keybinding for your own use without stomping on someone else's keybinding. If you ever write an extension to Emacs, please avoid taking any of these keys for public use. Create a key like C-c C-w instead. Otherwise, we will run out of own keys.

Here is another keybinding, with a comment:

#+begin_src elisp
         ;;; Keybinding for 'occur'
         ; I use occur a lot, so let's bind it to a key:
         (global-set-key "\C-co" 'occur)
#+end_src

The =occur= command shows all the lines in the current buffer that contain a match for a regular expression. When the region is active, =occur= restricts matches to such region. Otherwise it uses the entire buffer. Matching lines are shown in a buffer called *Occur*. That buffer serves as a menu to jump to occurrences.

Here is how to unbind a key, so it does not work:

#+begin_src elisp
         ;;; Unbind 'C-x f'
         (global-unset-key "\C-xf")
#+end_src

There is a reason for this unbinding: I found I inadvertently typed C-x f when I meant to type C-x C-f. Rather than find a file, as I intended, I accidentally set the width for filled text, almost always to a width I did not want. Since I hardly ever reset my default width, I simply unbound the key.

The following rebinds an existing key:

#+begin_src elisp
         ;;; Rebind 'C-x C-b' for 'buffer-menu'
         (global-set-key "\C-x\C-b" 'buffer-menu)
#+end_src

By default, C-x C-b runs the =list-buffers= command. This command lists your buffers in /another/ window. Since I almost always want to do something in that window, I prefer the =buffer-menu= command, which not only lists the buffers, but moves point into that window.


Next: [[#Loading-Files][Loading Files]], Previous: [[#Keybindings][Keybindings]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.8 Keymaps
    :PROPERTIES:
    :CUSTOM_ID: keymaps
    :CLASS: section
    :END:

 Emacs uses keymaps to record which keys call which commands. When you use =global-set-key= to set the keybinding for a single command in all parts of Emacs, you are specifying the keybinding in =current-global-map=.

Specific modes, such as C mode or Text mode, have their own keymaps; the mode-specific keymaps override the global map that is shared by all buffers.

The =global-set-key= function binds, or rebinds, the global keymap. For example, the following binds the key C-x C-b to the function =buffer-menu=:

#+begin_src elisp
         (global-set-key "\C-x\C-b" 'buffer-menu)
#+end_src

Mode-specific keymaps are bound using the =define-key= function, which takes a specific keymap as an argument, as well as the key and the command. For example, my .emacs file contains the following expression to bind the =texinfo-insert-@group= command to C-c C-c g:

#+begin_src elisp
         (define-key texinfo-mode-map "\C-c\C-cg" 'texinfo-insert-@group)
#+end_src

The =texinfo-insert-@group= function itself is a little extension to Texinfo mode that inserts ‘@group' into a Texinfo file. I use this command all the time and prefer to type the three strokes C-c C-c g rather than the six strokes @ g r o u p. (‘@group' and its matching ‘@end group' are commands that keep all enclosed text together on one page; many multi-line examples in this book are surrounded by ‘@group ... @end group'.)

Here is the =texinfo-insert-@group= function definition:

#+begin_src elisp
         (defun texinfo-insert-@group ()
           "Insert the string @group in a Texinfo buffer."
           (interactive)
           (beginning-of-line)
           (insert "@group\n"))
#+end_src

(Of course, I could have used Abbrev mode to save typing, rather than write a function to insert a word; but I prefer key strokes consistent with other Texinfo mode key bindings.)

You will see numerous =define-key= expressions in loaddefs.el as well as in the various mode libraries, such as cc-mode.el and lisp-mode.el.

See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Key-Bindings][Customizing Key Bindings]], and [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Keymaps][Keymaps]], for more information about keymaps.


Next: [[#Autoload][Autoload]], Previous: [[#Keymaps][Keymaps]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.9 Loading Files
    :PROPERTIES:
    :CUSTOM_ID: loading-files
    :CLASS: section
    :END:



Many people in the GNU Emacs community have written extensions to Emacs. As time goes by, these extensions are often included in new releases. For example, the Calendar and Diary packages are now part of the standard GNU Emacs, as is Calc.

You can use a =load= command to evaluate a complete file and thereby install all the functions and variables in the file into Emacs. For example:

#+begin_src elisp
         (load "~/emacs/slowsplit")
#+end_src

This evaluates, i.e., loads, the slowsplit.el file or if it exists, the faster, byte compiled slowsplit.elc file from the emacs sub-directory of your home directory. The file contains the function =split-window-quietly=, which John Robinson wrote in 1989.

The =split-window-quietly= function splits a window with the minimum of redisplay. I installed it in 1989 because it worked well with the slow 1200 baud terminals I was then using. Nowadays, I only occasionally come across such a slow connection, but I continue to use the function because I like the way it leaves the bottom half of a buffer in the lower of the new windows and the top half in the upper window.

To replace the key binding for the default =split-window-vertically=, you must also unset that key and bind the keys to =split-window-quietly=, like this:

#+begin_src elisp
         (global-unset-key "\C-x2")
         (global-set-key "\C-x2" 'split-window-quietly)
#+end_src

If you load many extensions, as I do, then instead of specifying the exact location of the extension file, as shown above, you can specify that directory as part of Emacs's =load-path=. Then, when Emacs loads a file, it will search that directory as well as its default list of directories. (The default list is specified in paths.h when Emacs is built.)

The following command adds your ~/emacs directory to the existing load path:

#+begin_src elisp
         ;;; Emacs Load Path
         (setq load-path (cons "~/emacs" load-path))
#+end_src

Incidentally, =load-library= is an interactive interface to the =load= function. The complete function looks like this:



#+begin_src elisp
         (defun load-library (library)
           "Load the Emacs Lisp library named LIBRARY.
         This is an interface to the function `load'.  LIBRARY is searched
         for in `load-path', both with and without `load-suffixes' (as
         well as `load-file-rep-suffixes').

         See Info node `(emacs)Lisp Libraries' for more details.
         See `load-file' for a different interface to `load'."
           (interactive
            (list (completing-read "Load library: "
                                   (apply-partially 'locate-file-completion-table
                                                    load-path
                                                    (get-load-suffixes)))))
           (load library))
#+end_src

The name of the function, =load-library=, comes from the use of “library” as a conventional synonym for “file”. The source for the =load-library= command is in the files.el library.

Another interactive command that does a slightly different job is =load-file=. See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Lisp-Libraries][Libraries of Lisp Code for Emacs]], for information on the distinction between =load-library= and this command.


Next: [[#Simple-Extension][Simple Extension]], Previous: [[#Loading-Files][Loading Files]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.10 Autoloading
    :PROPERTIES:
    :CUSTOM_ID: autoloading
    :CLASS: section
    :END:

 Instead of installing a function by loading the file that contains it, or by evaluating the function definition, you can make the function available but not actually install it until it is first called. This is called autoloading.

When you execute an autoloaded function, Emacs automatically evaluates the file that contains the definition, and then calls the function.

Emacs starts quicker with autoloaded functions, since their libraries are not loaded right away; but you need to wait a moment when you first use such a function, while its containing file is evaluated.

Rarely used functions are frequently autoloaded. The loaddefs.el library contains thousands of autoloaded functions, from =5x5= to =zone=. Of course, you may come to use a rare function frequently. When you do, you should load that function's file with a =load= expression in your .emacs file.

In my .emacs file, I load 14 libraries that contain functions that would otherwise be autoloaded. (Actually, it would have been better to include these files in my dumped Emacs, but I forgot. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Building-Emacs][Building Emacs]], and the INSTALL file for more about dumping.)

You may also want to include autoloaded expressions in your .emacs file. =autoload= is a built-in function that takes up to five arguments, the final three of which are optional. The first argument is the name of the function to be autoloaded; the second is the name of the file to be loaded. The third argument is documentation for the function, and the fourth tells whether the function can be called interactively. The fifth argument tells what type of object---=autoload= can handle a keymap or macro as well as a function (the default is a function).

Here is a typical example:

#+begin_src elisp
         (autoload 'html-helper-mode
           "html-helper-mode" "Edit HTML documents" t)
#+end_src

(=html-helper-mode= is an older alternative to =html-mode=, which is a standard part of the distribution.)

This expression autoloads the =html-helper-mode= function. It takes it from the html-helper-mode.el file (or from the byte compiled version html-helper-mode.elc, if that exists.) The file must be located in a directory specified by =load-path=. The documentation says that this is a mode to help you edit documents written in the HyperText Markup Language. You can call this mode interactively by typing M-x html-helper-mode. (You need to duplicate the function's regular documentation in the autoload expression because the regular function is not yet loaded, so its documentation is not available.)

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Autoload][Autoload]], for more information.


Next: [[#X11-Colors][X11 Colors]], Previous: [[#Autoload][Autoload]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.11 A Simple Extension: =line-to-top-of-window=
    :PROPERTIES:
    :CUSTOM_ID: a-simple-extension-line-to-top-of-window
    :CLASS: section
    :END:

 Here is a simple extension to Emacs that moves the line point is on to the top of the window. I use this all the time, to make text easier to read.

You can put the following code into a separate file and then load it from your .emacs file, or you can include it within your .emacs file.

Here is the definition:

#+begin_src elisp
         ;;; Line to top of window;
         ;;; replace three keystroke sequence  C-u 0 C-l
         (defun line-to-top-of-window ()
           "Move the line point is on to top of window."
           (interactive)
           (recenter 0))
#+end_src

Now for the keybinding.

Nowadays, function keys as well as mouse button events and non-ascii characters are written within square brackets, without quotation marks. (In Emacs version 18 and before, you had to write different function key bindings for each different make of terminal.)

I bind =line-to-top-of-window= to my <F6> function key like this:

#+begin_src elisp
         (global-set-key [f6] 'line-to-top-of-window)
#+end_src

For more information, see [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Init-Rebinding][Rebinding Keys in Your Init File]].

If you run two versions of GNU Emacs, such as versions 22 and 23, and use one .emacs file, you can select which code to evaluate with the following conditional:

#+begin_src elisp
         (cond
          ((= 22 emacs-major-version)
           ;; evaluate version 22 code
           ( ... ))
          ((= 23 emacs-major-version)
           ;; evaluate version 23 code
           ( ... )))
#+end_src

For example, recent versions blink their cursors by default. I hate such blinking, as well as other features, so I placed the following in my .emacs file[[#fn-17][^{17}]]:

#+begin_src elisp
         (when (>= emacs-major-version 21)
           (blink-cursor-mode 0)
           ;; Insert newline when you press 'C-n' (next-line)
           ;; at the end of the buffer
           (setq next-line-add-newlines t)
           ;; Turn on image viewing
           (auto-image-file-mode t)
           ;; Turn on menu bar (this bar has text)
           ;; (Use numeric argument to turn on)
           (menu-bar-mode 1)
           ;; Turn off tool bar (this bar has icons)
           ;; (Use numeric argument to turn on)
           (tool-bar-mode nil)
           ;; Turn off tooltip mode for tool bar
           ;; (This mode causes icon explanations to pop up)
           ;; (Use numeric argument to turn on)
           (tooltip-mode nil)
           ;; If tooltips turned on, make tips appear promptly
           (setq tooltip-delay 0.1)  ; default is 0.7 second
            )
#+end_src


Next: [[#Miscellaneous][Miscellaneous]], Previous: [[#Simple-Extension][Simple Extension]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.12 X11 Colors
    :PROPERTIES:
    :CUSTOM_ID: x11-colors
    :CLASS: section
    :END:

You can specify colors when you use Emacs with the MIT X Windowing system.

I dislike the default colors and specify my own.

Here are the expressions in my .emacs file that set values:

#+begin_src elisp
         ;; Set cursor color
         (set-cursor-color "white")

         ;; Set mouse color
         (set-mouse-color "white")

         ;; Set foreground and background
         (set-foreground-color "white")
         (set-background-color "darkblue")

         ;;; Set highlighting colors for isearch and drag
         (set-face-foreground 'highlight "white")
         (set-face-background 'highlight "blue")

         (set-face-foreground 'region "cyan")
         (set-face-background 'region "blue")

         (set-face-foreground 'secondary-selection "skyblue")
         (set-face-background 'secondary-selection "darkblue")

         ;; Set calendar highlighting colors
         (with-eval-after-load 'calendar
           (set-face-foreground 'diary   "skyblue")
           (set-face-background 'holiday "slate blue")
           (set-face-foreground 'holiday "white"))
#+end_src

The various shades of blue soothe my eye and prevent me from seeing the screen flicker.

Alternatively, I could have set my specifications in various X initialization files. For example, I could set the foreground, background, cursor, and pointer (i.e., mouse) colors in my ~/.Xresources file like this:

#+begin_src elisp
         Emacs*foreground:   white
         Emacs*background:   darkblue
         Emacs*cursorColor:  white
         Emacs*pointerColor: white
#+end_src

In any event, since it is not part of Emacs, I set the root color of my X window in my ~/.xinitrc file, like this[[#fn-18][^{18}]]:

#+begin_src elisp
         xsetroot -solid Navy -fg white &
#+end_src


Next: [[#Mode-Line][Mode Line]], Previous: [[#X11-Colors][X11 Colors]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.13 Miscellaneous Settings for a .emacs File
    :PROPERTIES:
    :CUSTOM_ID: miscellaneous-settings-for-a-.emacs-file
    :CLASS: section
    :END:

Here are a few miscellaneous settings:

#+begin_src elisp
#+end_src

- Set the shape and color of the mouse cursor:

  #+begin_src elisp
                ; Cursor shapes are defined in
                ; '/usr/include/X11/cursorfont.h';
                ; for example, the 'target' cursor is number 128;
                ; the 'top_left_arrow' cursor is number 132.

                (let ((mpointer (x-get-resource "*mpointer"
                                                "*emacs*mpointer")))
                  ;; If you have not set your mouse pointer
                  ;;     then set it, otherwise leave as is:
                  (if (eq mpointer nil)
                      (setq mpointer "132")) ; top_left_arrow
                  (setq x-pointer-shape (string-to-number mpointer))
                  (set-mouse-color "white"))
  #+end_src

- Or you can set the values of a variety of features in an alist, like this:

  #+begin_src elisp
                (setq-default
                 default-frame-alist
                 '((cursor-color . "white")
                   (mouse-color . "white")
                   (foreground-color . "white")
                   (background-color . "DodgerBlue4")
                   ;; (cursor-type . bar)
                   (cursor-type . box)
                   (tool-bar-lines . 0)
                   (menu-bar-lines . 1)
                   (width . 80)
                   (height . 58)
                   (font .
                         "-Misc-Fixed-Medium-R-Normal--20-200-75-75-C-100-ISO8859-1")
                   ))
  #+end_src

- Convert <CTRL>-h into <DEL> and <DEL> into <CTRL>-h.\\
  (Some older keyboards needed this, although I have not seen the problem recently.)

  #+begin_src elisp
                ;; Translate 'C-h' to <DEL>.
                ; (keyboard-translate ?\C-h ?\C-?)

                ;; Translate <DEL> to 'C-h'.
                (keyboard-translate ?\C-? ?\C-h)
  #+end_src

- Turn off a blinking cursor!

  #+begin_src elisp
                (if (fboundp 'blink-cursor-mode)
                    (blink-cursor-mode -1))
  #+end_src

  or start GNU Emacs with the command =emacs -nbc=.

- When using grep\\
  ‘-i'   Ignore case distinctions\\
  ‘-n'   Prefix each line of output with line number\\
  ‘-H'   Print the filename for each match.\\
  ‘-e'   Protect patterns beginning with a hyphen character, ‘-'

  #+begin_src elisp
                (setq grep-command "grep -i -nH -e ")
  #+end_src

- Find an existing buffer, even if it has a different name\\
  This avoids problems with symbolic links.

  #+begin_src elisp
                (setq find-file-existing-other-name t)
  #+end_src

- Set your language environment and default input method

  #+begin_src elisp
                (set-language-environment "latin-1")
                ;; Remember you can enable or disable multilingual text input
                ;; with the toggle-input-method' (C-\) command
                (setq default-input-method "latin-1-prefix")
  #+end_src

  If you want to write with Chinese GB characters, set this instead:

  #+begin_src elisp
                (set-language-environment "Chinese-GB")
                (setq default-input-method "chinese-tonepy")
  #+end_src

*** Fixing Unpleasant Key Bindings
      :PROPERTIES:
      :CUSTOM_ID: fixing-unpleasant-key-bindings
      :CLASS: subsubheading
      :END:

 Some systems bind keys unpleasantly. Sometimes, for example, the <CTRL> key appears in an awkward spot rather than at the far left of the home row.

Usually, when people fix these sorts of keybindings, they do not change their ~/.emacs file. Instead, they bind the proper keys on their consoles with the =loadkeys= or =install-keymap= commands in their boot script and then include =xmodmap= commands in their .xinitrc or .Xsession file for X Windows.

For a boot script:

#+begin_src elisp
         loadkeys /usr/share/keymaps/i386/qwerty/emacs2.kmap.gz

    or

         install-keymap emacs2
#+end_src

For a .xinitrc or .Xsession file when the <Caps Lock> key is at the far left of the home row:

#+begin_src elisp
         # Bind the key labeled 'Caps Lock' to 'Control'
         # (Such a broken user interface suggests that keyboard manufacturers
         # think that computers are typewriters from 1885.)

         xmodmap -e "clear Lock"
         xmodmap -e "add Control = Caps_Lock"
#+end_src

In a .xinitrc or .Xsession file, to convert an <ALT> key to a <META> key:

#+begin_src elisp
         # Some ill designed keyboards have a key labeled ALT and no Meta
         xmodmap -e "keysym Alt_L = Meta_L Alt_L"
#+end_src


Previous: [[#Miscellaneous][Miscellaneous]], Up: [[#Emacs-Initialization][Emacs Initialization]]

* 16.14 A Modified Mode Line
    :PROPERTIES:
    :CUSTOM_ID: a-modified-mode-line
    :CLASS: section
    :END:

 Finally, a feature I really like: a modified mode line.

When I work over a network, I forget which machine I am using. Also, I tend to I lose track of where I am, and which line point is on.

So I reset my mode line to look like this:

#+begin_src elisp
         -:-- foo.texi   rattlesnake:/home/bob/  Line 1  (Texinfo Fill) Top
#+end_src

I am visiting a file called foo.texi, on my machine rattlesnake in my /home/bob buffer. I am on line 1, in Texinfo mode, and am at the top of the buffer.

My .emacs file has a section that looks like this:

#+begin_src elisp
         ;; Set a Mode Line that tells me which machine, which directory,
         ;; and which line I am on, plus the other customary information.
         (setq-default mode-line-format
          (quote
           (#("-" 0 1
              (help-echo
               "mouse-1: select window, mouse-2: delete others ..."))
            mode-line-mule-info
            mode-line-modified
            mode-line-frame-identification
            "    "
            mode-line-buffer-identification
            "    "
            (:eval (substring
                    (system-name) 0 (string-match "\\..+" (system-name))))
            ":"
            default-directory
            #(" " 0 1
              (help-echo
               "mouse-1: select window, mouse-2: delete others ..."))
            (line-number-mode " Line %l ")
            global-mode-string
            #("   %[(" 0 6
              (help-echo
               "mouse-1: select window, mouse-2: delete others ..."))
            (:eval (mode-line-mode-name))
            mode-line-process
            minor-mode-alist
            #("%n" 0 2 (help-echo "mouse-2: widen" local-map (keymap ...)))
            ")%] "
            (-3 . "%P")
            ;;   "-%-"
            )))
#+end_src

Here, I redefine the default mode line. Most of the parts are from the original; but I make a few changes. I set the /default/ mode line format so as to permit various modes, such as Info, to override it.

Many elements in the list are self-explanatory: =mode-line-modified= is a variable that tells whether the buffer has been modified, =mode-name= tells the name of the mode, and so on. However, the format looks complicated because of two features we have not discussed.

The first string in the mode line is a dash or hyphen, ‘-'. In the old days, it would have been specified simply as ="-"=. But nowadays, Emacs can add properties to a string, such as highlighting or, as in this case, a help feature. If you place your mouse cursor over the hyphen, some help information appears (By default, you must wait seven-tenths of a second before the information appears. You can change that timing by changing the value of =tooltip-delay=.)

The new string format has a special syntax:

#+begin_src elisp
         #("-" 0 1 (help-echo "mouse-1: select window, ..."))
#+end_src

The =#(= begins a list. The first element of the list is the string itself, just one ‘-'. The second and third elements specify the range over which the fourth element applies. A range starts /after/ a character, so a zero means the range starts just before the first character; a 1 means that the range ends just after the first character. The third element is the property for the range. It consists of a property list, a property name, in this case, ‘help-echo', followed by a value, in this case, a string. The second, third, and fourth elements of this new string format can be repeated.

See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Text-Properties][Text Properties]], and see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Mode-Line-Format][Mode Line Format]], for more information.

=mode-line-buffer-identification= displays the current buffer name. It is a list beginning =(#("%12b" 0 4 ...=. The =#(= begins the list.

The ‘"%12b"' displays the current buffer name, using the =buffer-name= function with which we are familiar; the ‘12' specifies the maximum number of characters that will be displayed. When a name has fewer characters, whitespace is added to fill out to this number. (Buffer names can and often should be longer than 12 characters; this length works well in a typical 80 column wide window.)

=:eval= says to evaluate the following form and use the result as a string to display. In this case, the expression displays the first component of the full system name. The end of the first component is a ‘.' (period), so I use the =string-match= function to tell me the length of the first component. The substring from the zeroth character to that length is the name of the machine.

This is the expression:

#+begin_src elisp
         (:eval (substring
                 (system-name) 0 (string-match "\\..+" (system-name))))
#+end_src

‘%[' and ‘%]' cause a pair of square brackets to appear for each recursive editing level. ‘%n' says “Narrow” when narrowing is in effect. ‘%P' tells you the percentage of the buffer that is above the bottom of the window, or “Top”, “Bottom”, or “All”. (A lower case ‘p' tell you the percentage above the /top/ of the window.) ‘%-' inserts enough dashes to fill out the line.

Remember, you don't have to like Emacs to like it---your own Emacs can have different colors, different commands, and different keys than a default Emacs.

On the other hand, if you want to bring up a plain out-of-the-box Emacs, with no customization, type:

#+begin_src elisp
         emacs -q
#+end_src

This will start an Emacs that does /not/ load your ~/.emacs initialization file. A plain, default Emacs. Nothing more.


Next: [[#Conclusion][Conclusion]], Previous: [[#Emacs-Initialization][Emacs Initialization]], Up: [[#Top][Top]]
