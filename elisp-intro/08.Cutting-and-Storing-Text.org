#+TITLE: 08.Cutting-and-Storing-Text
* 8 Cutting and Storing Text
   :PROPERTIES:
   :CUSTOM_ID: cutting-and-storing-text
   :CLASS: chapter
   :END:

 Whenever you cut or clip text out of a buffer with a kill command in GNU Emacs, it is stored in a list and you can bring it back with a yank command.

(The use of the word “kill” in Emacs for processes which specifically /do not/ destroy the values of the entities is an unfortunate historical accident. A much more appropriate word would be “clip” since that is what the kill commands do; they clip text out of a buffer and put it into storage from which it can be brought back. I have often been tempted to replace globally all occurrences of “kill” in the Emacs sources with “clip” and all occurrences of “killed” with “clipped”.)

1) [[#Storing-Text][Storing Text]]: Text is stored in a list.
2) [[#zap_002dto_002dchar][zap-to-char]]: Cutting out text up to a character.
3) [[#kill_002dregion][kill-region]]: Cutting text out of a region.
4) [[#copy_002dregion_002das_002dkill][copy-region-as-kill]]: A definition for copying text.
5) [[#Digression-into-C][Digression into C]]: Minor note on C programming language macros.
6) [[#defvar][defvar]]: How to give a variable an initial value.
7) [[#cons-_0026-search_002dfwd-Review][cons & search-fwd Review]]
8) [[#search-Exercises][search Exercises]]


* Storing Text in a List
    :PROPERTIES:
    :CUSTOM_ID: storing-text-in-a-list
    :CLASS: unnumberedsec
    :END:

When text is cut out of a buffer, it is stored on a list. Successive pieces of text are stored on the list successively, so the list might look like this:

#+begin_src elisp
         ("a piece of text" "previous piece")
#+end_src

The function =cons= can be used to create a new list from a piece of text (an “atom”, to use the jargon) and an existing list, like this:

#+begin_src elisp
         (cons "another piece"
               '("a piece of text" "previous piece"))
#+end_src

If you evaluate this expression, a list of three elements will appear in the echo area:

#+begin_src elisp
         ("another piece" "a piece of text" "previous piece")
#+end_src

With the =car= and =nthcdr= functions, you can retrieve whichever piece of text you want. For example, in the following code, =nthcdr 1 ...= returns the list with the first item removed; and the =car= returns the first element of that remainder---the second element of the original list:

#+begin_src elisp
         (car (nthcdr 1 '("another piece"
                          "a piece of text"
                          "previous piece")))
              ⇒ "a piece of text"
#+end_src

The actual functions in Emacs are more complex than this, of course. The code for cutting and retrieving text has to be written so that Emacs can figure out which element in the list you want---the first, second, third, or whatever. In addition, when you get to the end of the list, Emacs should give you the first element of the list, rather than nothing at all.

The list that holds the pieces of text is called the kill ring. This chapter leads up to a description of the kill ring and how it is used by first tracing how the =zap-to-char= function works. This function calls a function that invokes a function that manipulates the kill ring. Thus, before reaching the mountains, we climb the foothills.

A subsequent chapter describes how text that is cut from the buffer is retrieved. See [[#Yanking][Yanking Text Back]].


Next: [[#kill_002dregion][kill-region]], Previous: [[#Storing-Text][Storing Text]], Up: [[#Cutting-_0026-Storing-Text][Cutting & Storing Text]]

* 8.1 =zap-to-char=
    :PROPERTIES:
    :CUSTOM_ID: zap-to-char
    :CLASS: section
    :END:

 Let us look at the interactive =zap-to-char= function.

- [[#Complete-zap_002dto_002dchar][Complete zap-to-char]]: The complete implementation.
- [[#zap_002dto_002dchar-interactive][zap-to-char interactive]]: A three part interactive expression.
- [[#zap_002dto_002dchar-body][zap-to-char body]]: A short overview.
- [[#search_002dforward][search-forward]]: How to search for a string.
- [[#progn][progn]]: The =progn= special form.
- [[#Summing-up-zap_002dto_002dchar][Summing up zap-to-char]]: Using =point= and =search-forward=.


Next: [[#zap_002dto_002dchar-interactive][zap-to-char interactive]], Up: [[#zap_002dto_002dchar][zap-to-char]]

** The Complete =zap-to-char= Implementation
     :PROPERTIES:
     :CUSTOM_ID: the-complete-zap-to-char-implementation
     :CLASS: unnumberedsubsec
     :END:

The =zap-to-char= function removes the text in the region between the location of the cursor (i.e., of point) up to and including the next occurrence of a specified character. The text that =zap-to-char= removes is put in the kill ring; and it can be retrieved from the kill ring by typing C-y (=yank=). If the command is given an argument, it removes text through that number of occurrences. Thus, if the cursor were at the beginning of this sentence and the character were ‘s', ‘Thus' would be removed. If the argument were two, ‘Thus, if the curs' would be removed, up to and including the ‘s' in ‘cursor'.

If the specified character is not found, =zap-to-char= will say “Search failed”, tell you the character you typed, and not remove any text.

In order to determine how much text to remove, =zap-to-char= uses a search function. Searches are used extensively in code that manipulates text, and we will focus attention on them as well as on the deletion command.

Here is the complete text of the version 22 implementation of the function:

#+begin_src elisp
         (defun zap-to-char (arg char)
           "Kill up to and including ARG'th occurrence of CHAR.
         Case is ignored if `case-fold-search' is non-nil in the current buffer.
         Goes backward if ARG is negative; error if CHAR not found."
           (interactive "p\ncZap to char: ")
           (if (char-table-p translation-table-for-input)
               (setq char (or (aref translation-table-for-input char) char)))
           (kill-region (point) (progn
                                  (search-forward (char-to-string char)
                                                  nil nil arg)
                                  (point))))
#+end_src

The documentation is thorough. You do need to know the jargon meaning of the word “kill”.

The version 22 documentation string for =zap-to-char= uses ASCII grave accent and apostrophe to quote a symbol, so it appears as =`case-fold-search'=. This quoting style was inspired by 1970s-era displays in which grave accent and apostrophe were often mirror images suitable for use as quotes. On most modern displays this is no longer true, and when these two ASCII characters appear in documentation strings or diagnostic message formats, Emacs typically transliterates them to curved quotes (left and right single quotation marks), so that the abovequoted symbol appears as =‘case-fold-search’=. Source-code strings can also simply use curved quotes directly.


Next: [[#zap_002dto_002dchar-body][zap-to-char body]], Previous: [[#Complete-zap_002dto_002dchar][Complete zap-to-char]], Up: [[#zap_002dto_002dchar][zap-to-char]]

** 8.1.1 The =interactive= Expression
     :PROPERTIES:
     :CUSTOM_ID: the-interactive-expression
     :CLASS: subsection
     :END:

The interactive expression in the =zap-to-char= command looks like this:

#+begin_src elisp
         (interactive "p\ncZap to char: ")
#+end_src

The part within quotation marks, ="p\ncZap to char: "=, specifies two different things. First, and most simply, is the ‘p'. This part is separated from the next part by a newline, ‘\n'. The ‘p' means that the first argument to the function will be passed the value of a processed prefix. The prefix argument is passed by typing C-u and a number, or M- and a number. If the function is called interactively without a prefix, 1 is passed to this argument.

The second part of ="p\ncZap to char: "= is ‘cZap to char: '. In this part, the lower case ‘c' indicates that =interactive= expects a prompt and that the argument will be a character. The prompt follows the ‘c' and is the string ‘Zap to char: ' (with a space after the colon to make it look good).

What all this does is prepare the arguments to =zap-to-char= so they are of the right type, and give the user a prompt.

In a read-only buffer, the =zap-to-char= function copies the text to the kill ring, but does not remove it. The echo area displays a message saying that the buffer is read-only. Also, the terminal may beep or blink at you.


Next: [[#search_002dforward][search-forward]], Previous: [[#zap_002dto_002dchar-interactive][zap-to-char interactive]], Up: [[#zap_002dto_002dchar][zap-to-char]]

** 8.1.2 The Body of =zap-to-char=
     :PROPERTIES:
     :CUSTOM_ID: the-body-of-zap-to-char
     :CLASS: subsection
     :END:

The body of the =zap-to-char= function contains the code that kills (that is, removes) the text in the region from the current position of the cursor up to and including the specified character.

The first part of the code looks like this:

#+begin_src elisp
         (if (char-table-p translation-table-for-input)
             (setq char (or (aref translation-table-for-input char) char)))
         (kill-region (point) (progn
                                (search-forward (char-to-string char) nil nil arg)
                                (point)))
#+end_src

=char-table-p= is a hitherto unseen function. It determines whether its argument is a character table. When it is, it sets the character passed to =zap-to-char= to one of them, if that character exists, or to the character itself. (This becomes important for certain characters in non-European languages. The =aref= function extracts an element from an array. It is an array-specific function that is not described in this document. See [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Arrays][Arrays]].)

=(point)= is the current position of the cursor.

The next part of the code is an expression using =progn=. The body of the =progn= consists of calls to =search-forward= and =point=.

It is easier to understand how =progn= works after learning about =search-forward=, so we will look at =search-forward= and then at =progn=.


Next: [[#progn][progn]], Previous: [[#zap_002dto_002dchar-body][zap-to-char body]], Up: [[#zap_002dto_002dchar][zap-to-char]]

** 8.1.3 The =search-forward= Function
     :PROPERTIES:
     :CUSTOM_ID: the-search-forward-function
     :CLASS: subsection
     :END:

 The =search-forward= function is used to locate the zapped-for-character in =zap-to-char=. If the search is successful, =search-forward= leaves point immediately after the last character in the target string. (In =zap-to-char=, the target string is just one character long. =zap-to-char= uses the function =char-to-string= to ensure that the computer treats that character as a string.) If the search is backwards, =search-forward= leaves point just before the first character in the target. Also, =search-forward= returns =t= for true. (Moving point is therefore a side effect.)

In =zap-to-char=, the =search-forward= function looks like this:

#+begin_src elisp
         (search-forward (char-to-string char) nil nil arg)
#+end_src

The =search-forward= function takes four arguments:

1. The first argument is the target, what is searched for. This must be a string, such as ‘"z"'.

   As it happens, the argument passed to =zap-to-char= is a single character. Because of the way computers are built, the Lisp interpreter may treat a single character as being different from a string of characters. Inside the computer, a single character has a different electronic format than a string of one character. (A single character can often be recorded in the computer using exactly one byte; but a string may be longer, and the computer needs to be ready for this.) Since the =search-forward= function searches for a string, the character that the =zap-to-char= function receives as its argument must be converted inside the computer from one format to the other; otherwise the =search-forward= function will fail. The =char-to-string= function is used to make this conversion.

2. The second argument bounds the search; it is specified as a position in the buffer. In this case, the search can go to the end of the buffer, so no bound is set and the second argument is =nil=.
3. The third argument tells the function what it should do if the search fails---it can signal an error (and print a message) or it can return =nil=. A =nil= as the third argument causes the function to signal an error when the search fails.
4. The fourth argument to =search-forward= is the repeat count---how many occurrences of the string to look for. This argument is optional and if the function is called without a repeat count, this argument is passed the value 1. If this argument is negative, the search goes backwards.

In template form, a =search-forward= expression looks like this:

#+begin_src elisp
         (search-forward "target-string"
                         limit-of-search
                         what-to-do-if-search-fails
                         repeat-count)
#+end_src

We will look at =progn= next.


Next: [[#Summing-up-zap_002dto_002dchar][Summing up zap-to-char]], Previous: [[#search_002dforward][search-forward]], Up: [[#zap_002dto_002dchar][zap-to-char]]

** 8.1.4 The =progn= Special Form
     :PROPERTIES:
     :CUSTOM_ID: the-progn-special-form
     :CLASS: subsection
     :END:

 =progn= is a special form that causes each of its arguments to be evaluated in sequence and then returns the value of the last one. The preceding expressions are evaluated only for the side effects they perform. The values produced by them are discarded.

The template for a =progn= expression is very simple:

#+begin_src elisp
         (progn
           body...)
#+end_src

In =zap-to-char=, the =progn= expression has to do two things: put point in exactly the right position; and return the location of point so that =kill-region= will know how far to kill to.

The first argument to the =progn= is =search-forward=. When =search-forward= finds the string, the function leaves point immediately after the last character in the target string. (In this case the target string is just one character long.) If the search is backwards, =search-forward= leaves point just before the first character in the target. The movement of point is a side effect.

The second and last argument to =progn= is the expression =(point)=. This expression returns the value of point, which in this case will be the location to which it has been moved by =search-forward=. (In the source, a line that tells the function to go to the previous character, if it is going forward, was commented out in 1999; I don't remember whether that feature or mis-feature was ever a part of the distributed source.) The value of =point= is returned by the =progn= expression and is passed to =kill-region= as =kill-region='s second argument.


Previous: [[#progn][progn]], Up: [[#zap_002dto_002dchar][zap-to-char]]

** 8.1.5 Summing up =zap-to-char=
     :PROPERTIES:
     :CUSTOM_ID: summing-up-zap-to-char
     :CLASS: subsection
     :END:

Now that we have seen how =search-forward= and =progn= work, we can see how the =zap-to-char= function works as a whole.

The first argument to =kill-region= is the position of the cursor when the =zap-to-char= command is given---the value of point at that time. Within the =progn=, the search function then moves point to just after the zapped-to-character and =point= returns the value of this location. The =kill-region= function puts together these two values of point, the first one as the beginning of the region and the second one as the end of the region, and removes the region.

The =progn= special form is necessary because the =kill-region= command takes two arguments; and it would fail if =search-forward= and =point= expressions were written in sequence as two additional arguments. The =progn= expression is a single argument to =kill-region= and returns the one value that =kill-region= needs for its second argument.


Next: [[#copy_002dregion_002das_002dkill][copy-region-as-kill]], Previous: [[#zap_002dto_002dchar][zap-to-char]], Up: [[#Cutting-_0026-Storing-Text][Cutting & Storing Text]]

* 8.2 =kill-region=
    :PROPERTIES:
    :CUSTOM_ID: kill-region
    :CLASS: section
    :END:

 The =zap-to-char= function uses the =kill-region= function. This function clips text from a region and copies that text to the kill ring, from which it may be retrieved.

The Emacs 22 version of that function uses =condition-case= and =copy-region-as-kill=, both of which we will explain. =condition-case= is an important special form.

In essence, the =kill-region= function calls =condition-case=, which takes three arguments. In this function, the first argument does nothing. The second argument contains the code that does the work when all goes well. The third argument contains the code that is called in the event of an error.

- [[#Complete-kill_002dregion][Complete kill-region]]: The function definition.
- [[#condition_002dcase][condition-case]]: Dealing with a problem.
- [[#Lisp-macro][Lisp macro]]


Next: [[#condition_002dcase][condition-case]], Up: [[#kill_002dregion][kill-region]]

** The Complete =kill-region= Definition
     :PROPERTIES:
     :CUSTOM_ID: the-complete-kill-region-definition
     :CLASS: unnumberedsubsec
     :END:

We will go through the =condition-case= code in a moment. First, let us look at the definition of =kill-region=, with comments added:

#+begin_src elisp
         (defun kill-region (beg end)
           "Kill (\"cut\") text between point and mark.
         This deletes the text from the buffer and saves it in the kill ring.
         The command \\[yank] can retrieve it from there. ... "

           ;; • Since order matters, pass point first.
           (interactive (list (point) (mark)))
           ;; • And tell us if we cannot cut the text.
           ;; 'unless' is an 'if' without a then-part.
           (unless (and beg end)
             (error "The mark is not set now, so there is no region"))

           ;; • 'condition-case' takes three arguments.
           ;;    If the first argument is nil, as it is here,
           ;;    information about the error signal is not
           ;;    stored for use by another function.
           (condition-case nil

               ;; • The second argument to 'condition-case' tells the
               ;;    Lisp interpreter what to do when all goes well.

               ;;    It starts with a 'let' function that extracts the string
               ;;    and tests whether it exists.  If so (that is what the
               ;;    'when' checks), it calls an 'if' function that determines
               ;;    whether the previous command was another call to
               ;;    'kill-region'; if it was, then the new text is appended to
               ;;    the previous text; if not, then a different function,
               ;;    'kill-new', is called.

               ;;    The 'kill-append' function concatenates the new string and
               ;;    the old.  The 'kill-new' function inserts text into a new
               ;;    item in the kill ring.

               ;;    'when' is an 'if' without an else-part.  The second 'when'
               ;;    again checks whether the current string exists; in
               ;;    addition, it checks whether the previous command was
               ;;    another call to 'kill-region'.  If one or the other
               ;;    condition is true, then it sets the current command to
               ;;    be 'kill-region'.
               (let ((string (filter-buffer-substring beg end t)))
                 (when string                    ;STRING is nil if BEG = END
                   ;; Add that string to the kill ring, one way or another.
                   (if (eq last-command 'kill-region)
                       ;;    − 'yank-handler' is an optional argument to
                       ;;    'kill-region' that tells the 'kill-append' and
                       ;;    'kill-new' functions how deal with properties
                       ;;    added to the text, such as 'bold' or 'italics'.
                       (kill-append string (< end beg) yank-handler)
                     (kill-new string nil yank-handler)))
                 (when (or string (eq last-command 'kill-region))
                   (setq this-command 'kill-region))
                 nil)

             ;;  • The third argument to 'condition-case' tells the interpreter
             ;;    what to do with an error.
             ;;    The third argument has a conditions part and a body part.
             ;;    If the conditions are met (in this case,
             ;;             if text or buffer are read-only)
             ;;    then the body is executed.
             ;;    The first part of the third argument is the following:
             ((buffer-read-only text-read-only) ;; the if-part
              ;; ...  the then-part
              (copy-region-as-kill beg end)
              ;;    Next, also as part of the then-part, set this-command, so
              ;;    it will be set in an error
              (setq this-command 'kill-region)
              ;;    Finally, in the then-part, send a message if you may copy
              ;;    the text to the kill ring without signaling an error, but
              ;;    don't if you may not.
              (if kill-read-only-ok
                  (progn (message "Read only text copied to kill ring") nil)
                (barf-if-buffer-read-only)
                ;; If the buffer isn't read-only, the text is.
                (signal 'text-read-only (list (current-buffer)))))
#+end_src


Next: [[#Lisp-macro][Lisp macro]], Previous: [[#Complete-kill_002dregion][Complete kill-region]], Up: [[#kill_002dregion][kill-region]]

** 8.2.1 =condition-case=
     :PROPERTIES:
     :CUSTOM_ID: condition-case
     :CLASS: subsection
     :END:

 As we have seen earlier (see [[#Making-Errors][Generate an Error Message]]), when the Emacs Lisp interpreter has trouble evaluating an expression, it provides you with help; in the jargon, this is called “signaling an error”. Usually, the computer stops the program and shows you a message.

However, some programs undertake complicated actions. They should not simply stop on an error. In the =kill-region= function, the most likely error is that you will try to kill text that is read-only and cannot be removed. So the =kill-region= function contains code to handle this circumstance. This code, which makes up the body of the =kill-region= function, is inside of a =condition-case= special form.

The template for =condition-case= looks like this:

#+begin_src elisp
         (condition-case
           var
           bodyform
           error-handler...)
#+end_src

The second argument, bodyform, is straightforward. The =condition-case= special form causes the Lisp interpreter to evaluate the code in bodyform. If no error occurs, the special form returns the code's value and produces the side-effects, if any.

In short, the bodyform part of a =condition-case= expression determines what should happen when everything works correctly.

However, if an error occurs, among its other actions, the function generating the error signal will define one or more error condition names.

An error handler is the third argument to =condition-case=. An error handler has two parts, a condition-name and a body. If the condition-name part of an error handler matches a condition name generated by an error, then the body part of the error handler is run.

As you will expect, the condition-name part of an error handler may be either a single condition name or a list of condition names.

Also, a complete =condition-case= expression may contain more than one error handler. When an error occurs, the first applicable handler is run.

Lastly, the first argument to the =condition-case= expression, the var argument, is sometimes bound to a variable that contains information about the error. However, if that argument is nil, as is the case in =kill-region=, that information is discarded.

In brief, in the =kill-region= function, the code =condition-case= works like this:

#+begin_src elisp
         If no errors, run only this code
             but, if errors, run this other code.
#+end_src


Previous: [[#condition_002dcase][condition-case]], Up: [[#kill_002dregion][kill-region]]

** 8.2.2 Lisp macro
     :PROPERTIES:
     :CUSTOM_ID: lisp-macro
     :CLASS: subsection
     :END:

 The part of the =condition-case= expression that is evaluated in the expectation that all goes well has a =when=. The code uses =when= to determine whether the =string= variable points to text that exists.

A =when= expression is simply a programmers' convenience. It is an =if= without the possibility of an else clause. In your mind, you can replace =when= with =if= and understand what goes on. That is what the Lisp interpreter does.

Technically speaking, =when= is a Lisp macro. A Lisp macro enables you to define new control constructs and other language features. It tells the interpreter how to compute another Lisp expression which will in turn compute the value. In this case, the other expression is an =if= expression.

The =kill-region= function definition also has an =unless= macro; it is the converse of =when=. The =unless= macro is an =if= without a then clause

For more about Lisp macros, see [[https://www.gnu.org/software/emacs/manual/html_mono/elisp.html#Macros][Macros]]. The C programming language also provides macros. These are different, but also useful.

Regarding the =when= macro, in the =condition-case= expression, when the string has content, then another conditional expression is executed. This is an =if= with both a then-part and an else-part.

#+begin_src elisp
         (if (eq last-command 'kill-region)
             (kill-append string (< end beg) yank-handler)
           (kill-new string nil yank-handler))
#+end_src

The then-part is evaluated if the previous command was another call to =kill-region=; if not, the else-part is evaluated.

=yank-handler= is an optional argument to =kill-region= that tells the =kill-append= and =kill-new= functions how deal with properties added to the text, such as bold or italics.

=last-command= is a variable that comes with Emacs that we have not seen before. Normally, whenever a function is executed, Emacs sets the value of =last-command= to the previous command.

In this segment of the definition, the =if= expression checks whether the previous command was =kill-region=. If it was,

#+begin_src elisp
         (kill-append string (< end beg) yank-handler)
#+end_src

concatenates a copy of the newly clipped text to the just previously clipped text in the kill ring.


Next: [[#Digression-into-C][Digression into C]], Previous: [[#kill_002dregion][kill-region]], Up: [[#Cutting-_0026-Storing-Text][Cutting & Storing Text]]

* 8.3 =copy-region-as-kill=
    :PROPERTIES:
    :CUSTOM_ID: copy-region-as-kill
    :CLASS: section
    :END:

 The =copy-region-as-kill= function copies a region of text from a buffer and (via either =kill-append= or =kill-new=) saves it in the =kill-ring=.

If you call =copy-region-as-kill= immediately after a =kill-region= command, Emacs appends the newly copied text to the previously copied text. This means that if you yank back the text, you get it all, from both this and the previous operation. On the other hand, if some other command precedes the =copy-region-as-kill=, the function copies the text into a separate entry in the kill ring.

- [[#Complete-copy_002dregion_002das_002dkill][Complete copy-region-as-kill]]: The complete function definition.
- [[#copy_002dregion_002das_002dkill-body][copy-region-as-kill body]]: The body of =copy-region-as-kill=.


Next: [[#copy_002dregion_002das_002dkill-body][copy-region-as-kill body]], Up: [[#copy_002dregion_002das_002dkill][copy-region-as-kill]]

** The complete =copy-region-as-kill= function definition
     :PROPERTIES:
     :CUSTOM_ID: the-complete-copy-region-as-kill-function-definition
     :CLASS: unnumberedsubsec
     :END:

Here is the complete text of the version 22 =copy-region-as-kill= function:

#+begin_src elisp
         (defun copy-region-as-kill (beg end)
           "Save the region as if killed, but don't kill it.
         In Transient Mark mode, deactivate the mark.
         If `interprogram-cut-function' is non-nil, also save the text for a window
         system cut and paste."
           (interactive "r")
           (if (eq last-command 'kill-region)
               (kill-append (filter-buffer-substring beg end) (< end beg))
             (kill-new (filter-buffer-substring beg end)))
           (if transient-mark-mode
               (setq deactivate-mark t))
           nil)
#+end_src

As usual, this function can be divided into its component parts:

#+begin_src elisp
         (defun copy-region-as-kill (argument-list)
           "documentation..."
           (interactive "r")
           body...)
#+end_src

The arguments are =beg= and =end= and the function is interactive with ="r"=, so the two arguments must refer to the beginning and end of the region. If you have been reading through this document from the beginning, understanding these parts of a function is almost becoming routine.

The documentation is somewhat confusing unless you remember that the word “kill” has a meaning different from usual. The Transient Mark and =interprogram-cut-function= comments explain certain side-effects.

After you once set a mark, a buffer always contains a region. If you wish, you can use Transient Mark mode to highlight the region temporarily. (No one wants to highlight the region all the time, so Transient Mark mode highlights it only at appropriate times. Many people turn off Transient Mark mode, so the region is never highlighted.)

Also, a windowing system allows you to copy, cut, and paste among different programs. In the X windowing system, for example, the =interprogram-cut-function= function is =x-select-text=, which works with the windowing system's equivalent of the Emacs kill ring.

The body of the =copy-region-as-kill= function starts with an =if= clause. What this clause does is distinguish between two different situations: whether or not this command is executed immediately after a previous =kill-region= command. In the first case, the new region is appended to the previously copied text. Otherwise, it is inserted into the beginning of the kill ring as a separate piece of text from the previous piece.

The last two lines of the function prevent the region from lighting up if Transient Mark mode is turned on.

The body of =copy-region-as-kill= merits discussion in detail.


Previous: [[#Complete-copy_002dregion_002das_002dkill][Complete copy-region-as-kill]], Up: [[#copy_002dregion_002das_002dkill][copy-region-as-kill]]

** 8.3.1 The Body of =copy-region-as-kill=
     :PROPERTIES:
     :CUSTOM_ID: the-body-of-copy-region-as-kill
     :CLASS: subsection
     :END:

The =copy-region-as-kill= function works in much the same way as the =kill-region= function. Both are written so that two or more kills in a row combine their text into a single entry. If you yank back the text from the kill ring, you get it all in one piece. Moreover, kills that kill forward from the current position of the cursor are added to the end of the previously copied text and commands that copy text backwards add it to the beginning of the previously copied text. This way, the words in the text stay in the proper order.

Like =kill-region=, the =copy-region-as-kill= function makes use of the =last-command= variable that keeps track of the previous Emacs command.

- [[#last_002dcommand-_0026-this_002dcommand][last-command & this-command]]
- [[#kill_002dappend-function][kill-append function]]
- [[#kill_002dnew-function][kill-new function]]


Next: [[#kill_002dappend-function][kill-append function]], Up: [[#copy_002dregion_002das_002dkill-body][copy-region-as-kill body]]

*** =last-command= and =this-command=
      :PROPERTIES:
      :CUSTOM_ID: last-command-and-this-command
      :CLASS: unnumberedsubsubsec
      :END:

Normally, whenever a function is executed, Emacs sets the value of =this-command= to the function being executed (which in this case would be =copy-region-as-kill=). At the same time, Emacs sets the value of =last-command= to the previous value of =this-command=.

In the first part of the body of the =copy-region-as-kill= function, an =if= expression determines whether the value of =last-command= is =kill-region=. If so, the then-part of the =if= expression is evaluated; it uses the =kill-append= function to concatenate the text copied at this call to the function with the text already in the first element (the car) of the kill ring. On the other hand, if the value of =last-command= is not =kill-region=, then the =copy-region-as-kill= function attaches a new element to the kill ring using the =kill-new= function.

The =if= expression reads as follows; it uses =eq=:

#+begin_src elisp
           (if (eq last-command 'kill-region)
               ;; then-part
               (kill-append  (filter-buffer-substring beg end) (< end beg))
             ;; else-part
             (kill-new  (filter-buffer-substring beg end)))
#+end_src

(The =filter-buffer-substring= function returns a filtered substring of the buffer, if any. Optionally---the arguments are not here, so neither is done---the function may delete the initial text or return the text without its properties; this function is a replacement for the older =buffer-substring= function, which came before text properties were implemented.)

The =eq= function tests whether its first argument is the same Lisp object as its second argument. The =eq= function is similar to the =equal= function in that it is used to test for equality, but differs in that it determines whether two representations are actually the same object inside the computer, but with different names. =equal= determines whether the structure and contents of two expressions are the same.

If the previous command was =kill-region=, then the Emacs Lisp interpreter calls the =kill-append= function


Next: [[#kill_002dnew-function][kill-new function]], Previous: [[#last_002dcommand-_0026-this_002dcommand][last-command & this-command]], Up: [[#copy_002dregion_002das_002dkill-body][copy-region-as-kill body]]

*** The =kill-append= function
      :PROPERTIES:
      :CUSTOM_ID: the-kill-append-function
      :CLASS: unnumberedsubsubsec
      :END:

 The =kill-append= function looks like this:

#+begin_src elisp
         (defun kill-append (string before-p &optional yank-handler)
           "Append STRING to the end of the latest kill in the kill ring.
         If BEFORE-P is non-nil, prepend STRING to the kill.
         ... "
           (let* ((cur (car kill-ring)))
             (kill-new (if before-p (concat string cur) (concat cur string))
                       (or (= (length cur) 0)
                           (equal yank-handler
                                  (get-text-property 0 'yank-handler cur)))
                       yank-handler)))
#+end_src

The =kill-append= function is fairly straightforward. It uses the =kill-new= function, which we will discuss in more detail in a moment.

(Also, the function provides an optional argument called =yank-handler=; when invoked, this argument tells the function how to deal with properties added to the text, such as bold or italics.)

It has a =let*= function to set the value of the first element of the kill ring to =cur=. (I do not know why the function does not use =let= instead; only one value is set in the expression. Perhaps this is a bug that produces no problems?)

Consider the conditional that is one of the two arguments to =kill-new=. It uses =concat= to concatenate the new text to the car of the kill ring. Whether it prepends or appends the text depends on the results of an =if= expression:

#+begin_src elisp
         (if before-p                            ; if-part
             (concat string cur)                 ; then-part
           (concat cur string))                  ; else-part
#+end_src

If the region being killed is before the region that was killed in the last command, then it should be prepended before the material that was saved in the previous kill; and conversely, if the killed text follows what was just killed, it should be appended after the previous text. The =if= expression depends on the predicate =before-p= to decide whether the newly saved text should be put before or after the previously saved text.

The symbol =before-p= is the name of one of the arguments to =kill-append=. When the =kill-append= function is evaluated, it is bound to the value returned by evaluating the actual argument. In this case, this is the expression =(< end beg)=. This expression does not directly determine whether the killed text in this command is located before or after the kill text of the last command; what it does is determine whether the value of the variable =end= is less than the value of the variable =beg=. If it is, it means that the user is most likely heading towards the beginning of the buffer. Also, the result of evaluating the predicate expression, =(< end beg)=, will be true and the text will be prepended before the previous text. On the other hand, if the value of the variable =end= is greater than the value of the variable =beg=, the text will be appended after the previous text.

When the newly saved text will be prepended, then the string with the new text will be concatenated before the old text:

#+begin_src elisp
         (concat string cur)
#+end_src

But if the text will be appended, it will be concatenated after the old text:

#+begin_src elisp
         (concat cur string))
#+end_src

To understand how this works, we first need to review the =concat= function. The =concat= function links together or unites two strings of text. The result is a string. For example:

#+begin_src elisp
         (concat "abc" "def")
              ⇒ "abcdef"

         (concat "new "
                 (car '("first element" "second element")))
              ⇒ "new first element"

         (concat (car
                 '("first element" "second element")) " modified")
              ⇒ "first element modified"
#+end_src

We can now make sense of =kill-append=: it modifies the contents of the kill ring. The kill ring is a list, each element of which is saved text. The =kill-append= function uses the =kill-new= function which in turn uses the =setcar= function.


Previous: [[#kill_002dappend-function][kill-append function]], Up: [[#copy_002dregion_002das_002dkill-body][copy-region-as-kill body]]

*** The =kill-new= function
      :PROPERTIES:
      :CUSTOM_ID: the-kill-new-function
      :CLASS: unnumberedsubsubsec
      :END:

 In version 22 the =kill-new= function looks like this:

#+begin_src elisp
         (defun kill-new (string &optional replace yank-handler)
           "Make STRING the latest kill in the kill ring.
         Set `kill-ring-yank-pointer' to point to it.

         If `interprogram-cut-function' is non-nil, apply it to STRING.
         Optional second argument REPLACE non-nil means that STRING will replace
         the front of the kill ring, rather than being added to the list.
         ..."
           (if (> (length string) 0)
               (if yank-handler
                   (put-text-property 0 (length string)
                                      'yank-handler yank-handler string))
             (if yank-handler
                 (signal 'args-out-of-range
                         (list string "yank-handler specified for empty string"))))
           (if (fboundp 'menu-bar-update-yank-menu)
               (menu-bar-update-yank-menu string (and replace (car kill-ring))))
           (if (and replace kill-ring)
               (setcar kill-ring string)
             (push string kill-ring)
             (if (> (length kill-ring) kill-ring-max)
                 (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
           (setq kill-ring-yank-pointer kill-ring)
           (if interprogram-cut-function
               (funcall interprogram-cut-function string (not replace))))
#+end_src

(Notice that the function is not interactive.)

As usual, we can look at this function in parts.

The function definition has an optional =yank-handler= argument, which when invoked tells the function how to deal with properties added to the text, such as bold or italics. We will skip that.

The first line of the documentation makes sense:

#+begin_src elisp
         Make STRING the latest kill in the kill ring.
#+end_src

Let's skip over the rest of the documentation for the moment.

Also, let's skip over the initial =if= expression and those lines of code involving =menu-bar-update-yank-menu=. We will explain them below.

The critical lines are these:

#+begin_src elisp
           (if (and replace kill-ring)
               ;; then
               (setcar kill-ring string)
             ;; else
             (push string kill-ring)
             (if (> (length kill-ring) kill-ring-max)
                 ;; avoid overly long kill ring
                 (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil)))
           (setq kill-ring-yank-pointer kill-ring)
           (if interprogram-cut-function
               (funcall interprogram-cut-function string (not replace))))
#+end_src

The conditional test is =(and replace kill-ring)=. This will be true when two conditions are met: the kill ring has something in it, and the =replace= variable is true.

When the =kill-append= function sets =replace= to be true and when the kill ring has at least one item in it, the =setcar= expression is executed:

#+begin_src elisp
         (setcar kill-ring string)
#+end_src

The =setcar= function actually changes the first element of the =kill-ring= list to the value of =string=. It replaces the first element.

On the other hand, if the kill ring is empty, or replace is false, the else-part of the condition is executed:

#+begin_src elisp
         (push string kill-ring)
#+end_src

=push= puts its first argument onto the second. It is similar to the older

#+begin_src elisp
         (setq kill-ring (cons string kill-ring))
#+end_src

or the newer

#+begin_src elisp
         (add-to-list kill-ring string)
#+end_src

When it is false, the expression first constructs a new version of the kill ring by prepending =string= to the existing kill ring as a new element (that is what the =push= does). Then it executes a second =if= clause. This second =if= clause keeps the kill ring from growing too long.

Let's look at these two expressions in order.

The =push= line of the else-part sets the new value of the kill ring to what results from adding the string being killed to the old kill ring.

We can see how this works with an example.

First,

#+begin_src elisp
         (setq example-list '("here is a clause" "another clause"))
#+end_src

After evaluating this expression with C-x C-e, you can evaluate =example-list= and see what it returns:

#+begin_src elisp
         example-list
              ⇒ ("here is a clause" "another clause")
#+end_src

Now, we can add a new element on to this list by evaluating the following expression:

#+begin_src elisp
         (push "a third clause" example-list)
#+end_src

When we evaluate =example-list=, we find its value is:

#+begin_src elisp
         example-list
              ⇒ ("a third clause" "here is a clause" "another clause")
#+end_src

Thus, the third clause is added to the list by =push=.

Now for the second part of the =if= clause. This expression keeps the kill ring from growing too long. It looks like this:

#+begin_src elisp
         (if (> (length kill-ring) kill-ring-max)
             (setcdr (nthcdr (1- kill-ring-max) kill-ring) nil))
#+end_src

The code checks whether the length of the kill ring is greater than the maximum permitted length. This is the value of =kill-ring-max= (which is 60, by default). If the length of the kill ring is too long, then this code sets the last element of the kill ring to =nil=. It does this by using two functions, =nthcdr= and =setcdr=.

We looked at =setcdr= earlier (see [[#setcdr][=setcdr=]]). It sets the cdr of a list, just as =setcar= sets the car of a list. In this case, however, =setcdr= will not be setting the cdr of the whole kill ring; the =nthcdr= function is used to cause it to set the cdr of the next to last element of the kill ring---this means that since the cdr of the next to last element is the last element of the kill ring, it will set the last element of the kill ring.

The =nthcdr= function works by repeatedly taking the cdr of a list---it takes the cdr of the cdr of the cdr ... It does this N times and returns the results. (See [[#nthcdr][=nthcdr=]].)

Thus, if we had a four element list that was supposed to be three elements long, we could set the cdr of the next to last element to =nil=, and thereby shorten the list. (If you set the last element to some other value than =nil=, which you could do, then you would not have shortened the list. See [[#setcdr][=setcdr=]].)

You can see shortening by evaluating the following three expressions in turn. First set the value of =trees= to =(maple oak pine birch)=, then set the cdr of its second cdr to =nil= and then find the value of =trees=:

#+begin_src elisp
         (setq trees '(maple oak pine birch))
              ⇒ (maple oak pine birch)

         (setcdr (nthcdr 2 trees) nil)
              ⇒ nil

         trees
              ⇒ (maple oak pine)
#+end_src

(The value returned by the =setcdr= expression is =nil= since that is what the cdr is set to.)

To repeat, in =kill-new=, the =nthcdr= function takes the cdr a number of times that is one less than the maximum permitted size of the kill ring and =setcdr= sets the cdr of that element (which will be the rest of the elements in the kill ring) to =nil=. This prevents the kill ring from growing too long.

The next to last expression in the =kill-new= function is

#+begin_src elisp
         (setq kill-ring-yank-pointer kill-ring)
#+end_src

The =kill-ring-yank-pointer= is a global variable that is set to be the =kill-ring=.

Even though the =kill-ring-yank-pointer= is called a ‘pointer', it is a variable just like the kill ring. However, the name has been chosen to help humans understand how the variable is used.

Now, to return to an early expression in the body of the function:

#+begin_src elisp
           (if (fboundp 'menu-bar-update-yank-menu)
                (menu-bar-update-yank-menu string (and replace (car kill-ring))))
#+end_src

It starts with an =if= expression

In this case, the expression tests first to see whether =menu-bar-update-yank-menu= exists as a function, and if so, calls it. The =fboundp= function returns true if the symbol it is testing has a function definition that is not void. If the symbol's function definition were void, we would receive an error message, as we did when we created errors intentionally (see [[#Making-Errors][Generate an Error Message]]).

The then-part contains an expression whose first element is the function =and=.

The =and= special form evaluates each of its arguments until one of the arguments returns a value of =nil=, in which case the =and= expression returns =nil=; however, if none of the arguments returns a value of =nil=, the value resulting from evaluating the last argument is returned. (Since such a value is not =nil=, it is considered true in Emacs Lisp.) In other words, an =and= expression returns a true value only if all its arguments are true. (See [[#Second-Buffer-Related-Review][Second Buffer Related Review]].)

The expression determines whether the second argument to =menu-bar-update-yank-menu= is true or not.

=menu-bar-update-yank-menu= is one of the functions that make it possible to use the “Select and Paste” menu in the Edit item of a menu bar; using a mouse, you can look at the various pieces of text you have saved and select one piece to paste.

The last expression in the =kill-new= function adds the newly copied string to whatever facility exists for copying and pasting among different programs running in a windowing system. In the X Windowing system, for example, the =x-select-text= function takes the string and stores it in memory operated by X. You can paste the string in another program, such as an Xterm.

The expression looks like this:

#+begin_src elisp
           (if interprogram-cut-function
               (funcall interprogram-cut-function string (not replace))))
#+end_src

If an =interprogram-cut-function= exists, then Emacs executes =funcall=, which in turn calls its first argument as a function and passes the remaining arguments to it. (Incidentally, as far as I can see, this =if= expression could be replaced by an =and= expression similar to the one in the first part of the function.)

We are not going to discuss windowing systems and other programs further, but merely note that this is a mechanism that enables GNU Emacs to work easily and well with other programs.

This code for placing text in the kill ring, either concatenated with an existing element or as a new element, leads us to the code for bringing back text that has been cut out of the buffer---the yank commands. However, before discussing the yank commands, it is better to learn how lists are implemented in a computer. This will make clear such mysteries as the use of the term “pointer”. But before that, we will digress into C.


Next: [[#defvar][defvar]], Previous: [[#copy_002dregion_002das_002dkill][copy-region-as-kill]], Up: [[#Cutting-_0026-Storing-Text][Cutting & Storing Text]]

* 8.4 Digression into C
    :PROPERTIES:
    :CUSTOM_ID: digression-into-c
    :CLASS: section
    :END:

 The =copy-region-as-kill= function (see [[#copy_002dregion_002das_002dkill][=copy-region-as-kill=]]) uses the =filter-buffer-substring= function, which in turn uses the =delete-and-extract-region= function. It removes the contents of a region and you cannot get them back.

Unlike the other code discussed here, the =delete-and-extract-region= function is not written in Emacs Lisp; it is written in C and is one of the primitives of the GNU Emacs system. Since it is very simple, I will digress briefly from Lisp and describe it here.

Like many of the other Emacs primitives, =delete-and-extract-region= is written as an instance of a C macro, a macro being a template for code. The complete macro looks like this:

#+begin_src elisp
         DEFUN ("delete-and-extract-region", Fdelete_and_extract_region,
                Sdelete_and_extract_region, 2, 2, 0,
                doc: /* Delete the text between START and END and return it.  */)
                (Lisp_Object start, Lisp_Object end)
         {
           validate_region (&start, &end);
           if (XINT (start) == XINT (end))
             return empty_unibyte_string;
           return del_range_1 (XINT (start), XINT (end), 1, 1);
         }
#+end_src

Without going into the details of the macro writing process, let me point out that this macro starts with the word =DEFUN=. The word =DEFUN= was chosen since the code serves the same purpose as =defun= does in Lisp. (The =DEFUN= C macro is defined in emacs/src/lisp.h.)

The word =DEFUN= is followed by seven parts inside of parentheses:

- The first part is the name given to the function in Lisp, =delete-and-extract-region=.
- The second part is the name of the function in C, =Fdelete_and_extract_region=. By convention, it starts with ‘F'. Since C does not use hyphens in names, underscores are used instead.
- The third part is the name for the C constant structure that records information on this function for internal use. It is the name of the function in C but begins with an ‘S' instead of an ‘F'.
- The fourth and fifth parts specify the minimum and maximum number of arguments the function can have. This function demands exactly 2 arguments.
- The sixth part is nearly like the argument that follows the =interactive= declaration in a function written in Lisp: a letter followed, perhaps, by a prompt. The only difference from Lisp is when the macro is called with no arguments. Then you write a =0= (which is a null string), as in this macro.

  If you were to specify arguments, you would place them between quotation marks. The C macro for =goto-char= includes ="NGoto char: "= in this position to indicate that the function expects a raw prefix, in this case, a numerical location in a buffer, and provides a prompt.

- The seventh part is a documentation string, just like the one for a function written in Emacs Lisp. This is written as a C comment. (When you build Emacs, the program lib-src/make-docfile extracts these comments and uses them to make the documentation.)

In a C macro, the formal parameters come next, with a statement of what kind of object they are, followed by the body of the macro. For =delete-and-extract-region= the body consists of the following four lines:

#+begin_src elisp
         validate_region (&start, &end);
         if (XINT (start) == XINT (end))
           return empty_unibyte_string;
         return del_range_1 (XINT (start), XINT (end), 1, 1);
#+end_src

The =validate_region= function checks whether the values passed as the beginning and end of the region are the proper type and are within range. If the beginning and end positions are the same, then return an empty string.

The =del_range_1= function actually deletes the text. It is a complex function we will not look into. It updates the buffer and does other things. However, it is worth looking at the two arguments passed to =del_range_1=. These are =XINT (start)= and =XINT (end)=.

As far as the C language is concerned, =start= and =end= are two integers that mark the beginning and end of the region to be deleted[[#fn-12][^{12}]].

Integer widths depend on the machine, and are typically 32 or 64 bits. A few of the bits are used to specify the type of information; the remaining bits are used as content.

‘XINT' is a C macro that extracts the relevant number from the longer collection of bits; the type bits are discarded.

The command in =delete-and-extract-region= looks like this:

#+begin_src elisp
         del_range_1 (XINT (start), XINT (end), 1, 1);
#+end_src

It deletes the region between the beginning position, =start=, and the ending position, =end=.

From the point of view of the person writing Lisp, Emacs is all very simple; but hidden underneath is a great deal of complexity to make it all work.


Next: [[#cons-_0026-search_002dfwd-Review][cons & search-fwd Review]], Previous: [[#Digression-into-C][Digression into C]], Up: [[#Cutting-_0026-Storing-Text][Cutting & Storing Text]]

* 8.5 Initializing a Variable with =defvar=
    :PROPERTIES:
    :CUSTOM_ID: initializing-a-variable-with-defvar
    :CLASS: section
    :END:



The =copy-region-as-kill= function is written in Emacs Lisp. Two functions within it, =kill-append= and =kill-new=, copy a region in a buffer and save it in a variable called the =kill-ring=. This section describes how the =kill-ring= variable is created and initialized using the =defvar= special form.

(Again we note that the term =kill-ring= is a misnomer. The text that is clipped out of the buffer can be brought back; it is not a ring of corpses, but a ring of resurrectable text.)

In Emacs Lisp, a variable such as the =kill-ring= is created and given an initial value by using the =defvar= special form. The name comes from “define variable”.

The =defvar= special form is similar to =setq= in that it sets the value of a variable. It is unlike =setq= in two ways: first, it only sets the value of the variable if the variable does not already have a value. If the variable already has a value, =defvar= does not override the existing value. Second, =defvar= has a documentation string.

(There is a related macro, =defcustom=, designed for variables that people customize. It has more features than =defvar=. (See [[#defcustom][Setting Variables with =defcustom=]].)

- [[#See-variable-current-value][See variable current value]]
- [[#defvar-and-asterisk][defvar and asterisk]]


Next: [[#defvar-and-asterisk][defvar and asterisk]], Up: [[#defvar][defvar]]

** Seeing the Current Value of a Variable
     :PROPERTIES:
     :CUSTOM_ID: seeing-the-current-value-of-a-variable
     :CLASS: unnumberedsubsec
     :END:

You can see the current value of a variable, any variable, by using the =describe-variable= function, which is usually invoked by typing C-h v. If you type C-h v and then =kill-ring= (followed by <RET>) when prompted, you will see what is in your current kill ring---this may be quite a lot! Conversely, if you have been doing nothing this Emacs session except read this document, you may have nothing in it. Also, you will see the documentation for =kill-ring=:

#+begin_src elisp
         Documentation:
         List of killed text sequences.
         Since the kill ring is supposed to interact nicely with cut-and-paste
         facilities offered by window systems, use of this variable should
         interact nicely with `interprogram-cut-function' and
         `interprogram-paste-function'.  The functions `kill-new',
         `kill-append', and `current-kill' are supposed to implement this
         interaction; you may want to use them instead of manipulating the kill
         ring directly.
#+end_src

The kill ring is defined by a =defvar= in the following way:

#+begin_src elisp
         (defvar kill-ring nil
           "List of killed text sequences.
         ...")
#+end_src

In this variable definition, the variable is given an initial value of =nil=, which makes sense, since if you have saved nothing, you want nothing back if you give a =yank= command. The documentation string is written just like the documentation string of a =defun=. As with the documentation string of the =defun=, the first line of the documentation should be a complete sentence, since some commands, like =apropos=, print only the first line of documentation. Succeeding lines should not be indented; otherwise they look odd when you use C-h v (=describe-variable=).


Previous: [[#See-variable-current-value][See variable current value]], Up: [[#defvar][defvar]]

** 8.5.1 =defvar= and an asterisk
     :PROPERTIES:
     :CUSTOM_ID: defvar-and-an-asterisk
     :CLASS: subsection
     :END:

 In the past, Emacs used the =defvar= special form both for internal variables that you would not expect a user to change and for variables that you do expect a user to change. Although you can still use =defvar= for user customizable variables, please use =defcustom= instead, since it provides a path into the Customization commands. (See [[#defcustom][Specifying Variables using =defcustom=]].)

When you specified a variable using the =defvar= special form, you could distinguish a variable that a user might want to change from others by typing an asterisk, ‘*', in the first column of its documentation string. For example:

#+begin_src elisp
         (defvar shell-command-default-error-buffer nil
           "*Buffer name for `shell-command' ... error output.
         ... ")
#+end_src

You could (and still can) use the =set-variable= command to change the value of =shell-command-default-error-buffer= temporarily. However, options set using =set-variable= are set only for the duration of your editing session. The new values are not saved between sessions. Each time Emacs starts, it reads the original value, unless you change the value within your .emacs file, either by setting it manually or by using =customize=. See [[#Emacs-Initialization][Your .emacs File]].

For me, the major use of the =set-variable= command is to suggest variables that I might want to set in my .emacs file. There are now more than 700 such variables, far too many to remember readily. Fortunately, you can press <TAB> after calling the =M-x set-variable= command to see the list of variables. (See [[https://www.gnu.org/software/emacs/manual/html_mono/emacs.html#Examining][Examining and Setting Variables]].)


Next: [[#search-Exercises][search Exercises]], Previous: [[#defvar][defvar]], Up: [[#Cutting-_0026-Storing-Text][Cutting & Storing Text]]

* 8.6 Review
    :PROPERTIES:
    :CUSTOM_ID: review-3
    :CLASS: section
    :END:

Here is a brief summary of some recently introduced functions.

- =car=\\
  =cdr= :: =car= returns the first element of a list; =cdr= returns the second and subsequent elements of a list.

  For example:

  #+begin_src elisp
                (car '(1 2 3 4 5 6 7))
                     ⇒ 1
                (cdr '(1 2 3 4 5 6 7))
                     ⇒ (2 3 4 5 6 7)
  #+end_src

  \\

- =cons= :: =cons= constructs a list by prepending its first argument to its second argument.

  For example:

  #+begin_src elisp
                (cons 1 '(2 3 4))
                     ⇒ (1 2 3 4)
  #+end_src

  \\

- =funcall= :: =funcall= evaluates its first argument as a function. It passes its remaining arguments to its first argument.\\
- =nthcdr= :: Return the result of taking cdr n times on a list. The “rest of the rest”, as it were.

  For example:

  #+begin_src elisp
                (nthcdr 3 '(1 2 3 4 5 6 7))
                     ⇒ (4 5 6 7)
  #+end_src

  \\

- =setcar=\\
  =setcdr= :: =setcar= changes the first element of a list; =setcdr= changes the second and subsequent elements of a list.

  For example:

  #+begin_src elisp
                (setq triple '(1 2 3))

                (setcar triple '37)

                triple
                     ⇒ (37 2 3)

                (setcdr triple '("foo" "bar"))

                triple
                     ⇒ (37 "foo" "bar")
  #+end_src

  \\

- =progn= :: Evaluate each argument in sequence and then return the value of the last.

  For example:

  #+begin_src elisp
                (progn 1 2 3 4)
                     ⇒ 4
  #+end_src

  \\

- =save-restriction= :: Record whatever narrowing is in effect in the current buffer, if any, and restore that narrowing after evaluating the arguments.\\
- =search-forward= :: Search for a string, and if the string is found, move point. With a regular expression, use the similar =re-search-forward=. (See [[#Regexp-Search][Regular Expression Searches]], for an explanation of regular expression patterns and searches.)

  =search-forward= and =re-search-forward= take four arguments:

  1. The string or regular expression to search for.
  2. Optionally, the limit of the search.
  3. Optionally, what to do if the search fails, return =nil= or an error message.
  4. Optionally, how many times to repeat the search; if negative, the search goes backwards.

  \\

- =kill-region=\\
  =delete-and-extract-region=\\
  =copy-region-as-kill= :: =kill-region= cuts the text between point and mark from the buffer and stores that text in the kill ring, so you can get it back by yanking.

  =copy-region-as-kill= copies the text between point and mark into the kill ring, from which you can get it by yanking. The function does not cut or remove the text from the buffer.

=delete-and-extract-region= removes the text between point and mark from the buffer and throws it away. You cannot get it back. (This is not an interactive command.)


Previous: [[#cons-_0026-search_002dfwd-Review][cons & search-fwd Review]], Up: [[#Cutting-_0026-Storing-Text][Cutting & Storing Text]]

* 8.7 Searching Exercises
    :PROPERTIES:
    :CUSTOM_ID: searching-exercises
    :CLASS: section
    :END:

- Write an interactive function that searches for a string. If the search finds the string, leave point after it and display a message that says “Found!”. (Do not use =search-forward= for the name of this function; if you do, you will overwrite the existing version of =search-forward= that comes with Emacs. Use a name such as =test-search= instead.)
- Write a function that prints the third element of the kill ring in the echo area, if any; if the kill ring does not contain a third element, print an appropriate message.


Next: [[#Yanking][Yanking]], Previous: [[#Cutting-_0026-Storing-Text][Cutting & Storing Text]], Up: [[#Top][Top]]
